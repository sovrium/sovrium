name: Test
permissions:
  contents: read
  actions: write
  issues: write
  pull-requests: write

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main]

# Concurrency control: Cancel PRs (fast feedback), complete main (spec updates)
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

env:
  # Infrastructure retry configuration
  MAX_E2E_RETRIES: 2
  E2E_RETRY_DELAY_SECONDS: 30
  # Sharding configuration (8 shards √ó 2 workers = 16 effective workers)
  E2E_SHARD_TOTAL: 8

jobs:
  # ============================================================================
  # CHANGE TYPE DETECTION
  # Detects test-only changes (e.g., .fixme() removal) for reduced CI
  # ============================================================================

  detect-change-type:
    name: Detect Change Type
    if: github.event_name == 'pull_request' && github.event.action != 'closed'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      is_test_only: ${{ steps.detect.outputs.is_test_only }}
      target_spec: ${{ steps.detect.outputs.target_spec }}
      is_tdd_automation: ${{ steps.detect.outputs.is_tdd_automation }}
      is_fixme_removal_only: ${{ steps.detect.outputs.is_fixme_removal_only }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Detect test-only changes
        id: detect
        env:
          GH_TOKEN: ${{ github.token }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          HAS_TDD_LABEL: ${{ contains(github.event.pull_request.labels.*.name, 'tdd-automation') }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          RESULT=$(bun run scripts/tdd-automation/workflows/test/detect-change-type.ts 2>&1)
          IS_TEST_ONLY=$(echo "$RESULT" | tail -1 | jq -r '.isTestOnly')
          TARGET_SPEC=$(echo "$RESULT" | tail -1 | jq -r '.targetSpec')
          IS_TDD_AUTOMATION=$(echo "$RESULT" | tail -1 | jq -r '.isTDDAutomation')
          IS_FIXME_REMOVAL_ONLY=$(echo "$RESULT" | tail -1 | jq -r '.isFixmeRemovalOnly')

          echo "is_test_only=$IS_TEST_ONLY" >> $GITHUB_OUTPUT
          echo "target_spec=$TARGET_SPEC" >> $GITHUB_OUTPUT
          echo "is_tdd_automation=$IS_TDD_AUTOMATION" >> $GITHUB_OUTPUT
          echo "is_fixme_removal_only=$IS_FIXME_REMOVAL_ONLY" >> $GITHUB_OUTPUT

  # ============================================================================
  # PARALLEL STATIC ANALYSIS JOBS
  # These run simultaneously to reduce wall-clock time
  # Skipped for test-only changes to speed up CI
  # ============================================================================

  lint:
    name: Lint
    needs: [detect-change-type]
    # Skip lint for test-only changes (spec files have separate lint rules)
    # Always run on push to main, skip on PR if test-only
    # Note: always() allows this job to run even when detect-change-type is skipped (push events)
    if: |
      always() &&
      (
        (github.event_name == 'push') ||
        (github.event.action != 'closed' && needs.detect-change-type.outputs.is_test_only != 'true')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Cache ESLint results
        uses: actions/cache@v4
        with:
          path: .eslintcache
          key: ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('eslint.config.ts') }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('eslint.config.ts') }}-
            ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-

      - name: Lint code
        run: bun run lint

  typecheck:
    name: TypeCheck
    needs: [detect-change-type]
    # TypeCheck always runs (spec files have TypeScript that needs validation)
    # EXCEPT for pure .fixme() removals (typecheck guaranteed to pass)
    # Note: always() allows this job to run even when detect-change-type is skipped (push events)
    # When detect-change-type runs (PR events), skip if is_fixme_removal_only == 'true'
    # When detect-change-type is skipped (push events), always run TypeCheck
    if: |
      always() &&
      (github.event_name == 'push' || github.event.action != 'closed') &&
      (
        needs.detect-change-type.result == 'skipped' ||
        needs.detect-change-type.outputs.is_fixme_removal_only != 'true'
      )
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Type check
        run: bun run typecheck

  unit-tests:
    name: Unit Tests
    needs: [detect-change-type]
    # Skip unit tests for test-only changes (no production code changed)
    # Note: always() allows this job to run even when detect-change-type is skipped (push events)
    if: |
      always() &&
      (
        (github.event_name == 'push') ||
        (github.event.action != 'closed' && needs.detect-change-type.outputs.is_test_only != 'true')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run unit tests
        run: bun test:unit

  # ============================================================================
  # E2E TESTS WITH SHARDING
  # 8 shards running in parallel, each with 2 workers = 16 effective workers
  # ============================================================================

  # E2E for test-only changes or .fixme() removal: Run only target spec (fast path)
  # - is_test_only: Test file changed (typecheck + E2E target)
  # - is_fixme_removal_only: .fixme() removed (typecheck skipped, E2E target only)
  e2e-target:
    name: E2E Target Spec
    if: |
      always() &&
      github.event_name == 'pull_request' &&
      github.event.action != 'closed' &&
      (needs.detect-change-type.outputs.is_test_only == 'true' ||
       needs.detect-change-type.outputs.is_fixme_removal_only == 'true') &&
      (needs.typecheck.result == 'success' || needs.typecheck.result == 'skipped')
    needs: [detect-change-type, typecheck]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Get Playwright version
        id: playwright-version
        run: echo "version=$(bun pm ls @playwright/test | grep '@playwright/test' | awk '{print $2}' | head -n 1)" >> $GITHUB_OUTPUT

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ steps.playwright-version.outputs.version }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: bunx playwright install --with-deps chromium

      - name: Pre-pull Docker images
        run: |
          echo "üê≥ Pre-pulling Docker images..."

          # Pull with retry logic for registry resilience
          pull_with_retry() {
            local image=$1
            local max_attempts=3

            for attempt in $(seq 1 $max_attempts); do
              echo "  Pulling $image (attempt $attempt/$max_attempts)..."
              if docker pull "$image" 2>&1; then
                echo "  ‚úÖ $image pulled successfully"
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                echo "  ‚ö†Ô∏è Pull failed, waiting 10s before retry..."
                sleep 10
              fi
            done

            # Check if image exists locally (from cache)
            if docker image inspect "$image" > /dev/null 2>&1; then
              echo "  ‚ÑπÔ∏è Using cached image for $image"
              return 0
            fi

            echo "  ‚ùå Failed to pull $image after $max_attempts attempts"
            return 1
          }

          # Track failures for reporting
          FAILED_IMAGES=""

          # Pull images with fallback behavior
          if ! pull_with_retry "axllent/mailpit:latest"; then
            FAILED_IMAGES="$FAILED_IMAGES mailpit"
          fi

          if ! pull_with_retry "postgres:16-alpine"; then
            FAILED_IMAGES="$FAILED_IMAGES postgres"
          fi

          if [ -n "$FAILED_IMAGES" ]; then
            echo ""
            echo "‚ö†Ô∏è Some images failed to pull:$FAILED_IMAGES"
            echo "   Tests may fail if images are not cached locally"
            echo "   This could indicate Docker Hub is experiencing issues"
          else
            echo "‚úÖ All Docker images ready"
          fi
        continue-on-error: true

      - name: Verify Docker ready
        run: |
          docker info > /dev/null 2>&1 || { echo "‚ùå Docker not running"; exit 1; }
          echo "‚úÖ Docker daemon ready"

      - name: Run target spec only
        id: e2e
        env:
          TARGET_SPEC: ${{ needs.detect-change-type.outputs.target_spec }}
          CI_WORKERS: 2
          # JSON reporter outputs to this file
          PLAYWRIGHT_JSON_OUTPUT_NAME: test-results.json
        run: |
          echo "üéØ Running target spec only (test-only fast path)..."
          echo "Target: $TARGET_SPEC"

          if [ -n "$TARGET_SPEC" ] && [ -f "$TARGET_SPEC" ]; then
            echo "üß™ Running: bunx playwright test $TARGET_SPEC"
            bunx playwright test "$TARGET_SPEC" --reporter=github,json
            # Move JSON results to predictable location
            if [ -f "test-results.json" ]; then
              mv test-results.json "test-results-target-spec.json"
            fi
          else
            echo "‚ö†Ô∏è  Target spec not found, running @regression tests that match changed files..."
            # Fall back to running changed spec files
            CHANGED_SPECS=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD | grep '\.spec\.ts$' || true)
            if [ -n "$CHANGED_SPECS" ]; then
              echo "Running: $CHANGED_SPECS"
              bunx playwright test $CHANGED_SPECS --reporter=github,json
              # Move JSON results to predictable location
              if [ -f "test-results.json" ]; then
                mv test-results.json "test-results-target-spec.json"
              fi
            else
              echo "‚úÖ No spec files to run"
            fi
          fi

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-target-spec
          path: test-results/
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload JSON test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: json-results-target-spec
          path: test-results-target-spec.json
          retention-days: 7
          if-no-files-found: ignore

  # E2E for normal changes: Full 8-shard regression suite
  e2e:
    name: E2E Shard ${{ matrix.shard }}/${{ matrix.total }}
    # Run full shards only when NOT test-only (or on push to main)
    # Note: always() allows this job to run even when detect-change-type is skipped (push events)
    # On push events, we verify lint/typecheck/unit-tests succeeded before running E2E
    if: |
      always() &&
      (
        (github.event_name == 'push' && needs.lint.result == 'success' && needs.typecheck.result == 'success' && needs.unit-tests.result == 'success') ||
        (github.event.action != 'closed' && needs.detect-change-type.outputs.is_test_only != 'true' && needs.lint.result == 'success' && needs.typecheck.result == 'success' && needs.unit-tests.result == 'success')
      )
    needs: [detect-change-type, lint, typecheck, unit-tests]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        shard: [1, 2, 3, 4, 5, 6, 7, 8]
        total: [8]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Get Playwright version
        id: playwright-version
        run: echo "version=$(bun pm ls @playwright/test | grep '@playwright/test' | awk '{print $2}' | head -n 1)" >> $GITHUB_OUTPUT

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ steps.playwright-version.outputs.version }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: bunx playwright install --with-deps chromium

      - name: Pre-pull Docker images
        run: |
          echo "üê≥ Pre-pulling Docker images..."

          # Pull with retry logic for registry resilience
          pull_with_retry() {
            local image=$1
            local max_attempts=3

            for attempt in $(seq 1 $max_attempts); do
              echo "  Pulling $image (attempt $attempt/$max_attempts)..."
              if docker pull "$image" 2>&1; then
                echo "  ‚úÖ $image pulled successfully"
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                echo "  ‚ö†Ô∏è Pull failed, waiting 10s before retry..."
                sleep 10
              fi
            done

            # Check if image exists locally (from cache)
            if docker image inspect "$image" > /dev/null 2>&1; then
              echo "  ‚ÑπÔ∏è Using cached image for $image"
              return 0
            fi

            echo "  ‚ùå Failed to pull $image after $max_attempts attempts"
            return 1
          }

          # Track failures for reporting
          FAILED_IMAGES=""

          # Pull images with fallback behavior
          if ! pull_with_retry "axllent/mailpit:latest"; then
            FAILED_IMAGES="$FAILED_IMAGES mailpit"
          fi

          if ! pull_with_retry "postgres:16-alpine"; then
            FAILED_IMAGES="$FAILED_IMAGES postgres"
          fi

          if [ -n "$FAILED_IMAGES" ]; then
            echo ""
            echo "‚ö†Ô∏è Some images failed to pull:$FAILED_IMAGES"
            echo "   Tests may fail if images are not cached locally"
            echo "   This could indicate Docker Hub is experiencing issues"
          else
            echo "‚úÖ All Docker images ready"
          fi
        continue-on-error: true

      - name: Verify Docker ready
        run: |
          docker info > /dev/null 2>&1 || { echo "‚ùå Docker not running"; exit 1; }
          echo "‚úÖ Docker daemon ready"

      - name: Run E2E tests (shard ${{ matrix.shard }}/${{ matrix.total }})
        id: e2e
        run: |
          echo "üß™ Running E2E shard ${{ matrix.shard }} of ${{ matrix.total }}..."
          # Use JSON reporter alongside default for reliable failure parsing
          bunx playwright test --grep "@regression" --shard=${{ matrix.shard }}/${{ matrix.total }} \
            --reporter=github,json
          # Move JSON results to predictable location
          if [ -f "test-results.json" ]; then
            mv test-results.json "test-results-shard-${{ matrix.shard }}.json"
          fi
        continue-on-error: true
        env:
          # Use 2 workers per shard (4 shards √ó 2 workers = 8 effective workers)
          CI_WORKERS: 2
          # JSON reporter outputs to this file
          PLAYWRIGHT_JSON_OUTPUT_NAME: test-results.json

      - name: Retry E2E tests on failure
        id: e2e-retry
        if: steps.e2e.outcome == 'failure'
        run: |
          echo "‚ö†Ô∏è E2E shard ${{ matrix.shard }} failed, retrying..."
          sleep ${{ env.E2E_RETRY_DELAY_SECONDS }}

          # Cleanup stale containers
          docker ps -aq --filter "name=sovrium-" | xargs -r docker rm -f 2>/dev/null || true
          docker ps -aq --filter "name=mailpit" | xargs -r docker rm -f 2>/dev/null || true

          echo "üîÑ Retrying shard ${{ matrix.shard }}..."
          # Use JSON reporter alongside default for reliable failure parsing
          bunx playwright test --grep "@regression" --shard=${{ matrix.shard }}/${{ matrix.total }} \
            --reporter=github,json
          # Move JSON results to predictable location (overwrite previous if exists)
          if [ -f "test-results.json" ]; then
            mv test-results.json "test-results-shard-${{ matrix.shard }}.json"
          fi
        env:
          CI_WORKERS: 2
          PLAYWRIGHT_JSON_OUTPUT_NAME: test-results.json

      - name: E2E shard final status
        if: always()
        run: |
          if [ "${{ steps.e2e.outcome }}" = "success" ]; then
            echo "‚úÖ Shard ${{ matrix.shard }} passed on first attempt"
          elif [ "${{ steps.e2e-retry.outcome }}" = "success" ]; then
            echo "‚úÖ Shard ${{ matrix.shard }} passed on retry"
          else
            echo "‚ùå Shard ${{ matrix.shard }} failed"
            exit 1
          fi

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-shard-${{ matrix.shard }}
          path: test-results/
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload JSON test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: json-results-shard-${{ matrix.shard }}
          path: test-results-shard-${{ matrix.shard }}.json
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload Playwright report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-shard-${{ matrix.shard }}
          path: playwright-report/
          retention-days: 7
          if-no-files-found: ignore

  # ============================================================================
  # E2E RESULTS AGGREGATION
  # Merges results from all shards and handles regression classification
  # ============================================================================

  e2e-results:
    name: E2E Results
    if: always() && (github.event_name == 'push' || github.event.action != 'closed')
    needs: [detect-change-type, e2e, e2e-target]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      e2e_failed: ${{ steps.check.outputs.e2e_failed }}
      has_regressions: ${{ steps.classify-failures.outputs.has_regressions }}
      regression_specs: ${{ steps.classify-failures.outputs.regression_specs }}
      target_spec: ${{ steps.classify-failures.outputs.target_spec }}
      failure_type: ${{ steps.classify-failures.outputs.failure_type }}
      infra_error_type: ${{ steps.classify-failures.outputs.infra_error_type }}
      is_test_only: ${{ needs.detect-change-type.outputs.is_test_only }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          pattern: test-results-*
          path: all-test-results/
          merge-multiple: false
        continue-on-error: true

      - name: Download all JSON test results
        uses: actions/download-artifact@v4
        with:
          pattern: json-results-*
          path: all-json-results/
          merge-multiple: false
        continue-on-error: true

      - name: Check E2E results
        id: check
        env:
          IS_TEST_ONLY: ${{ needs.detect-change-type.outputs.is_test_only }}
        run: |
          echo "üìä Checking E2E results..."
          echo "   Test-only mode: $IS_TEST_ONLY"

          FAILED="false"

          # Check the appropriate job based on change type
          if [ "$IS_TEST_ONLY" = "true" ]; then
            # Test-only: check e2e-target job
            E2E_TARGET_RESULT="${{ needs.e2e-target.result }}"
            echo "   E2E Target result: $E2E_TARGET_RESULT"

            if [ "$E2E_TARGET_RESULT" = "failure" ]; then
              FAILED="true"
              echo "‚ùå E2E target spec failed"
            elif [ "$E2E_TARGET_RESULT" = "success" ]; then
              echo "‚úÖ E2E target spec passed (fast path)"
            else
              echo "‚ö†Ô∏è  E2E target result: $E2E_TARGET_RESULT"
            fi
          else
            # Normal: check e2e shards job
            E2E_RESULT="${{ needs.e2e.result }}"
            echo "   E2E Shards result: $E2E_RESULT"

            if [ "$E2E_RESULT" = "failure" ]; then
              FAILED="true"
              echo "‚ùå One or more E2E shards failed"
            elif [ "$E2E_RESULT" = "success" ]; then
              echo "‚úÖ All E2E shards passed"
            else
              echo "‚ö†Ô∏è  E2E result: $E2E_RESULT"
            fi
          fi

          echo "e2e_failed=$FAILED" >> $GITHUB_OUTPUT

      - name: Classify test failures
        id: classify-failures
        if: |
          (needs.e2e.result == 'failure' || needs.e2e-target.result == 'failure') &&
          contains(github.event.pull_request.labels.*.name, 'tdd-automation')
        env:
          TEST_RESULTS_DIR: all-test-results
          JSON_RESULTS_DIR: all-json-results
          TARGET_SPEC: ${{ needs.detect-change-type.outputs.target_spec }}
        run: |
          RESULT=$(bun run scripts/tdd-automation/workflows/test/classify-failures.ts 2>&1)

          # Parse JSON output (last line is JSON, earlier lines are logs to stderr)
          HAS_REGRESSIONS=$(echo "$RESULT" | tail -1 | jq -r '.hasRegressions')
          REGRESSION_SPECS=$(echo "$RESULT" | tail -1 | jq -r '.regressionSpecs | join(",")')
          TARGET_SPEC_OUT=$(echo "$RESULT" | tail -1 | jq -r '.targetSpec')
          FAILURE_TYPE=$(echo "$RESULT" | tail -1 | jq -r '.failureType')
          INFRA_ERROR_TYPE=$(echo "$RESULT" | tail -1 | jq -r '.infraErrorType // ""')

          echo "has_regressions=$HAS_REGRESSIONS" >> $GITHUB_OUTPUT
          echo "regression_specs=$REGRESSION_SPECS" >> $GITHUB_OUTPUT
          echo "target_spec=$TARGET_SPEC_OUT" >> $GITHUB_OUTPUT
          echo "failure_type=$FAILURE_TYPE" >> $GITHUB_OUTPUT
          echo "infra_error_type=$INFRA_ERROR_TYPE" >> $GITHUB_OUTPUT

      - name: Add target failure label
        if: |
          (needs.e2e.result == 'failure' || needs.e2e-target.result == 'failure') &&
          contains(github.event.pull_request.labels.*.name, 'tdd-automation') &&
          steps.classify-failures.outputs.failure_type == 'target_only'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          echo "üè∑Ô∏è  Adding failure:spec label to PR #$PR_NUMBER (target-only failure)"
          gh pr edit "$PR_NUMBER" --add-label "failure:spec" || true

      - name: Add infrastructure failure label
        if: |
          (needs.e2e.result == 'failure' || needs.e2e-target.result == 'failure') &&
          contains(github.event.pull_request.labels.*.name, 'tdd-automation') &&
          steps.classify-failures.outputs.failure_type == 'infrastructure'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_BODY: ${{ github.event.pull_request.body }}
          INFRA_ERROR_TYPE: ${{ steps.classify-failures.outputs.infra_error_type }}
        run: |
          echo "üè∑Ô∏è  Adding failure:infra label to PR #$PR_NUMBER (infrastructure error: $INFRA_ERROR_TYPE)"
          gh pr edit "$PR_NUMBER" --add-label "failure:infra" || true

          # Also update the linked issue to maintain consistent state
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oE 'Closes #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")
          if [ -n "$ISSUE_NUMBER" ]; then
            echo "üè∑Ô∏è  Adding failure:infra label to linked issue #$ISSUE_NUMBER"
            gh issue edit "$ISSUE_NUMBER" --add-label "failure:infra" || true
          fi

          # Post comment explaining infrastructure error using heredoc
          cat << 'EOF' > /tmp/infra-error.md
          ## üîß Infrastructure Error Detected

          **This is NOT a code regression** - it's an environment/infrastructure issue.

          **Error Type**: `$INFRA_ERROR_TYPE`

          **What this means**:
          - The test failures are caused by CI environment issues, not your code changes
          - The TDD Monitor will automatically retry this PR
          - No code changes are needed to fix this

          **Common causes**:
          - `playwright_browser_missing`: Playwright browser cache miss
          - `network_error`: Transient network connectivity issues
          - `docker_error`: Docker service unavailable
          - `resource_exhaustion`: Runner ran out of memory
          - `browser_context_closed`: Browser context prematurely closed
          - `test_timeout`: Test execution timeout exceeded

          ---
          *ü§ñ Infrastructure Error Handler*
          EOF

          envsubst < /tmp/infra-error.md > /tmp/infra-error-final.md
          gh pr comment "$PR_NUMBER" --body-file /tmp/infra-error-final.md

      - name: Fail if E2E tests failed
        if: steps.check.outputs.e2e_failed == 'true'
        env:
          IS_TEST_ONLY: ${{ needs.detect-change-type.outputs.is_test_only }}
        run: |
          if [ "$IS_TEST_ONLY" = "true" ]; then
            echo "‚ùå E2E target spec failed - see test results for details"
          else
            echo "‚ùå E2E tests failed - see individual shard results for details"
          fi
          exit 1

  # ============================================================================
  # FINAL STATUS CHECK
  # Single rollup job that branch protection can require
  # Aggregates results from all parallel jobs
  # ============================================================================

  test:
    name: Test
    if: always() && (github.event_name == 'push' || github.event.action != 'closed')
    needs: [detect-change-type, lint, typecheck, unit-tests, e2e-results]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      all-passed: ${{ steps.check-all.outputs.all-passed }}
    steps:
      - name: Check all jobs passed
        id: check-all
        env:
          IS_TEST_ONLY: ${{ needs.detect-change-type.outputs.is_test_only }}
        run: |
          echo "üìä Checking results from all parallel jobs..."
          echo "   Test-only mode: $IS_TEST_ONLY"
          echo ""
          echo "  Detect:     ${{ needs.detect-change-type.result }}"
          echo "  Lint:       ${{ needs.lint.result }}"
          echo "  TypeCheck:  ${{ needs.typecheck.result }}"
          echo "  Unit Tests: ${{ needs.unit-tests.result }}"
          echo "  E2E:        ${{ needs.e2e-results.result }}"
          echo ""

          FAILED=""

          # For test-only changes, lint and unit-tests are skipped (acceptable)
          # For normal changes, all jobs must pass
          LINT_RESULT="${{ needs.lint.result }}"
          TYPECHECK_RESULT="${{ needs.typecheck.result }}"
          UNIT_RESULT="${{ needs.unit-tests.result }}"
          E2E_RESULT="${{ needs.e2e-results.result }}"

          # Lint: skipped is OK for test-only, otherwise must be success
          if [ "$IS_TEST_ONLY" = "true" ]; then
            if [ "$LINT_RESULT" != "success" ] && [ "$LINT_RESULT" != "skipped" ]; then
              FAILED="${FAILED}Lint, "
            fi
          else
            if [ "$LINT_RESULT" != "success" ]; then
              FAILED="${FAILED}Lint, "
            fi
          fi

          # TypeCheck: skipped is OK for test-only, otherwise must be success
          if [ "$IS_TEST_ONLY" = "true" ]; then
            if [ "$TYPECHECK_RESULT" != "success" ] && [ "$TYPECHECK_RESULT" != "skipped" ]; then
              FAILED="${FAILED}TypeCheck, "
            fi
          else
            if [ "$TYPECHECK_RESULT" != "success" ]; then
              FAILED="${FAILED}TypeCheck, "
            fi
          fi

          # Unit Tests: skipped is OK for test-only, otherwise must be success
          if [ "$IS_TEST_ONLY" = "true" ]; then
            if [ "$UNIT_RESULT" != "success" ] && [ "$UNIT_RESULT" != "skipped" ]; then
              FAILED="${FAILED}Unit Tests, "
            fi
          else
            if [ "$UNIT_RESULT" != "success" ]; then
              FAILED="${FAILED}Unit Tests, "
            fi
          fi

          # E2E: always required
          if [ "$E2E_RESULT" != "success" ]; then
            FAILED="${FAILED}E2E, "
          fi

          if [ -n "$FAILED" ]; then
            echo "‚ùå Failed jobs: ${FAILED%, }"
            exit 1
          fi

          if [ "$IS_TEST_ONLY" = "true" ]; then
            echo "‚úÖ All jobs passed! (test-only fast path - lint & unit tests skipped)"
          else
            echo "‚úÖ All jobs passed!"
          fi

          # Set output for dependent jobs
          echo "all-passed=true" >> "$GITHUB_OUTPUT"

      - name: Re-enable auto-merge on success
        if: |
          github.event_name == 'pull_request' &&
          contains(github.event.pull_request.labels.*.name, 'tdd-automation') &&
          !contains(github.event.pull_request.labels.*.name, 'tdd-automation:manual-intervention')
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          echo "‚úÖ All checks passed, ensuring auto-merge is enabled"
          gh pr merge "$PR_NUMBER" --squash --auto || {
            echo "‚ö†Ô∏è Could not enable auto-merge (may already be enabled or PR not mergeable)"
            exit 0
          }

  # ============================================================================
  # SPEC PROGRESS AUTO-UPDATE
  # Updates SPEC-PROGRESS.md after successful test runs
  # ============================================================================

  update-spec-progress:
    name: Update Spec Progress
    if: |
      needs.test.outputs.all-passed == 'true' &&
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main'
    needs: [test]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Debug condition values
        run: |
          echo "üîç Spec progress update triggered"
          echo "   Event: ${{ github.event_name }}"
          echo "   Ref: ${{ github.ref }}"
          echo "   All tests passed: ${{ needs.test.outputs.all-passed }}"
          echo ""
          echo "‚úÖ Proceeding with spec progress update"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Analyze spec progress
        run: bun run analyze:spec

      - name: Commit spec progress updates
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if SPEC-PROGRESS.md changed
          if git diff --quiet SPEC-PROGRESS.md; then
            echo "‚úÖ No changes to SPEC-PROGRESS.md"
          else
            echo "üìù Committing SPEC-PROGRESS.md updates..."
            git add SPEC-PROGRESS.md
            git commit -m "chore: update spec progress [skip ci]"
            git push
            echo "‚úÖ SPEC-PROGRESS.md updated and pushed"
          fi

  # ============================================================================
  # TDD AUTOMATION JOBS
  #
  # These jobs handle TDD lifecycle events that must run IMMEDIATELY on PR events.
  # They complement tdd-monitor.yml which provides SCHEDULED RECOVERY as backup.
  #

  delete-tdd-branch:
    name: Delete TDD Branch on PR Close
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == false &&
      (startsWith(github.event.pull_request.head.ref, 'tdd/') ||
       startsWith(github.event.pull_request.head.ref, 'claude/'))
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Delete branch
        run: |
          BRANCH="${{ github.event.pull_request.head.ref }}"
          echo "üóëÔ∏è  Deleting unmerged branch: $BRANCH"

          gh api \
            --method DELETE \
            /repos/${{ github.repository }}/git/refs/heads/$BRANCH \
            && echo "‚úÖ Branch deleted successfully" \
            || echo "‚ö†Ô∏è  Branch may already be deleted"
        env:
          GH_TOKEN: ${{ github.token }}

  # ============================================================================
  # TDD AUTOMATION: TRIGGER CLAUDE CODE ON FAILURE
  #
  # When a TDD PR fails tests, increment attempt counter and trigger Claude Code.
  # After max attempts, move to manual intervention.
  # ============================================================================

  tdd-handle-failure:
    name: TDD Handle Failure
    # Detect TDD PR via label OR branch name (backup per spec)
    if: |
      always() &&
      github.event_name == 'pull_request' &&
      github.event.action != 'closed' &&
      (contains(github.event.pull_request.labels.*.name, 'tdd-automation') || startsWith(github.event.pull_request.head.ref, 'tdd/')) &&
      (
        (needs.e2e-results.outputs.e2e_failed == 'true' && needs.e2e-results.outputs.failure_type != 'infrastructure') ||
        needs.lint.result == 'failure' ||
        needs.typecheck.result == 'failure' ||
        needs.unit-tests.result == 'failure'
      )
    needs: [lint, typecheck, unit-tests, e2e-results]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Detect failure type
        id: detect-failure
        env:
          E2E_FAILED: ${{ needs.e2e-results.outputs.e2e_failed }}
          LINT_RESULT: ${{ needs.lint.result }}
          TYPECHECK_RESULT: ${{ needs.typecheck.result }}
          UNIT_RESULT: ${{ needs.unit-tests.result }}
          E2E_FAILURE_TYPE: ${{ needs.e2e-results.outputs.failure_type }}
        run: |
          echo "üìä Detecting failure type..."
          echo "   E2E failed: $E2E_FAILED"
          echo "   Lint result: $LINT_RESULT"
          echo "   TypeCheck result: $TYPECHECK_RESULT"
          echo "   Unit test result: $UNIT_RESULT"
          echo "   E2E failure type: $E2E_FAILURE_TYPE"

          # Determine overall failure type per spec (line 209)
          # Quality failure only: lint/typecheck/unit fail, but E2E passes (or no E2E ran)
          # Test failure: E2E tests fail
          if [ "$E2E_FAILED" = "true" ]; then
            echo "failure-type=$E2E_FAILURE_TYPE" >> $GITHUB_OUTPUT
            echo "üß™ Test failure detected (E2E)"
          elif [ "$LINT_RESULT" = "failure" ] || [ "$TYPECHECK_RESULT" = "failure" ] || [ "$UNIT_RESULT" = "failure" ]; then
            echo "failure-type=quality_only" >> $GITHUB_OUTPUT
            echo "üîß Quality failure detected (lint/typecheck/unit)"
          else
            echo "failure-type=unknown" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Unknown failure type"
          fi

      - name: Parse PR title for attempt info
        id: parse
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          # Parse [TDD] Implement SPEC-ID | Attempt X/Y
          SPEC_ID=$(echo "$PR_TITLE" | grep -oP '\[TDD\]\s+Implement\s+\K[A-Z]+-[A-Z-]+-(?:\d{3}|REGRESSION)' || echo "")
          ATTEMPT=$(echo "$PR_TITLE" | grep -oP 'Attempt\s+\K\d+' || echo "1")
          MAX_ATTEMPTS=$(echo "$PR_TITLE" | grep -oP 'Attempt\s+\d+/\K\d+' || echo "5")

          echo "spec-id=$SPEC_ID" >> $GITHUB_OUTPUT
          echo "attempt=$ATTEMPT" >> $GITHUB_OUTPUT
          echo "max-attempts=$MAX_ATTEMPTS" >> $GITHUB_OUTPUT

          echo "üìã Parsed: Spec=$SPEC_ID, Attempt=$ATTEMPT/$MAX_ATTEMPTS"

      - name: Increment attempt counter
        id: increment
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          CURRENT_ATTEMPT="${{ steps.parse.outputs.attempt }}"
          MAX_ATTEMPTS="${{ steps.parse.outputs.max-attempts }}"
          NEW_ATTEMPT=$((CURRENT_ATTEMPT + 1))

          echo "Incrementing attempt: $CURRENT_ATTEMPT -> $NEW_ATTEMPT (max: $MAX_ATTEMPTS)"

          if [ "$NEW_ATTEMPT" -gt "$MAX_ATTEMPTS" ]; then
            echo "exceeded=true" >> $GITHUB_OUTPUT
            echo "new-attempt=$CURRENT_ATTEMPT" >> $GITHUB_OUTPUT
          else
            echo "exceeded=false" >> $GITHUB_OUTPUT
            echo "new-attempt=$NEW_ATTEMPT" >> $GITHUB_OUTPUT

            # Update PR title
            RESULT=$(bun run scripts/tdd-automation/core/update-pr-title.ts "$PR_NUMBER" 2>&1) || true
            echo "$RESULT"
          fi

      - name: Check if this is the last test run
        id: check-last-run
        if: steps.increment.outputs.exceeded == 'false'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          BRANCH: ${{ github.event.pull_request.head.ref }}
        run: |
          echo "üîç Checking if there are other test.yml runs after this one..."

          # Query test.yml runs for this PR's branch
          # Get runs that are queued or in_progress (after this one started)
          CURRENT_RUN_ID="${{ github.run_id }}"

          PENDING_TEST_RUNS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/workflows/test.yml/runs?status=queued&branch=$BRANCH" \
            --jq ".workflow_runs | map(select(.id != $CURRENT_RUN_ID)) | length")

          IN_PROGRESS_TEST_RUNS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/workflows/test.yml/runs?status=in_progress&branch=$BRANCH" \
            --jq ".workflow_runs | map(select(.id != $CURRENT_RUN_ID)) | length")

          # Also check for pending Claude Code runs (if already triggered)
          PENDING_CLAUDE_RUNS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/workflows/claude-code.yml/runs?status=queued&branch=$BRANCH" \
            --jq '.workflow_runs | length')

          IN_PROGRESS_CLAUDE_RUNS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/workflows/claude-code.yml/runs?status=in_progress&branch=$BRANCH" \
            --jq '.workflow_runs | length')

          TOTAL_PENDING_TESTS=$((PENDING_TEST_RUNS + IN_PROGRESS_TEST_RUNS))
          TOTAL_PENDING_CLAUDE=$((PENDING_CLAUDE_RUNS + IN_PROGRESS_CLAUDE_RUNS))

          echo "üìä Status:"
          echo "   Other test.yml runs (queued/running): $TOTAL_PENDING_TESTS"
          echo "   Claude Code runs (queued/running): $TOTAL_PENDING_CLAUDE"

          # Only trigger Claude Code if:
          # 1. No other test.yml runs are pending (we're the last one)
          # 2. No Claude Code is already running (avoid duplicates)
          if [ "$TOTAL_PENDING_TESTS" -gt 0 ]; then
            echo "‚è≠Ô∏è Skipping @claude comment: $TOTAL_PENDING_TESTS test run(s) pending after this one"
            echo "   The last test.yml run will trigger Claude Code with the most recent failure"
            echo "should-trigger=false" >> "$GITHUB_OUTPUT"
          elif [ "$TOTAL_PENDING_CLAUDE" -gt 0 ]; then
            echo "‚è≠Ô∏è Skipping @claude comment: Claude Code already running or queued ($TOTAL_PENDING_CLAUDE workflow(s))"
            echo "should-trigger=false" >> "$GITHUB_OUTPUT"
          else
            echo "‚úÖ This is the last test run and no Claude Code pending - will trigger execution"
            echo "should-trigger=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Trigger Claude Code on failure
        if: steps.increment.outputs.exceeded == 'false' && steps.check-last-run.outputs.should-trigger == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          TARGET_SPEC: ${{ needs.e2e-results.outputs.target_spec || needs.detect-change-type.outputs.target_spec || 'specs/' }}
          SPEC_ID: ${{ steps.parse.outputs.spec-id }}
          NEW_ATTEMPT: ${{ steps.increment.outputs.new-attempt }}
          MAX_ATTEMPTS: ${{ steps.parse.outputs.max-attempts }}
          BRANCH: ${{ github.event.pull_request.head.ref }}
          FAILURE_TYPE: ${{ steps.detect-failure.outputs.failure-type }}
        run: |
          echo "ü§ñ Triggering Claude Code (Attempt $NEW_ATTEMPT/$MAX_ATTEMPTS)"
          echo "   Failure type: $FAILURE_TYPE"
          echo "   Target spec: $TARGET_SPEC"

          # Select agent based on failure type (per spec)
          # - quality_only: Use codebase-refactor-auditor (lint/format/type issues, not test failures)
          # - target_only: Use e2e-test-fixer (actual test failures)
          if [ "$FAILURE_TYPE" = "quality_only" ]; then
            AGENT="codebase-refactor-auditor"
            AGENT_WORKFLOW="codebase-refactor-auditor"
          else
            AGENT="e2e-test-fixer"
            AGENT_WORKFLOW="e2e-test-fixer"
          fi

          echo "   Selected agent: $AGENT"

          # Generate failure comment using TypeScript (replaces 38 lines of bash template logic)
          # Format matches spec: docs/development/tdd-automation-pipeline.md#system-prompt-templates
          bun run scripts/tdd-automation/workflows/test/generate-failure-comment.ts > /tmp/claude_comment.txt

          gh pr comment "$PR_NUMBER" --body-file /tmp/claude_comment.txt

      - name: Move to manual intervention
        if: steps.increment.outputs.exceeded == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          MAX_ATTEMPTS: ${{ steps.parse.outputs.max-attempts }}
          SPEC_ID: ${{ steps.parse.outputs.spec-id }}
        run: |
          echo "‚ö†Ô∏è Max attempts ($MAX_ATTEMPTS) exceeded - moving to manual intervention"

          # Add manual intervention label
          gh pr edit "$PR_NUMBER" --add-label "tdd-automation:manual-intervention"

          # Disable auto-merge
          gh pr merge "$PR_NUMBER" --disable-auto || true

          # Post comment (using temp file to avoid YAML parsing issues)
          {
            echo "## üõë TDD Automation: Manual Intervention Required"
            echo ""
            echo "Spec ID: \`$SPEC_ID\`"
            echo "Attempts: $MAX_ATTEMPTS/$MAX_ATTEMPTS (exhausted)"
            echo ""
            echo "The TDD automation has exhausted all automatic attempts to fix this spec."
            echo ""
            echo "Next Steps:"
            echo "1. Review the test file and implementation"
            echo "2. Check the error logs from previous attempts"
            echo "3. Manually fix the issue and push changes"
            echo "4. Remove the tdd-automation:manual-intervention label to re-enable automation"
            echo ""
            echo "This PR will not auto-merge until manual intervention is complete."
          } > /tmp/manual_comment.txt

          gh pr comment "$PR_NUMBER" --body-file /tmp/manual_comment.txt
