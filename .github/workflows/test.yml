name: Test
permissions:
  contents: read
  actions: write
  issues: write
  pull-requests: write

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main]

env:
  # Infrastructure retry configuration
  MAX_E2E_RETRIES: 2
  E2E_RETRY_DELAY_SECONDS: 30
  # Sharding configuration (4 shards √ó 2 workers = 8 effective workers)
  E2E_SHARD_TOTAL: 4

jobs:
  # ============================================================================
  # PARALLEL STATIC ANALYSIS JOBS
  # These run simultaneously to reduce wall-clock time
  # ============================================================================

  lint:
    name: Lint
    if: github.event_name == 'push' || github.event.action != 'closed'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Cache ESLint results
        uses: actions/cache@v4
        with:
          path: .eslintcache
          key: ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('eslint.config.ts') }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('eslint.config.ts') }}-
            ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-

      - name: Lint code
        run: bun run lint

  typecheck:
    name: TypeCheck
    if: github.event_name == 'push' || github.event.action != 'closed'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Type check
        run: bun run typecheck

  unit-tests:
    name: Unit Tests
    if: github.event_name == 'push' || github.event.action != 'closed'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run unit tests
        run: bun test:unit

      - name: Validate spec counts
        run: bun run validate:spec-counts

  # ============================================================================
  # E2E TESTS WITH SHARDING
  # 4 shards running in parallel, each with 2 workers = 8 effective workers
  # ============================================================================

  e2e:
    name: E2E Shard ${{ matrix.shard }}/${{ matrix.total }}
    if: github.event_name == 'push' || github.event.action != 'closed'
    needs: [lint, typecheck, unit-tests]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        shard: [1, 2, 3, 4]
        total: [4]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Get Playwright version
        id: playwright-version
        run: echo "version=$(bun pm ls @playwright/test | grep '@playwright/test' | awk '{print $2}' | head -n 1)" >> $GITHUB_OUTPUT

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ steps.playwright-version.outputs.version }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: bunx playwright install --with-deps chromium

      - name: Pre-pull Docker images
        run: |
          echo "üê≥ Pre-pulling Docker images..."
          docker pull axllent/mailpit:latest &
          docker pull postgres:16-alpine &
          wait
          echo "‚úÖ Docker images ready"

      - name: Verify Docker ready
        run: |
          docker info > /dev/null 2>&1 || { echo "‚ùå Docker not running"; exit 1; }
          echo "‚úÖ Docker daemon ready"

      - name: Run E2E tests (shard ${{ matrix.shard }}/${{ matrix.total }})
        id: e2e
        run: |
          echo "üß™ Running E2E shard ${{ matrix.shard }} of ${{ matrix.total }}..."
          # Use JSON reporter alongside default for reliable failure parsing
          bunx playwright test --grep "@regression" --shard=${{ matrix.shard }}/${{ matrix.total }} \
            --reporter=github,json
          # Move JSON results to predictable location
          if [ -f "test-results.json" ]; then
            mv test-results.json "test-results-shard-${{ matrix.shard }}.json"
          fi
        continue-on-error: true
        env:
          # Use 2 workers per shard (4 shards √ó 2 workers = 8 effective workers)
          CI_WORKERS: 2
          # JSON reporter outputs to this file
          PLAYWRIGHT_JSON_OUTPUT_NAME: test-results.json

      - name: Retry E2E tests on failure
        id: e2e-retry
        if: steps.e2e.outcome == 'failure'
        run: |
          echo "‚ö†Ô∏è E2E shard ${{ matrix.shard }} failed, retrying..."
          sleep ${{ env.E2E_RETRY_DELAY_SECONDS }}

          # Cleanup stale containers
          docker ps -aq --filter "name=sovrium-" | xargs -r docker rm -f 2>/dev/null || true
          docker ps -aq --filter "name=mailpit" | xargs -r docker rm -f 2>/dev/null || true

          echo "üîÑ Retrying shard ${{ matrix.shard }}..."
          # Use JSON reporter alongside default for reliable failure parsing
          bunx playwright test --grep "@regression" --shard=${{ matrix.shard }}/${{ matrix.total }} \
            --reporter=github,json
          # Move JSON results to predictable location (overwrite previous if exists)
          if [ -f "test-results.json" ]; then
            mv test-results.json "test-results-shard-${{ matrix.shard }}.json"
          fi
        env:
          CI_WORKERS: 2
          PLAYWRIGHT_JSON_OUTPUT_NAME: test-results.json

      - name: E2E shard final status
        if: always()
        run: |
          if [ "${{ steps.e2e.outcome }}" = "success" ]; then
            echo "‚úÖ Shard ${{ matrix.shard }} passed on first attempt"
          elif [ "${{ steps.e2e-retry.outcome }}" = "success" ]; then
            echo "‚úÖ Shard ${{ matrix.shard }} passed on retry"
          else
            echo "‚ùå Shard ${{ matrix.shard }} failed"
            exit 1
          fi

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-shard-${{ matrix.shard }}
          path: test-results/
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload JSON test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: json-results-shard-${{ matrix.shard }}
          path: test-results-shard-${{ matrix.shard }}.json
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload Playwright report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-shard-${{ matrix.shard }}
          path: playwright-report/
          retention-days: 7
          if-no-files-found: ignore

  # ============================================================================
  # E2E RESULTS AGGREGATION
  # Merges results from all shards and handles regression classification
  # ============================================================================

  e2e-results:
    name: E2E Results
    if: always() && (github.event_name == 'push' || github.event.action != 'closed')
    needs: [e2e]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      e2e_failed: ${{ steps.check.outputs.e2e_failed }}
      has_regressions: ${{ steps.classify-failures.outputs.has_regressions }}
      regression_specs: ${{ steps.classify-failures.outputs.regression_specs }}
      target_spec: ${{ steps.classify-failures.outputs.target_spec }}
      failure_type: ${{ steps.classify-failures.outputs.failure_type }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          pattern: test-results-shard-*
          path: all-test-results/
          merge-multiple: false

      - name: Download all JSON test results
        uses: actions/download-artifact@v4
        with:
          pattern: json-results-shard-*
          path: all-json-results/
          merge-multiple: false
        continue-on-error: true

      - name: Check E2E results
        id: check
        run: |
          echo "üìä Checking E2E shard results..."

          # Check if any shard failed
          FAILED="false"
          if [ "${{ needs.e2e.result }}" = "failure" ]; then
            FAILED="true"
            echo "‚ùå One or more E2E shards failed"
          else
            echo "‚úÖ All E2E shards passed"
          fi

          echo "e2e_failed=$FAILED" >> $GITHUB_OUTPUT

      - name: Classify test failures
        id: classify-failures
        if: |
          needs.e2e.result == 'failure' &&
          contains(github.event.pull_request.labels.*.name, 'tdd-automation')
        env:
          GH_TOKEN: ${{ github.token }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          echo "üîç Classifying test failures for TDD automation PR..."

          # Extract target spec from PR body
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oP 'Closes #\K[0-9]+' | head -1 || echo "")
          TARGET_SPEC=""

          if [ -n "$ISSUE_NUMBER" ]; then
            echo "üìã Found linked issue: #$ISSUE_NUMBER"
            ISSUE_BODY=$(gh issue view "$ISSUE_NUMBER" --json body --jq '.body' 2>/dev/null || echo "")
            TARGET_SPEC=$(echo "$ISSUE_BODY" | grep -oP '\*\*File\*\*:\s*`\K[^`]+' | head -1 || echo "")

            if [ -z "$TARGET_SPEC" ]; then
              TARGET_SPEC=$(echo "$ISSUE_BODY" | grep -oP 'specs/[^\s:]+\.spec\.ts' | head -1 || echo "")
            fi
            echo "üéØ Target spec: $TARGET_SPEC"
          fi

          # Parse failed tests from JSON results (reliable) or fall back to directory names
          FAILED_SPECS=""

          # Method 1: Parse from JSON results (preferred - contains exact file paths)
          if [ -d "all-json-results" ]; then
            echo "üìÑ Parsing failed specs from JSON results..."
            # Extract unique file paths from all JSON result files where status is not "passed"
            FAILED_SPECS=$(find all-json-results -name "*.json" -exec cat {} \; 2>/dev/null | \
              jq -r '.suites[]?.specs[]? | select(.tests[]?.status != "passed") | .file // empty' 2>/dev/null | \
              sort -u | tr '\n' ',' | sed 's/,$//' || echo "")

            # If jq parsing failed or empty, try alternative JSON structure
            if [ -z "$FAILED_SPECS" ]; then
              FAILED_SPECS=$(find all-json-results -name "*.json" -exec cat {} \; 2>/dev/null | \
                jq -r '.suites[]? | select(.specs[]?.tests[]?.status != "passed") | .file // empty' 2>/dev/null | \
                sort -u | tr '\n' ',' | sed 's/,$//' || echo "")
            fi
          fi

          # Method 2: Fall back to directory-based parsing (legacy, less reliable for hyphenated paths)
          if [ -z "$FAILED_SPECS" ] && [ -d "all-test-results" ]; then
            echo "‚ö†Ô∏è  JSON results unavailable, falling back to directory-based parsing..."
            echo "    Note: This may misparse specs with hyphens in their paths"
            FAILED_SPECS=$(find all-test-results -type d -name "*.spec.ts*" 2>/dev/null | \
              sed 's|.*/test-results-shard-[0-9]*/||' | \
              sed 's|-chromium.*||' | \
              sed 's|--.*||' | \
              tr '-' '/' | \
              sed 's|^|specs/|' | \
              sed 's|$|.spec.ts|' | \
              sort -u | tr '\n' ',' | sed 's/,$//')
          fi

          if [ -z "$FAILED_SPECS" ]; then
            FAILED_SPECS="unknown"
          fi

          echo "‚ùå Failed specs: $FAILED_SPECS"

          # Classify failures
          HAS_REGRESSIONS="false"
          REGRESSION_SPECS=""
          FAILURE_TYPE="unknown"

          if [ -n "$TARGET_SPEC" ] && [ "$FAILED_SPECS" != "unknown" ]; then
            IFS=',' read -ra SPECS_ARRAY <<< "$FAILED_SPECS"
            for spec in "${SPECS_ARRAY[@]}"; do
              spec=$(echo "$spec" | xargs)
              if [ -n "$spec" ] && [ "$spec" != "$TARGET_SPEC" ]; then
                HAS_REGRESSIONS="true"
                if [ -z "$REGRESSION_SPECS" ]; then
                  REGRESSION_SPECS="$spec"
                else
                  REGRESSION_SPECS="$REGRESSION_SPECS,$spec"
                fi
              fi
            done

            if [ "$HAS_REGRESSIONS" = "true" ]; then
              if echo "$FAILED_SPECS" | grep -q "$TARGET_SPEC"; then
                FAILURE_TYPE="mixed"
              else
                FAILURE_TYPE="regression_only"
              fi
            else
              FAILURE_TYPE="target_only"
            fi
          fi

          echo ""
          echo "üìä Classification Results:"
          echo "  Target spec: $TARGET_SPEC"
          echo "  Failed specs: $FAILED_SPECS"
          echo "  Has regressions: $HAS_REGRESSIONS"
          echo "  Regression specs: $REGRESSION_SPECS"
          echo "  Failure type: $FAILURE_TYPE"

          echo "has_regressions=$HAS_REGRESSIONS" >> $GITHUB_OUTPUT
          echo "regression_specs=$REGRESSION_SPECS" >> $GITHUB_OUTPUT
          echo "target_spec=$TARGET_SPEC" >> $GITHUB_OUTPUT
          echo "failure_type=$FAILURE_TYPE" >> $GITHUB_OUTPUT

      - name: Add target failure label
        if: |
          needs.e2e.result == 'failure' &&
          contains(github.event.pull_request.labels.*.name, 'tdd-automation') &&
          steps.classify-failures.outputs.failure_type == 'target_only'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          echo "üè∑Ô∏è  Adding failure:spec label to PR #$PR_NUMBER (target-only failure)"
          gh pr edit "$PR_NUMBER" --add-label "failure:spec" || true

      - name: Fail if E2E tests failed
        if: needs.e2e.result == 'failure'
        run: |
          echo "‚ùå E2E tests failed - see individual shard results for details"
          exit 1

  # ============================================================================
  # FINAL STATUS CHECK
  # Single rollup job that branch protection can require
  # Aggregates results from all parallel jobs
  # ============================================================================

  test:
    name: Test
    if: always() && (github.event_name == 'push' || github.event.action != 'closed')
    needs: [lint, typecheck, unit-tests, e2e-results]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - name: Check all jobs passed
        run: |
          echo "üìä Checking results from all parallel jobs..."
          echo ""
          echo "  Lint:       ${{ needs.lint.result }}"
          echo "  TypeCheck:  ${{ needs.typecheck.result }}"
          echo "  Unit Tests: ${{ needs.unit-tests.result }}"
          echo "  E2E:        ${{ needs.e2e-results.result }}"
          echo ""

          FAILED=""
          if [ "${{ needs.lint.result }}" != "success" ]; then
            FAILED="${FAILED}Lint, "
          fi
          if [ "${{ needs.typecheck.result }}" != "success" ]; then
            FAILED="${FAILED}TypeCheck, "
          fi
          if [ "${{ needs.unit-tests.result }}" != "success" ]; then
            FAILED="${FAILED}Unit Tests, "
          fi
          if [ "${{ needs.e2e-results.result }}" != "success" ]; then
            FAILED="${FAILED}E2E, "
          fi

          if [ -n "$FAILED" ]; then
            echo "‚ùå Failed jobs: ${FAILED%, }"
            exit 1
          fi

          echo "‚úÖ All jobs passed!"

  # ============================================================================
  # TDD AUTOMATION JOBS
  #
  # These jobs handle TDD lifecycle events that must run IMMEDIATELY on PR events.
  # They complement tdd-monitor.yml which provides SCHEDULED RECOVERY as backup.
  #
  # Architecture (Defense-in-Depth):
  # - close-tdd-issue: Closes issue on PR merge with retry & verification (primary)
  # - delete-tdd-branch: Immediate cleanup on PR close (vs. weekly in monitor)
  # - handle-regressions: First response to regressions (vs. scheduled recovery)
  #
  # The overlap with tdd-monitor.yml is INTENTIONAL:
  # - test.yml: Event-driven, immediate response
  # - tdd-monitor.yml: Scheduled polling, catches edge cases & API failures
  #
  # For scheduled recovery and health monitoring, see: tdd-monitor.yml
  # ============================================================================

  close-tdd-issue:
    name: Close TDD Issue on PR Merge
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.labels.*.name, 'tdd-automation')
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Extract issue number from PR body
        id: issue
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -o 'Closes #[0-9]*' | head -1 | grep -o '[0-9]*' || echo "")

          if [ -z "$ISSUE_NUMBER" ]; then
            echo "‚ö†Ô∏è No issue number found in PR body"
            echo "has_issue=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found issue #$ISSUE_NUMBER"
            echo "has_issue=true" >> $GITHUB_OUTPUT
            echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          fi

      - name: Close issue with verification
        if: steps.issue.outputs.has_issue == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
        run: |
          ISSUE_NUMBER="${{ steps.issue.outputs.issue_number }}"

          # ‚îÄ‚îÄ Step 1: Close the issue ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          echo "üìã Closing issue #$ISSUE_NUMBER..."
          gh issue close "$ISSUE_NUMBER" --reason completed
          gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed"
          gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress"

          # Clean up retry labels (may have been added during failed attempts)
          for label in retry:spec:1 retry:spec:2 retry:spec:3 retry:infra:1 retry:infra:2 retry:infra:3; do
            gh issue edit "$ISSUE_NUMBER" --remove-label "$label" 2>/dev/null || true
          done

          # Clean up failure classification labels
          for label in failure:spec failure:regression failure:infra; do
            gh issue edit "$ISSUE_NUMBER" --remove-label "$label" 2>/dev/null || true
          done

          # ‚îÄ‚îÄ Step 2: Verify closure with retry ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          echo ""
          echo "üîç Verifying issue closure..."

          for attempt in 1 2 3; do
            sleep 2  # Brief delay for API consistency

            ISSUE_DATA=$(gh issue view "$ISSUE_NUMBER" --json state,labels --jq '{state: .state, labels: [.labels[].name]}')
            STATE=$(echo "$ISSUE_DATA" | jq -r '.state')
            LABELS=$(echo "$ISSUE_DATA" | jq -r '.labels | join(", ")')

            echo "  Attempt $attempt: state=$STATE, labels=$LABELS"

            if [ "$STATE" = "CLOSED" ]; then
              # Verify labels are correct
              if echo "$LABELS" | grep -q "tdd-spec:completed"; then
                if ! echo "$LABELS" | grep -q "tdd-spec:in-progress"; then
                  echo "‚úÖ Issue #$ISSUE_NUMBER verified: closed with correct labels"
                  exit 0
                fi
              fi

              # Fix labels if needed
              echo "‚ö†Ô∏è Fixing labels..."
              gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed" || true
              gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true
              echo "‚úÖ Issue #$ISSUE_NUMBER closed with labels fixed"
              exit 0
            fi

            echo "  Issue still open, retrying..."
          done

          # ‚îÄ‚îÄ Step 3: Force closure if verification failed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          echo ""
          echo "‚ùå CRITICAL: Issue #$ISSUE_NUMBER failed to close after 3 attempts"
          echo "üîß Forcing closure via REST API..."

          gh api --method PATCH "/repos/${{ github.repository }}/issues/$ISSUE_NUMBER" \
            -f state='closed' \
            -f state_reason='completed' || true

          gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed" || true
          gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true

          # Final verification
          FINAL_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state')
          if [ "$FINAL_STATE" = "CLOSED" ]; then
            echo "‚úÖ Successfully force-closed issue #$ISSUE_NUMBER"
            echo "üîì Queue unblocked - processor can continue with next spec"
          else
            echo "‚ùå FAILED to close issue #$ISSUE_NUMBER - manual intervention required"
            echo "::error::Failed to close issue #$ISSUE_NUMBER after PR merge - queue may be blocked"
            exit 1
          fi

  delete-tdd-branch:
    name: Delete TDD Branch on PR Close
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == false &&
      (startsWith(github.event.pull_request.head.ref, 'tdd/') ||
       startsWith(github.event.pull_request.head.ref, 'claude/'))
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Delete branch
        run: |
          BRANCH="${{ github.event.pull_request.head.ref }}"
          echo "üóëÔ∏è  Deleting unmerged branch: $BRANCH"

          gh api \
            --method DELETE \
            /repos/${{ github.repository }}/git/refs/heads/$BRANCH \
            && echo "‚úÖ Branch deleted successfully" \
            || echo "‚ö†Ô∏è  Branch may already be deleted"
        env:
          GH_TOKEN: ${{ github.token }}

  handle-regressions:
    name: Handle TDD Regressions
    needs: e2e-results
    if: |
      failure() &&
      needs.e2e-results.outputs.has_regressions == 'true' &&
      contains(github.event.pull_request.labels.*.name, 'tdd-automation')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: Add regression label to PR
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          echo "üè∑Ô∏è  Adding failure:regression label to PR #$PR_NUMBER"
          gh pr edit "$PR_NUMBER" --add-label "failure:regression" || true

      - name: Extract issue and failure details
        id: details
        env:
          GH_TOKEN: ${{ github.token }}
          PR_BODY: ${{ github.event.pull_request.body }}
          REGRESSION_SPECS: ${{ needs.e2e-results.outputs.regression_specs }}
          TARGET_SPEC: ${{ needs.e2e-results.outputs.target_spec }}
          FAILURE_TYPE: ${{ needs.e2e-results.outputs.failure_type }}
        run: |
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oP 'Closes #\K[0-9]+' | head -1 || echo "")
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          SPEC_ID=""
          if [ -n "$ISSUE_NUMBER" ]; then
            ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title --jq '.title' 2>/dev/null || echo "")
            SPEC_ID=$(echo "$ISSUE_TITLE" | grep -oP '[A-Z]+-[A-Z]+-[0-9]+' | head -1 || echo "unknown")
          fi
          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT

          echo ""
          echo "üìã Regression Details:"
          echo "  Issue: #$ISSUE_NUMBER"
          echo "  Spec ID: $SPEC_ID"
          echo "  Target spec: $TARGET_SPEC"
          echo "  Regression specs: $REGRESSION_SPECS"
          echo "  Failure type: $FAILURE_TYPE"

      - name: Check for recent fix attempts (cooldown)
        id: cooldown
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          # Check for recent regression/fix comments in the last 30 minutes
          # This prevents duplicate @claude comments from both test.yml and tdd-monitor.yml
          echo "üïê Checking for recent fix attempt comments..."

          CUTOFF_TIME=$(date -u -d '30 minutes ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || \
                        date -u -v-30M +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || \
                        echo "1970-01-01T00:00:00Z")

          echo "  Cutoff time: $CUTOFF_TIME"

          # Get recent comments and check for regression-related content
          RECENT_COMMENTS=$(gh api "/repos/${{ github.repository }}/issues/$PR_NUMBER/comments" \
            --jq "[.[] | select(.created_at > \"$CUTOFF_TIME\") | select(.body | test(\"Regression Detected|Failed PR Recovery|Auto-Fix Required\"; \"i\"))] | length" \
            2>/dev/null || echo "0")

          echo "  Recent regression comments found: $RECENT_COMMENTS"

          if [ "$RECENT_COMMENTS" -gt 0 ]; then
            echo "‚è≠Ô∏è  Skipping: Recent fix attempt comment exists (cooldown active)"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No recent comments, proceeding with regression notification"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Post regression fix instructions to PR
        if: steps.cooldown.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          ISSUE_NUMBER: ${{ steps.details.outputs.issue_number }}
          SPEC_ID: ${{ steps.details.outputs.spec_id }}
          REGRESSION_SPECS: ${{ needs.e2e-results.outputs.regression_specs }}
          TARGET_SPEC: ${{ needs.e2e-results.outputs.target_spec }}
          FAILURE_TYPE: ${{ needs.e2e-results.outputs.failure_type }}
          BRANCH: ${{ github.event.pull_request.head.ref }}
        run: |
          cat << 'EOF' > /tmp/comment.md
          ## üîß Regression Detected - Auto-Fix Required

          @claude This PR has **regressions** - tests failing in files OTHER than the target spec.

          ### üìä Failure Analysis
          - **Target Spec**: `$TARGET_SPEC`
          - **Regression Specs**: `$REGRESSION_SPECS`
          - **Failure Type**: `$FAILURE_TYPE`
          - **Spec ID**: `$SPEC_ID`
          - **Issue**: #$ISSUE_NUMBER

          ### ü§ñ Auto-Fix Instructions

          **CRITICAL**: Your changes broke tests in other files. This is a **regression** that must be fixed.

          1. **Analyze the regression cause**:
             - Run `bun test:e2e -- $REGRESSION_SPECS` to see the failing tests
             - Check what code you changed that could affect these tests
             - Look for **catch-all patterns** that are too greedy

          2. **Fix the regression** without modifying the failing tests

          3. **Verify the fix**:
             ```bash
             bun run quality
             bun test:e2e:regression
             ```

          4. **Push the fix**:
             ```bash
             bun run license
             git add -A
             git commit -m "fix: resolve regression in $SPEC_ID"
             git push
             ```

          ---
          *ü§ñ Regression Handler - [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*
          EOF

          envsubst < /tmp/comment.md > /tmp/comment_final.md
          gh pr comment "$PR_NUMBER" --body-file /tmp/comment_final.md
          echo "‚úÖ Posted regression fix instructions to PR #$PR_NUMBER"

      - name: Update issue with regression status
        if: steps.cooldown.outputs.skip != 'true' && steps.details.outputs.issue_number != ''
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.details.outputs.issue_number }}
          REGRESSION_SPECS: ${{ needs.e2e-results.outputs.regression_specs }}
        run: |
          gh issue comment "$ISSUE_NUMBER" --body "‚ö†Ô∏è **Regression Detected**

          The PR for this spec has introduced regressions in other test files:
          - **Regression specs**: \`$REGRESSION_SPECS\`

          Claude Code will attempt to auto-fix the regression.

          ---
          *ü§ñ Regression Handler*"

          gh issue edit "$ISSUE_NUMBER" --add-label "failure:regression" || true
