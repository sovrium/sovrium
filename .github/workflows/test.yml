name: Test
permissions:
  contents: read
  actions: write
  issues: write
  pull-requests: write

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main]

env:
  # Infrastructure retry configuration
  MAX_E2E_RETRIES: 2
  E2E_RETRY_DELAY_SECONDS: 30
  # Sharding configuration (8 shards √ó 2 workers = 16 effective workers)
  E2E_SHARD_TOTAL: 8

jobs:
  # ============================================================================
  # CHANGE TYPE DETECTION
  # Detects test-only changes (e.g., .fixme() removal) for reduced CI
  # ============================================================================

  detect-change-type:
    name: Detect Change Type
    if: github.event_name == 'pull_request' && github.event.action != 'closed'
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      is_test_only: ${{ steps.detect.outputs.is_test_only }}
      target_spec: ${{ steps.detect.outputs.target_spec }}
      is_tdd_automation: ${{ steps.detect.outputs.is_tdd_automation }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect test-only changes
        id: detect
        env:
          GH_TOKEN: ${{ github.token }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          IS_TEST_ONLY="false"
          TARGET_SPEC=""
          IS_TDD_AUTOMATION="false"

          # Check if this is a TDD automation PR
          if [ "${{ contains(github.event.pull_request.labels.*.name, 'tdd-automation') }}" = "true" ]; then
            IS_TDD_AUTOMATION="true"
            echo "ü§ñ TDD automation PR detected"

            # Extract target spec from linked issue
            ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oP 'Closes #\K[0-9]+' | head -1 || echo "")
            if [ -n "$ISSUE_NUMBER" ]; then
              ISSUE_BODY=$(gh issue view "$ISSUE_NUMBER" --json body --jq '.body' 2>/dev/null || echo "")
              TARGET_SPEC=$(echo "$ISSUE_BODY" | grep -oP '\*\*Test File\*\*:\s*`\K[^`]+' | head -1 || echo "")
              if [ -z "$TARGET_SPEC" ]; then
                TARGET_SPEC=$(echo "$ISSUE_BODY" | grep -oP 'specs/[^\s:]+\.spec\.ts' | head -1 || echo "")
              fi
              echo "üéØ Target spec: $TARGET_SPEC"
            fi
          fi

          # Get changed files compared to base branch
          echo "üîç Analyzing changed files..."
          CHANGED_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES" | head -20

          # Check if ALL changed files are in specs/ directory
          NON_SPEC_FILES=$(echo "$CHANGED_FILES" | grep -v '^specs/' | grep -v '^\s*$' || true)

          if [ -z "$NON_SPEC_FILES" ]; then
            echo "‚úÖ Only spec files changed"

            # Check if changes are only .fixme() removal (no significant logic changes)
            DIFF_CONTENT=$(git diff origin/${{ github.event.pull_request.base.ref }}...HEAD -- specs/)

            # Count lines that are NOT:
            # - .fixme() related
            # - file headers (---, +++)
            # - diff markers (@@)
            # - empty lines
            SIGNIFICANT_CHANGES=$(echo "$DIFF_CONTENT" | \
              grep -E '^[-+]' | \
              grep -v '^[-+][-+][-+]' | \
              grep -v '\.fixme\(' | \
              grep -v '\.skip\(' | \
              grep -v '^[-+]\s*$' | \
              wc -l | tr -d ' ')

            echo "üìä Significant changes (non-.fixme): $SIGNIFICANT_CHANGES lines"

            # If less than 10 significant lines changed, consider it test-only
            if [ "$SIGNIFICANT_CHANGES" -lt 10 ]; then
              IS_TEST_ONLY="true"
              echo "‚úÖ Test-only change detected (primarily .fixme() removal)"
            else
              echo "‚ÑπÔ∏è  Spec files changed with significant modifications"
            fi
          else
            echo "‚ÑπÔ∏è  Non-spec files changed:"
            echo "$NON_SPEC_FILES" | head -10
          fi

          # Output results
          echo ""
          echo "üìã Detection Results:"
          echo "  is_test_only=$IS_TEST_ONLY"
          echo "  target_spec=$TARGET_SPEC"
          echo "  is_tdd_automation=$IS_TDD_AUTOMATION"

          echo "is_test_only=$IS_TEST_ONLY" >> $GITHUB_OUTPUT
          echo "target_spec=$TARGET_SPEC" >> $GITHUB_OUTPUT
          echo "is_tdd_automation=$IS_TDD_AUTOMATION" >> $GITHUB_OUTPUT

  # ============================================================================
  # PARALLEL STATIC ANALYSIS JOBS
  # These run simultaneously to reduce wall-clock time
  # Skipped for test-only changes to speed up CI
  # ============================================================================

  lint:
    name: Lint
    needs: [detect-change-type]
    # Skip lint for test-only changes (spec files have separate lint rules)
    # Always run on push to main, skip on PR if test-only
    # Note: always() allows this job to run even when detect-change-type is skipped (push events)
    if: |
      always() &&
      (
        (github.event_name == 'push') ||
        (github.event.action != 'closed' && needs.detect-change-type.outputs.is_test_only != 'true')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Cache ESLint results
        uses: actions/cache@v4
        with:
          path: .eslintcache
          key: ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('eslint.config.ts') }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('eslint.config.ts') }}-
            ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-

      - name: Lint code
        run: bun run lint

  typecheck:
    name: TypeCheck
    needs: [detect-change-type]
    # TypeCheck always runs (spec files have TypeScript that needs validation)
    # Note: always() allows this job to run even when detect-change-type is skipped (push events)
    if: |
      always() &&
      (github.event_name == 'push' || github.event.action != 'closed')
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Type check
        run: bun run typecheck

  unit-tests:
    name: Unit Tests
    needs: [detect-change-type]
    # Skip unit tests for test-only changes (no production code changed)
    # Note: always() allows this job to run even when detect-change-type is skipped (push events)
    if: |
      always() &&
      (
        (github.event_name == 'push') ||
        (github.event.action != 'closed' && needs.detect-change-type.outputs.is_test_only != 'true')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run unit tests
        run: bun test:unit

  # ============================================================================
  # E2E TESTS WITH SHARDING
  # 8 shards running in parallel, each with 2 workers = 16 effective workers
  # ============================================================================

  # E2E for test-only changes: Run only target spec (fast path)
  e2e-target:
    name: E2E Target Spec
    if: |
      github.event_name == 'pull_request' &&
      github.event.action != 'closed' &&
      needs.detect-change-type.outputs.is_test_only == 'true'
    needs: [detect-change-type, typecheck]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Get Playwright version
        id: playwright-version
        run: echo "version=$(bun pm ls @playwright/test | grep '@playwright/test' | awk '{print $2}' | head -n 1)" >> $GITHUB_OUTPUT

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ steps.playwright-version.outputs.version }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: bunx playwright install --with-deps chromium

      - name: Pre-pull Docker images
        run: |
          echo "üê≥ Pre-pulling Docker images..."

          # Pull with retry logic for registry resilience
          pull_with_retry() {
            local image=$1
            local max_attempts=3

            for attempt in $(seq 1 $max_attempts); do
              echo "  Pulling $image (attempt $attempt/$max_attempts)..."
              if docker pull "$image" 2>&1; then
                echo "  ‚úÖ $image pulled successfully"
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                echo "  ‚ö†Ô∏è Pull failed, waiting 10s before retry..."
                sleep 10
              fi
            done

            # Check if image exists locally (from cache)
            if docker image inspect "$image" > /dev/null 2>&1; then
              echo "  ‚ÑπÔ∏è Using cached image for $image"
              return 0
            fi

            echo "  ‚ùå Failed to pull $image after $max_attempts attempts"
            return 1
          }

          # Track failures for reporting
          FAILED_IMAGES=""

          # Pull images with fallback behavior
          if ! pull_with_retry "axllent/mailpit:latest"; then
            FAILED_IMAGES="$FAILED_IMAGES mailpit"
          fi

          if ! pull_with_retry "postgres:16-alpine"; then
            FAILED_IMAGES="$FAILED_IMAGES postgres"
          fi

          if [ -n "$FAILED_IMAGES" ]; then
            echo ""
            echo "‚ö†Ô∏è Some images failed to pull:$FAILED_IMAGES"
            echo "   Tests may fail if images are not cached locally"
            echo "   This could indicate Docker Hub is experiencing issues"
          else
            echo "‚úÖ All Docker images ready"
          fi
        continue-on-error: true

      - name: Verify Docker ready
        run: |
          docker info > /dev/null 2>&1 || { echo "‚ùå Docker not running"; exit 1; }
          echo "‚úÖ Docker daemon ready"

      - name: Run target spec only
        id: e2e
        env:
          TARGET_SPEC: ${{ needs.detect-change-type.outputs.target_spec }}
          CI_WORKERS: 2
        run: |
          echo "üéØ Running target spec only (test-only fast path)..."
          echo "Target: $TARGET_SPEC"

          if [ -n "$TARGET_SPEC" ] && [ -f "$TARGET_SPEC" ]; then
            echo "üß™ Running: bunx playwright test $TARGET_SPEC"
            bunx playwright test "$TARGET_SPEC" --reporter=github
          else
            echo "‚ö†Ô∏è  Target spec not found, running @regression tests that match changed files..."
            # Fall back to running changed spec files
            CHANGED_SPECS=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD | grep '\.spec\.ts$' || true)
            if [ -n "$CHANGED_SPECS" ]; then
              echo "Running: $CHANGED_SPECS"
              bunx playwright test $CHANGED_SPECS --reporter=github
            else
              echo "‚úÖ No spec files to run"
            fi
          fi

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-target-spec
          path: test-results/
          retention-days: 7
          if-no-files-found: ignore

  # E2E for normal changes: Full 8-shard regression suite
  e2e:
    name: E2E Shard ${{ matrix.shard }}/${{ matrix.total }}
    # Run full shards only when NOT test-only (or on push to main)
    # Note: always() allows this job to run even when detect-change-type is skipped (push events)
    # On push events, we verify lint/typecheck/unit-tests succeeded before running E2E
    if: |
      always() &&
      (
        (github.event_name == 'push' && needs.lint.result == 'success' && needs.typecheck.result == 'success' && needs.unit-tests.result == 'success') ||
        (github.event.action != 'closed' && needs.detect-change-type.outputs.is_test_only != 'true' && needs.lint.result == 'success' && needs.typecheck.result == 'success' && needs.unit-tests.result == 'success')
      )
    needs: [detect-change-type, lint, typecheck, unit-tests]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        shard: [1, 2, 3, 4, 5, 6, 7, 8]
        total: [8]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Get Playwright version
        id: playwright-version
        run: echo "version=$(bun pm ls @playwright/test | grep '@playwright/test' | awk '{print $2}' | head -n 1)" >> $GITHUB_OUTPUT

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ steps.playwright-version.outputs.version }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: bunx playwright install --with-deps chromium

      - name: Pre-pull Docker images
        run: |
          echo "üê≥ Pre-pulling Docker images..."

          # Pull with retry logic for registry resilience
          pull_with_retry() {
            local image=$1
            local max_attempts=3

            for attempt in $(seq 1 $max_attempts); do
              echo "  Pulling $image (attempt $attempt/$max_attempts)..."
              if docker pull "$image" 2>&1; then
                echo "  ‚úÖ $image pulled successfully"
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                echo "  ‚ö†Ô∏è Pull failed, waiting 10s before retry..."
                sleep 10
              fi
            done

            # Check if image exists locally (from cache)
            if docker image inspect "$image" > /dev/null 2>&1; then
              echo "  ‚ÑπÔ∏è Using cached image for $image"
              return 0
            fi

            echo "  ‚ùå Failed to pull $image after $max_attempts attempts"
            return 1
          }

          # Track failures for reporting
          FAILED_IMAGES=""

          # Pull images with fallback behavior
          if ! pull_with_retry "axllent/mailpit:latest"; then
            FAILED_IMAGES="$FAILED_IMAGES mailpit"
          fi

          if ! pull_with_retry "postgres:16-alpine"; then
            FAILED_IMAGES="$FAILED_IMAGES postgres"
          fi

          if [ -n "$FAILED_IMAGES" ]; then
            echo ""
            echo "‚ö†Ô∏è Some images failed to pull:$FAILED_IMAGES"
            echo "   Tests may fail if images are not cached locally"
            echo "   This could indicate Docker Hub is experiencing issues"
          else
            echo "‚úÖ All Docker images ready"
          fi
        continue-on-error: true

      - name: Verify Docker ready
        run: |
          docker info > /dev/null 2>&1 || { echo "‚ùå Docker not running"; exit 1; }
          echo "‚úÖ Docker daemon ready"

      - name: Run E2E tests (shard ${{ matrix.shard }}/${{ matrix.total }})
        id: e2e
        run: |
          echo "üß™ Running E2E shard ${{ matrix.shard }} of ${{ matrix.total }}..."
          # Use JSON reporter alongside default for reliable failure parsing
          bunx playwright test --grep "@regression" --shard=${{ matrix.shard }}/${{ matrix.total }} \
            --reporter=github,json
          # Move JSON results to predictable location
          if [ -f "test-results.json" ]; then
            mv test-results.json "test-results-shard-${{ matrix.shard }}.json"
          fi
        continue-on-error: true
        env:
          # Use 2 workers per shard (4 shards √ó 2 workers = 8 effective workers)
          CI_WORKERS: 2
          # JSON reporter outputs to this file
          PLAYWRIGHT_JSON_OUTPUT_NAME: test-results.json

      - name: Retry E2E tests on failure
        id: e2e-retry
        if: steps.e2e.outcome == 'failure'
        run: |
          echo "‚ö†Ô∏è E2E shard ${{ matrix.shard }} failed, retrying..."
          sleep ${{ env.E2E_RETRY_DELAY_SECONDS }}

          # Cleanup stale containers
          docker ps -aq --filter "name=sovrium-" | xargs -r docker rm -f 2>/dev/null || true
          docker ps -aq --filter "name=mailpit" | xargs -r docker rm -f 2>/dev/null || true

          echo "üîÑ Retrying shard ${{ matrix.shard }}..."
          # Use JSON reporter alongside default for reliable failure parsing
          bunx playwright test --grep "@regression" --shard=${{ matrix.shard }}/${{ matrix.total }} \
            --reporter=github,json
          # Move JSON results to predictable location (overwrite previous if exists)
          if [ -f "test-results.json" ]; then
            mv test-results.json "test-results-shard-${{ matrix.shard }}.json"
          fi
        env:
          CI_WORKERS: 2
          PLAYWRIGHT_JSON_OUTPUT_NAME: test-results.json

      - name: E2E shard final status
        if: always()
        run: |
          if [ "${{ steps.e2e.outcome }}" = "success" ]; then
            echo "‚úÖ Shard ${{ matrix.shard }} passed on first attempt"
          elif [ "${{ steps.e2e-retry.outcome }}" = "success" ]; then
            echo "‚úÖ Shard ${{ matrix.shard }} passed on retry"
          else
            echo "‚ùå Shard ${{ matrix.shard }} failed"
            exit 1
          fi

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-shard-${{ matrix.shard }}
          path: test-results/
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload JSON test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: json-results-shard-${{ matrix.shard }}
          path: test-results-shard-${{ matrix.shard }}.json
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload Playwright report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-shard-${{ matrix.shard }}
          path: playwright-report/
          retention-days: 7
          if-no-files-found: ignore

  # ============================================================================
  # E2E RESULTS AGGREGATION
  # Merges results from all shards and handles regression classification
  # ============================================================================

  e2e-results:
    name: E2E Results
    if: always() && (github.event_name == 'push' || github.event.action != 'closed')
    needs: [detect-change-type, e2e, e2e-target]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      e2e_failed: ${{ steps.check.outputs.e2e_failed }}
      has_regressions: ${{ steps.classify-failures.outputs.has_regressions }}
      regression_specs: ${{ steps.classify-failures.outputs.regression_specs }}
      target_spec: ${{ steps.classify-failures.outputs.target_spec }}
      failure_type: ${{ steps.classify-failures.outputs.failure_type }}
      infra_error_type: ${{ steps.classify-failures.outputs.infra_error_type }}
      is_test_only: ${{ needs.detect-change-type.outputs.is_test_only }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          pattern: test-results-*
          path: all-test-results/
          merge-multiple: false
        continue-on-error: true

      - name: Download all JSON test results
        uses: actions/download-artifact@v4
        with:
          pattern: json-results-shard-*
          path: all-json-results/
          merge-multiple: false
        continue-on-error: true

      - name: Check E2E results
        id: check
        env:
          IS_TEST_ONLY: ${{ needs.detect-change-type.outputs.is_test_only }}
        run: |
          echo "üìä Checking E2E results..."
          echo "   Test-only mode: $IS_TEST_ONLY"

          FAILED="false"

          # Check the appropriate job based on change type
          if [ "$IS_TEST_ONLY" = "true" ]; then
            # Test-only: check e2e-target job
            E2E_TARGET_RESULT="${{ needs.e2e-target.result }}"
            echo "   E2E Target result: $E2E_TARGET_RESULT"

            if [ "$E2E_TARGET_RESULT" = "failure" ]; then
              FAILED="true"
              echo "‚ùå E2E target spec failed"
            elif [ "$E2E_TARGET_RESULT" = "success" ]; then
              echo "‚úÖ E2E target spec passed (fast path)"
            else
              echo "‚ö†Ô∏è  E2E target result: $E2E_TARGET_RESULT"
            fi
          else
            # Normal: check e2e shards job
            E2E_RESULT="${{ needs.e2e.result }}"
            echo "   E2E Shards result: $E2E_RESULT"

            if [ "$E2E_RESULT" = "failure" ]; then
              FAILED="true"
              echo "‚ùå One or more E2E shards failed"
            elif [ "$E2E_RESULT" = "success" ]; then
              echo "‚úÖ All E2E shards passed"
            else
              echo "‚ö†Ô∏è  E2E result: $E2E_RESULT"
            fi
          fi

          echo "e2e_failed=$FAILED" >> $GITHUB_OUTPUT

      - name: Classify test failures
        id: classify-failures
        if: |
          needs.e2e.result == 'failure' &&
          contains(github.event.pull_request.labels.*.name, 'tdd-automation')
        env:
          GH_TOKEN: ${{ github.token }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          echo "üîç Classifying test failures for TDD automation PR..."

          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # INFRASTRUCTURE ERROR DETECTION (Check BEFORE classifying as regression)
          # Detects environment issues that are NOT caused by code changes
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          INFRA_ERROR_DETECTED=false
          INFRA_ERROR_TYPE=""

          echo "üîß Checking for infrastructure errors in test results..."

          # Collect all test result content (stdout/stderr from failures)
          TEST_OUTPUT=""
          if [ -d "all-test-results" ]; then
            TEST_OUTPUT=$(find all-test-results -type f \( -name "*.txt" -o -name "*.log" -o -name "output.txt" \) -exec cat {} \; 2>/dev/null || echo "")
          fi

          # Also check JSON results for error messages
          if [ -d "all-json-results" ]; then
            JSON_ERRORS=$(find all-json-results -name "*.json" -exec cat {} \; 2>/dev/null | \
              jq -r '.. | .error? // .message? // empty' 2>/dev/null | head -100 || echo "")
            TEST_OUTPUT="$TEST_OUTPUT"$'\n'"$JSON_ERRORS"
          fi

          # Check for Playwright browser installation errors
          if echo "$TEST_OUTPUT" | grep -qE "browserType\.launch|Executable doesn't exist|chrome-headless-shell"; then
            INFRA_ERROR_DETECTED=true
            INFRA_ERROR_TYPE="playwright_browser_missing"
            echo "‚ö†Ô∏è  INFRASTRUCTURE ERROR: Playwright browser not installed"
          # Check for network/connection errors
          elif echo "$TEST_OUTPUT" | grep -qE "ECONNRESET|ECONNREFUSED|ETIMEDOUT|ENOTFOUND|socket hang up"; then
            INFRA_ERROR_DETECTED=true
            INFRA_ERROR_TYPE="network_error"
            echo "‚ö†Ô∏è  INFRASTRUCTURE ERROR: Network connectivity issue"
          # Check for Docker errors
          elif echo "$TEST_OUTPUT" | grep -qE "docker.*error|Cannot connect to Docker|docker daemon"; then
            INFRA_ERROR_DETECTED=true
            INFRA_ERROR_TYPE="docker_error"
            echo "‚ö†Ô∏è  INFRASTRUCTURE ERROR: Docker service unavailable"
          # Check for resource exhaustion
          elif echo "$TEST_OUTPUT" | grep -qE "out of memory|OOM|ENOMEM|killed"; then
            INFRA_ERROR_DETECTED=true
            INFRA_ERROR_TYPE="resource_exhaustion"
            echo "‚ö†Ô∏è  INFRASTRUCTURE ERROR: Resource exhaustion (OOM)"
          # Check for permission errors
          elif echo "$TEST_OUTPUT" | grep -qE "EPERM|EACCES|Permission denied"; then
            INFRA_ERROR_DETECTED=true
            INFRA_ERROR_TYPE="permission_error"
            echo "‚ö†Ô∏è  INFRASTRUCTURE ERROR: Permission denied"
          # Check for Playwright browser context/page closure errors
          elif echo "$TEST_OUTPUT" | grep -qE "Target page.*closed|Context disposed|Page closed|browser has been closed"; then
            INFRA_ERROR_DETECTED=true
            INFRA_ERROR_TYPE="browser_context_closed"
            echo "‚ö†Ô∏è  INFRASTRUCTURE ERROR: Browser context prematurely closed"
          # Check for explicit Playwright test timeout
          elif echo "$TEST_OUTPUT" | grep -qE "Test timeout of [0-9]+ms exceeded"; then
            INFRA_ERROR_DETECTED=true
            INFRA_ERROR_TYPE="test_timeout"
            echo "‚ö†Ô∏è  INFRASTRUCTURE ERROR: Test execution timeout"
          fi

          # If infrastructure error detected, short-circuit classification
          if [ "$INFRA_ERROR_DETECTED" = "true" ]; then
            echo ""
            echo "üö® INFRASTRUCTURE ERROR DETECTED - NOT a code regression!"
            echo "   Error Type: $INFRA_ERROR_TYPE"
            echo "   This failure should be retried, not classified as regression"
            echo ""

            # Output as infrastructure failure (will trigger different handling)
            echo "has_regressions=false" >> $GITHUB_OUTPUT
            echo "regression_specs=" >> $GITHUB_OUTPUT
            echo "target_spec=" >> $GITHUB_OUTPUT
            echo "failure_type=infrastructure" >> $GITHUB_OUTPUT
            echo "infra_error_type=$INFRA_ERROR_TYPE" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ No infrastructure errors detected - proceeding with failure classification"
          echo ""

          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # NORMAL CLASSIFICATION LOGIC (Code/Test failures)
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

          # Extract target spec from PR body
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oP 'Closes #\K[0-9]+' | head -1 || echo "")
          TARGET_SPEC=""

          if [ -n "$ISSUE_NUMBER" ]; then
            echo "üìã Found linked issue: #$ISSUE_NUMBER"
            ISSUE_BODY=$(gh issue view "$ISSUE_NUMBER" --json body --jq '.body' 2>/dev/null || echo "")
            TARGET_SPEC=$(echo "$ISSUE_BODY" | grep -oP '\*\*File\*\*:\s*`\K[^`]+' | head -1 || echo "")

            if [ -z "$TARGET_SPEC" ]; then
              TARGET_SPEC=$(echo "$ISSUE_BODY" | grep -oP 'specs/[^\s:]+\.spec\.ts' | head -1 || echo "")
            fi
            echo "üéØ Target spec: $TARGET_SPEC"
          fi

          # Parse failed tests from JSON results (reliable) or fall back to directory names
          FAILED_SPECS=""

          # Method 1: Parse from JSON results (preferred - contains exact file paths)
          if [ -d "all-json-results" ]; then
            echo "üìÑ Parsing failed specs from JSON results..."
            # Extract unique file paths from all JSON result files where status is not "passed"
            FAILED_SPECS=$(find all-json-results -name "*.json" -exec cat {} \; 2>/dev/null | \
              jq -r '.suites[]?.specs[]? | select(.tests[]?.status != "passed") | .file // empty' 2>/dev/null | \
              sort -u | tr '\n' ',' | sed 's/,$//' || echo "")

            # If jq parsing failed or empty, try alternative JSON structure
            if [ -z "$FAILED_SPECS" ]; then
              FAILED_SPECS=$(find all-json-results -name "*.json" -exec cat {} \; 2>/dev/null | \
                jq -r '.suites[]? | select(.specs[]?.tests[]?.status != "passed") | .file // empty' 2>/dev/null | \
                sort -u | tr '\n' ',' | sed 's/,$//' || echo "")
            fi
          fi

          # Method 2: Fall back to directory-based parsing (legacy, less reliable for hyphenated paths)
          if [ -z "$FAILED_SPECS" ] && [ -d "all-test-results" ]; then
            echo "‚ö†Ô∏è  JSON results unavailable, falling back to directory-based parsing..."
            echo "    Note: This may misparse specs with hyphens in their paths"
            FAILED_SPECS=$(find all-test-results -type d -name "*.spec.ts*" 2>/dev/null | \
              sed 's|.*/test-results-shard-[0-9]*/||' | \
              sed 's|-chromium.*||' | \
              sed 's|--.*||' | \
              tr '-' '/' | \
              sed 's|^|specs/|' | \
              sed 's|$|.spec.ts|' | \
              sort -u | tr '\n' ',' | sed 's/,$//')
          fi

          if [ -z "$FAILED_SPECS" ]; then
            FAILED_SPECS="unknown"
          fi

          echo "‚ùå Failed specs: $FAILED_SPECS"

          # Classify failures
          HAS_REGRESSIONS="false"
          REGRESSION_SPECS=""
          FAILURE_TYPE="unknown"

          if [ -n "$TARGET_SPEC" ] && [ "$FAILED_SPECS" != "unknown" ]; then
            IFS=',' read -ra SPECS_ARRAY <<< "$FAILED_SPECS"
            for spec in "${SPECS_ARRAY[@]}"; do
              spec=$(echo "$spec" | xargs)
              if [ -n "$spec" ] && [ "$spec" != "$TARGET_SPEC" ]; then
                HAS_REGRESSIONS="true"
                if [ -z "$REGRESSION_SPECS" ]; then
                  REGRESSION_SPECS="$spec"
                else
                  REGRESSION_SPECS="$REGRESSION_SPECS,$spec"
                fi
              fi
            done

            if [ "$HAS_REGRESSIONS" = "true" ]; then
              if echo "$FAILED_SPECS" | grep -q "$TARGET_SPEC"; then
                FAILURE_TYPE="mixed"
              else
                FAILURE_TYPE="regression_only"
              fi
            else
              FAILURE_TYPE="target_only"
            fi
          fi

          echo ""
          echo "üìä Classification Results:"
          echo "  Target spec: $TARGET_SPEC"
          echo "  Failed specs: $FAILED_SPECS"
          echo "  Has regressions: $HAS_REGRESSIONS"
          echo "  Regression specs: $REGRESSION_SPECS"
          echo "  Failure type: $FAILURE_TYPE"

          echo "has_regressions=$HAS_REGRESSIONS" >> $GITHUB_OUTPUT
          echo "regression_specs=$REGRESSION_SPECS" >> $GITHUB_OUTPUT
          echo "target_spec=$TARGET_SPEC" >> $GITHUB_OUTPUT
          echo "failure_type=$FAILURE_TYPE" >> $GITHUB_OUTPUT

      - name: Add target failure label
        if: |
          (needs.e2e.result == 'failure' || needs.e2e-target.result == 'failure') &&
          contains(github.event.pull_request.labels.*.name, 'tdd-automation') &&
          steps.classify-failures.outputs.failure_type == 'target_only'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          echo "üè∑Ô∏è  Adding failure:spec label to PR #$PR_NUMBER (target-only failure)"
          gh pr edit "$PR_NUMBER" --add-label "failure:spec" || true

      - name: Add infrastructure failure label
        if: |
          (needs.e2e.result == 'failure' || needs.e2e-target.result == 'failure') &&
          contains(github.event.pull_request.labels.*.name, 'tdd-automation') &&
          steps.classify-failures.outputs.failure_type == 'infrastructure'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_BODY: ${{ github.event.pull_request.body }}
          INFRA_ERROR_TYPE: ${{ steps.classify-failures.outputs.infra_error_type }}
        run: |
          echo "üè∑Ô∏è  Adding failure:infra label to PR #$PR_NUMBER (infrastructure error: $INFRA_ERROR_TYPE)"
          gh pr edit "$PR_NUMBER" --add-label "failure:infra" || true

          # Also update the linked issue to maintain consistent state
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oE 'Closes #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")
          if [ -n "$ISSUE_NUMBER" ]; then
            echo "üè∑Ô∏è  Adding failure:infra label to linked issue #$ISSUE_NUMBER"
            gh issue edit "$ISSUE_NUMBER" --add-label "failure:infra" || true
          fi

          # Post comment explaining infrastructure error
          gh pr comment "$PR_NUMBER" --body "## üîß Infrastructure Error Detected

          **This is NOT a code regression** - it's an environment/infrastructure issue.

          **Error Type**: \`$INFRA_ERROR_TYPE\`

          **What this means**:
          - The test failures are caused by CI environment issues, not your code changes
          - The TDD Monitor will automatically retry this PR
          - No code changes are needed to fix this

          **Common causes**:
          - \`playwright_browser_missing\`: Playwright browser cache miss
          - \`network_error\`: Transient network connectivity issues
          - \`docker_error\`: Docker service unavailable
          - \`resource_exhaustion\`: Runner ran out of memory
          - \`browser_context_closed\`: Browser context prematurely closed
          - \`test_timeout\`: Test execution timeout exceeded

          ---
          *ü§ñ Infrastructure Error Handler*"

      - name: Fail if E2E tests failed
        if: steps.check.outputs.e2e_failed == 'true'
        env:
          IS_TEST_ONLY: ${{ needs.detect-change-type.outputs.is_test_only }}
        run: |
          if [ "$IS_TEST_ONLY" = "true" ]; then
            echo "‚ùå E2E target spec failed - see test results for details"
          else
            echo "‚ùå E2E tests failed - see individual shard results for details"
          fi
          exit 1

  # ============================================================================
  # FINAL STATUS CHECK
  # Single rollup job that branch protection can require
  # Aggregates results from all parallel jobs
  # ============================================================================

  test:
    name: Test
    if: always() && (github.event_name == 'push' || github.event.action != 'closed')
    needs: [detect-change-type, lint, typecheck, unit-tests, e2e-results]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - name: Check all jobs passed
        env:
          IS_TEST_ONLY: ${{ needs.detect-change-type.outputs.is_test_only }}
        run: |
          echo "üìä Checking results from all parallel jobs..."
          echo "   Test-only mode: $IS_TEST_ONLY"
          echo ""
          echo "  Detect:     ${{ needs.detect-change-type.result }}"
          echo "  Lint:       ${{ needs.lint.result }}"
          echo "  TypeCheck:  ${{ needs.typecheck.result }}"
          echo "  Unit Tests: ${{ needs.unit-tests.result }}"
          echo "  E2E:        ${{ needs.e2e-results.result }}"
          echo ""

          FAILED=""

          # For test-only changes, lint and unit-tests are skipped (acceptable)
          # For normal changes, all jobs must pass
          LINT_RESULT="${{ needs.lint.result }}"
          TYPECHECK_RESULT="${{ needs.typecheck.result }}"
          UNIT_RESULT="${{ needs.unit-tests.result }}"
          E2E_RESULT="${{ needs.e2e-results.result }}"

          # Lint: skipped is OK for test-only, otherwise must be success
          if [ "$IS_TEST_ONLY" = "true" ]; then
            if [ "$LINT_RESULT" != "success" ] && [ "$LINT_RESULT" != "skipped" ]; then
              FAILED="${FAILED}Lint, "
            fi
          else
            if [ "$LINT_RESULT" != "success" ]; then
              FAILED="${FAILED}Lint, "
            fi
          fi

          # TypeCheck: always required (spec files have TypeScript)
          if [ "$TYPECHECK_RESULT" != "success" ]; then
            FAILED="${FAILED}TypeCheck, "
          fi

          # Unit Tests: skipped is OK for test-only, otherwise must be success
          if [ "$IS_TEST_ONLY" = "true" ]; then
            if [ "$UNIT_RESULT" != "success" ] && [ "$UNIT_RESULT" != "skipped" ]; then
              FAILED="${FAILED}Unit Tests, "
            fi
          else
            if [ "$UNIT_RESULT" != "success" ]; then
              FAILED="${FAILED}Unit Tests, "
            fi
          fi

          # E2E: always required
          if [ "$E2E_RESULT" != "success" ]; then
            FAILED="${FAILED}E2E, "
          fi

          if [ -n "$FAILED" ]; then
            echo "‚ùå Failed jobs: ${FAILED%, }"
            exit 1
          fi

          if [ "$IS_TEST_ONLY" = "true" ]; then
            echo "‚úÖ All jobs passed! (test-only fast path - lint & unit tests skipped)"
          else
            echo "‚úÖ All jobs passed!"
          fi

  # ============================================================================
  # TDD AUTOMATION JOBS
  #
  # These jobs handle TDD lifecycle events that must run IMMEDIATELY on PR events.
  # They complement tdd-monitor.yml which provides SCHEDULED RECOVERY as backup.
  #
  # Architecture (Defense-in-Depth):
  # - close-tdd-issue: Closes issue on PR merge with retry & verification (primary)
  # - delete-tdd-branch: Immediate cleanup on PR close (vs. weekly in monitor)
  # - handle-regressions: First response to regressions (vs. scheduled recovery)
  #
  # The overlap with tdd-monitor.yml is INTENTIONAL:
  # - test.yml: Event-driven, immediate response
  # - tdd-monitor.yml: Scheduled polling, catches edge cases & API failures
  #
  # For scheduled recovery and health monitoring, see: tdd-monitor.yml
  # ============================================================================

  close-tdd-issue:
    name: Close TDD Issue on PR Merge
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.labels.*.name, 'tdd-automation')
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Extract issue number from PR body
        id: issue
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -o 'Closes #[0-9]*' | head -1 | grep -o '[0-9]*' || echo "")

          if [ -z "$ISSUE_NUMBER" ]; then
            echo "‚ö†Ô∏è No issue number found in PR body"
            echo "has_issue=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found issue #$ISSUE_NUMBER"
            echo "has_issue=true" >> $GITHUB_OUTPUT
            echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          fi

      - name: Close issue with verification
        if: steps.issue.outputs.has_issue == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
        run: |
          ISSUE_NUMBER="${{ steps.issue.outputs.issue_number }}"

          # ‚îÄ‚îÄ Step 1: Close the issue ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          echo "üìã Closing issue #$ISSUE_NUMBER..."
          gh issue close "$ISSUE_NUMBER" --reason completed
          gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed"
          gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress"

          # Clean up retry labels (may have been added during failed attempts)
          for label in retry:spec:1 retry:spec:2 retry:spec:3 retry:infra:1 retry:infra:2 retry:infra:3; do
            gh issue edit "$ISSUE_NUMBER" --remove-label "$label" 2>/dev/null || true
          done

          # Clean up failure classification labels
          for label in failure:spec failure:regression failure:infra; do
            gh issue edit "$ISSUE_NUMBER" --remove-label "$label" 2>/dev/null || true
          done

          # ‚îÄ‚îÄ Step 2: Verify closure with retry ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          echo ""
          echo "üîç Verifying issue closure..."

          for attempt in 1 2 3; do
            sleep 2  # Brief delay for API consistency

            ISSUE_DATA=$(gh issue view "$ISSUE_NUMBER" --json state,labels --jq '{state: .state, labels: [.labels[].name]}')
            STATE=$(echo "$ISSUE_DATA" | jq -r '.state')
            LABELS=$(echo "$ISSUE_DATA" | jq -r '.labels | join(", ")')

            echo "  Attempt $attempt: state=$STATE, labels=$LABELS"

            if [ "$STATE" = "CLOSED" ]; then
              # Verify labels are correct
              if echo "$LABELS" | grep -q "tdd-spec:completed"; then
                if ! echo "$LABELS" | grep -q "tdd-spec:in-progress"; then
                  echo "‚úÖ Issue #$ISSUE_NUMBER verified: closed with correct labels"
                  exit 0
                fi
              fi

              # Fix labels if needed
              echo "‚ö†Ô∏è Fixing labels..."
              gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed" || true
              gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true
              echo "‚úÖ Issue #$ISSUE_NUMBER closed with labels fixed"
              exit 0
            fi

            echo "  Issue still open, retrying..."
          done

          # ‚îÄ‚îÄ Step 3: Force closure if verification failed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          echo ""
          echo "‚ùå CRITICAL: Issue #$ISSUE_NUMBER failed to close after 3 attempts"
          echo "üîß Forcing closure via REST API..."

          gh api --method PATCH "/repos/${{ github.repository }}/issues/$ISSUE_NUMBER" \
            -f state='closed' \
            -f state_reason='completed' || true

          gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed" || true
          gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true

          # Final verification
          FINAL_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state')
          if [ "$FINAL_STATE" = "CLOSED" ]; then
            echo "‚úÖ Successfully force-closed issue #$ISSUE_NUMBER"
            echo "üîì Queue unblocked - processor can continue with next spec"
          else
            echo "‚ùå FAILED to close issue #$ISSUE_NUMBER - manual intervention required"
            echo "::error::Failed to close issue #$ISSUE_NUMBER after PR merge - queue may be blocked"
            exit 1
          fi

  delete-tdd-branch:
    name: Delete TDD Branch on PR Close
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == false &&
      (startsWith(github.event.pull_request.head.ref, 'tdd/') ||
       startsWith(github.event.pull_request.head.ref, 'claude/'))
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Delete branch
        run: |
          BRANCH="${{ github.event.pull_request.head.ref }}"
          echo "üóëÔ∏è  Deleting unmerged branch: $BRANCH"

          gh api \
            --method DELETE \
            /repos/${{ github.repository }}/git/refs/heads/$BRANCH \
            && echo "‚úÖ Branch deleted successfully" \
            || echo "‚ö†Ô∏è  Branch may already be deleted"
        env:
          GH_TOKEN: ${{ github.token }}

  handle-regressions:
    name: Handle TDD Regressions
    needs: e2e-results
    if: |
      failure() &&
      needs.e2e-results.outputs.has_regressions == 'true' &&
      contains(github.event.pull_request.labels.*.name, 'tdd-automation')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: Add regression label to PR
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          echo "üè∑Ô∏è  Adding failure:regression label to PR #$PR_NUMBER"
          gh pr edit "$PR_NUMBER" --add-label "failure:regression" || true

      - name: Extract issue and failure details
        id: details
        env:
          GH_TOKEN: ${{ github.token }}
          PR_BODY: ${{ github.event.pull_request.body }}
          REGRESSION_SPECS: ${{ needs.e2e-results.outputs.regression_specs }}
          TARGET_SPEC: ${{ needs.e2e-results.outputs.target_spec }}
          FAILURE_TYPE: ${{ needs.e2e-results.outputs.failure_type }}
        run: |
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oP 'Closes #\K[0-9]+' | head -1 || echo "")
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          SPEC_ID=""
          if [ -n "$ISSUE_NUMBER" ]; then
            ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title --jq '.title' 2>/dev/null || echo "")
            SPEC_ID=$(echo "$ISSUE_TITLE" | grep -oP '[A-Z]+-[A-Z]+-[0-9]+' | head -1 || echo "unknown")
          fi
          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT

          echo ""
          echo "üìã Regression Details:"
          echo "  Issue: #$ISSUE_NUMBER"
          echo "  Spec ID: $SPEC_ID"
          echo "  Target spec: $TARGET_SPEC"
          echo "  Regression specs: $REGRESSION_SPECS"
          echo "  Failure type: $FAILURE_TYPE"

      - name: Check for recent fix attempts (cooldown)
        id: cooldown
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          # Check for recent regression/fix comments in the last 30 minutes
          # This prevents duplicate @claude comments from both test.yml and tdd-monitor.yml
          echo "üïê Checking for recent fix attempt comments..."

          CUTOFF_TIME=$(date -u -d '30 minutes ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || \
                        date -u -v-30M +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || \
                        echo "1970-01-01T00:00:00Z")

          echo "  Cutoff time: $CUTOFF_TIME"

          # Get recent comments and check for regression-related content
          RECENT_COMMENTS=$(gh api "/repos/${{ github.repository }}/issues/$PR_NUMBER/comments" \
            --jq "[.[] | select(.created_at > \"$CUTOFF_TIME\") | select(.body | test(\"Regression Detected|Failed PR Recovery|Auto-Fix Required\"; \"i\"))] | length" \
            2>/dev/null || echo "0")

          echo "  Recent regression comments found: $RECENT_COMMENTS"

          if [ "$RECENT_COMMENTS" -gt 0 ]; then
            echo "‚è≠Ô∏è  Skipping: Recent fix attempt comment exists (cooldown active)"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No recent comments, proceeding with regression notification"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Check if Claude Code is actively processing this spec
        id: claude-check
        if: steps.cooldown.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          SPEC_ID: ${{ steps.details.outputs.spec_id }}
        run: |
          # Check if Claude Code is actively processing this spec
          # This prevents posting @claude regression fix while original Claude is still running
          echo "üîç Checking if Claude Code is actively processing spec $SPEC_ID..."

          if [ -z "$SPEC_ID" ]; then
            echo "‚ö†Ô∏è  No spec ID found, proceeding with regression notification"
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          CLAUDE_RUNNING=$(gh run list \
            --repo ${{ github.repository }} \
            --workflow "TDD - Execute (Claude Code)" \
            --json status,displayTitle \
            --jq "[.[] | select(.status == \"in_progress\" or .status == \"queued\") | select(.displayTitle | contains(\"$SPEC_ID\"))] | length" 2>/dev/null || echo "0")

          echo "  Claude Code runs for $SPEC_ID: $CLAUDE_RUNNING"

          if [ "$CLAUDE_RUNNING" -gt 0 ]; then
            echo "‚è≠Ô∏è  Skipping: Claude Code is actively processing spec $SPEC_ID"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No active Claude Code run, proceeding with regression notification"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Post regression fix request to PR (immediate @claude trigger)
        # Uses PAT so @claude triggers Claude Code immediately (no waiting for tdd-monitor.yml)
        # The cooldown check and claude-check above prevent duplicate triggers
        if: steps.cooldown.outputs.skip != 'true' && steps.claude-check.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          ISSUE_NUMBER: ${{ steps.details.outputs.issue_number }}
          SPEC_ID: ${{ steps.details.outputs.spec_id }}
          REGRESSION_SPECS: ${{ needs.e2e-results.outputs.regression_specs }}
          TARGET_SPEC: ${{ needs.e2e-results.outputs.target_spec }}
          FAILURE_TYPE: ${{ needs.e2e-results.outputs.failure_type }}
          BRANCH: ${{ github.event.pull_request.head.ref }}
        run: |
          cat << 'EOF' > /tmp/comment.md
          @claude fix the regression in this PR

          ## üîß Regression Auto-Fix Required (Immediate)

          This PR has **regressions** - tests failing in files OTHER than the target spec.

          ### üìä Failure Analysis
          - **Target Spec**: `$TARGET_SPEC`
          - **Regression Specs**: `$REGRESSION_SPECS`
          - **Failure Type**: `$FAILURE_TYPE`
          - **Spec ID**: `$SPEC_ID`
          - **Issue**: #$ISSUE_NUMBER
          - **PR**: #$PR_NUMBER

          ### ü§ñ Automation Mode

          **You are in pipeline/automation mode**:
          - ‚úÖ Make autonomous decisions following Sovrium patterns
          - ‚úÖ Fix the minimum code needed to pass tests
          - ‚ùå DO NOT ask questions - proceed with best judgment
          - ‚ùå DO NOT modify failing tests - fix the implementation instead

          ### ‚úÖ Critical Steps (ALL REQUIRED)

          1. **Checkout the PR branch and pull latest**:
             ```bash
             git fetch origin $BRANCH
             git checkout $BRANCH
             git pull origin $BRANCH
             ```

          2. **Run the failing regression specs to understand the failure**:
             ```bash
             bun test:e2e -- $REGRESSION_SPECS
             ```

          3. **Identify the regression cause**:
             - Look at what changed in the implementation: `git diff HEAD~1`
             - Common causes: catch-all schemas that are too greedy, validation changes affecting other tests
             - Check which assertions are failing and trace back to your changes

          4. **Fix WITHOUT modifying the failing tests**:
             - Preserve existing validation behavior
             - For catch-all schemas: explicitly EXCLUDE known types
             - Ensure backward compatibility

          5. **Run codebase-refactor-auditor** - Use `Task` tool with `subagent_type='codebase-refactor-auditor'` to ensure fix follows architecture patterns

          6. **Verify ALL tests pass**:
             ```bash
             bun run quality
             bun test:e2e -- $TARGET_SPEC
             bun test:e2e -- $REGRESSION_SPECS
             ```
             ALL checks must pass before proceeding.

          7. **Push the fix**:
             ```bash
             bun run license
             git add -A
             git commit -m "fix: resolve regression in $SPEC_ID"
             git push
             ```

          8. **Verify auto-merge is still enabled**:
             ```bash
             gh pr view $PR_NUMBER --json autoMergeRequest
             ```
             If null, re-enable: `gh pr merge $PR_NUMBER --auto --squash`

          ### üö® MOST COMMON REGRESSION CAUSES

          - **Greedy catch-all schemas**: UnknownFieldSchema with `type: Schema.String` catches valid types
          - **Validation bypass**: Removing/weakening validation that other tests rely on
          - **Type signature changes**: Breaking dependent code with new return types

          **Complete workflow documentation**: `@docs/development/tdd-automation-pipeline.md`

          ---
          *ü§ñ Regression Handler (Immediate Response) - [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*
          EOF

          envsubst < /tmp/comment.md > /tmp/comment_final.md
          gh pr comment "$PR_NUMBER" --body-file /tmp/comment_final.md
          echo "‚úÖ Posted @claude regression fix request to PR #$PR_NUMBER (immediate trigger)"

      - name: Update issue with regression status
        if: steps.cooldown.outputs.skip != 'true' && steps.claude-check.outputs.skip != 'true' && steps.details.outputs.issue_number != ''
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.details.outputs.issue_number }}
          REGRESSION_SPECS: ${{ needs.e2e-results.outputs.regression_specs }}
        run: |
          gh issue comment "$ISSUE_NUMBER" --body "‚ö†Ô∏è **Regression Detected**

          The PR for this spec has introduced regressions in other test files:
          - **Regression specs**: \`$REGRESSION_SPECS\`

          Claude Code will attempt to auto-fix the regression.

          ---
          *ü§ñ Regression Handler*"

          gh issue edit "$ISSUE_NUMBER" --add-label "failure:regression" || true

  # ============================================================================
  # HANDLE CODE QUALITY FAILURES FOR TDD AUTOMATION
  # Triggers @claude fix when lint/typecheck/unit-tests fail on TDD PRs
  # This fills the gap where E2E regression handling doesn't cover code quality
  # ============================================================================

  handle-code-quality-failure:
    name: Handle TDD Code Quality Failures
    needs: [detect-change-type, lint, typecheck, unit-tests]
    if: |
      always() &&
      github.event_name == 'pull_request' &&
      github.event.action != 'closed' &&
      contains(github.event.pull_request.labels.*.name, 'tdd-automation') &&
      (needs.lint.result == 'failure' || needs.typecheck.result == 'failure' || needs.unit-tests.result == 'failure')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Determine failure type
        id: failure-type
        run: |
          LINT_RESULT="${{ needs.lint.result }}"
          TYPECHECK_RESULT="${{ needs.typecheck.result }}"
          UNIT_RESULT="${{ needs.unit-tests.result }}"

          echo "üìä Code quality job results:"
          echo "  Lint:       $LINT_RESULT"
          echo "  TypeCheck:  $TYPECHECK_RESULT"
          echo "  Unit Tests: $UNIT_RESULT"
          echo ""

          # Prioritize: typecheck > lint > unit-tests
          if [ "$TYPECHECK_RESULT" = "failure" ]; then
            echo "type=typecheck" >> $GITHUB_OUTPUT
            echo "label=failure:typecheck" >> $GITHUB_OUTPUT
            echo "command=bun run typecheck" >> $GITHUB_OUTPUT
            echo "message=TypeScript compilation errors detected" >> $GITHUB_OUTPUT
            echo "‚ùå Primary failure: TypeCheck"
          elif [ "$LINT_RESULT" = "failure" ]; then
            echo "type=lint" >> $GITHUB_OUTPUT
            echo "label=failure:lint" >> $GITHUB_OUTPUT
            echo "command=bun run lint" >> $GITHUB_OUTPUT
            echo "message=ESLint errors detected" >> $GITHUB_OUTPUT
            echo "‚ùå Primary failure: Lint"
          elif [ "$UNIT_RESULT" = "failure" ]; then
            echo "type=unit-tests" >> $GITHUB_OUTPUT
            echo "label=failure:unit-tests" >> $GITHUB_OUTPUT
            echo "command=bun test:unit" >> $GITHUB_OUTPUT
            echo "message=Unit test failures detected" >> $GITHUB_OUTPUT
            echo "‚ùå Primary failure: Unit Tests"
          fi

      - name: Extract issue details
        id: issue
        env:
          GH_TOKEN: ${{ github.token }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oP 'Closes #\K[0-9]+' | head -1 || echo "")
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          if [ -n "$ISSUE_NUMBER" ]; then
            echo "üìã Linked issue: #$ISSUE_NUMBER"
            ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title --jq '.title' 2>/dev/null || echo "")
            SPEC_ID=$(echo "$ISSUE_TITLE" | grep -oP '[A-Z]+-[A-Z]+-[A-Z]*-?[0-9]+' | head -1 || echo "unknown")
            echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT
            echo "   Spec ID: $SPEC_ID"
          else
            echo "‚ö†Ô∏è  No linked issue found"
            echo "spec_id=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Add failure label to PR
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          FAILURE_LABEL: ${{ steps.failure-type.outputs.label }}
        run: |
          echo "üè∑Ô∏è  Adding $FAILURE_LABEL label to PR #$PR_NUMBER"
          gh pr edit "$PR_NUMBER" --add-label "$FAILURE_LABEL" || true

      - name: Check for recent fix attempts (cooldown)
        id: cooldown
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          FAILURE_TYPE: ${{ steps.failure-type.outputs.type }}
        run: |
          echo "üïê Checking for recent fix attempt comments..."

          CUTOFF_TIME=$(date -u -d '30 minutes ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || \
                        date -u -v-30M +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || \
                        echo "1970-01-01T00:00:00Z")

          RECENT_COMMENTS=$(gh api "/repos/${{ github.repository }}/issues/$PR_NUMBER/comments" \
            --jq "[.[] | select(.created_at > \"$CUTOFF_TIME\") | select(.body | test(\"Code Quality.*Auto-Fix|$FAILURE_TYPE.*error\"; \"i\"))] | length" \
            2>/dev/null || echo "0")

          echo "  Recent $FAILURE_TYPE fix comments: $RECENT_COMMENTS"

          if [ "$RECENT_COMMENTS" -gt 0 ]; then
            echo "‚è≠Ô∏è  Skipping: Recent fix attempt exists (cooldown active)"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No recent comments, proceeding with fix request"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Post code quality fix request to PR
        if: steps.cooldown.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
          SPEC_ID: ${{ steps.issue.outputs.spec_id }}
          FAILURE_TYPE: ${{ steps.failure-type.outputs.type }}
          FAILURE_MESSAGE: ${{ steps.failure-type.outputs.message }}
          FAILURE_COMMAND: ${{ steps.failure-type.outputs.command }}
          BRANCH: ${{ github.event.pull_request.head.ref }}
        run: |
          cat << 'EOF' > /tmp/comment.md
          @claude fix the $FAILURE_TYPE errors in this PR

          ## üîß Code Quality Auto-Fix Required

          This TDD automation PR has **$FAILURE_TYPE errors** that must be fixed before tests can run.

          ### üìä Error Details
          - **Failure Type**: `$FAILURE_TYPE`
          - **Message**: $FAILURE_MESSAGE
          - **Spec ID**: `$SPEC_ID`
          - **Issue**: #$ISSUE_NUMBER
          - **PR**: #$PR_NUMBER

          ### ü§ñ Automation Mode

          **You are in pipeline/automation mode**:
          - ‚úÖ Make autonomous decisions following Sovrium patterns
          - ‚úÖ Fix the minimum code needed to pass checks
          - ‚ùå DO NOT ask questions - proceed with best judgment
          - ‚ùå DO NOT modify test assertions

          ### ‚úÖ Steps to Fix

          1. **Checkout the PR branch**:
             ```bash
             git fetch origin $BRANCH
             git checkout $BRANCH
             git pull origin $BRANCH
             ```

          2. **Run the failing check to see errors**:
             ```bash
             $FAILURE_COMMAND 2>&1 | head -100
             ```

          3. **Fix all errors**:
             - For TypeScript errors: Fix type mismatches, unused variables, missing imports
             - For ESLint errors: Run `bun run lint:fix` first, then fix remaining issues
             - For unit test errors: Fix the implementation (NOT the tests)

          4. **Verify ALL checks pass**:
             ```bash
             bun run quality
             ```
             ALL checks must pass before proceeding.

          5. **Push the fix**:
             ```bash
             bun run license
             git add -A
             git commit -m "fix: resolve $FAILURE_TYPE errors in $SPEC_ID"
             git push
             ```

          6. **Verify auto-merge is still enabled**:
             ```bash
             gh pr view $PR_NUMBER --json autoMergeRequest
             ```
             If null, re-enable: `gh pr merge $PR_NUMBER --auto --squash`

          ### üö® Common $FAILURE_TYPE Fixes

          **TypeScript**:
          - `TS6133` (unused variable): Remove the variable or use it
          - `TS2322` (type mismatch): Fix the type or add proper casting
          - `TS2339` (property missing): Add the property to the type or check it exists

          **ESLint**:
          - Run `bun run lint:fix` to auto-fix most issues
          - Check for unused imports, missing semicolons (we use no-semicolons)

          **Unit Tests**:
          - Check test output for specific assertion failures
          - Fix the implementation, NOT the test expectations

          ---
          *ü§ñ Code Quality Handler - [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*
          EOF

          envsubst < /tmp/comment.md > /tmp/comment_final.md
          gh pr comment "$PR_NUMBER" --body-file /tmp/comment_final.md
          echo "‚úÖ Posted @claude $FAILURE_TYPE fix request to PR #$PR_NUMBER"

      - name: Update linked issue with failure status
        if: steps.cooldown.outputs.skip != 'true' && steps.issue.outputs.issue_number != ''
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
          FAILURE_TYPE: ${{ steps.failure-type.outputs.type }}
          FAILURE_MESSAGE: ${{ steps.failure-type.outputs.message }}
        run: |
          gh issue comment "$ISSUE_NUMBER" --body "‚ö†Ô∏è **Code Quality Failure**

          The PR for this spec has **$FAILURE_TYPE errors**:
          - **Error**: $FAILURE_MESSAGE

          Claude Code will attempt to auto-fix the errors.

          ---
          *ü§ñ Code Quality Handler*"

          gh issue edit "$ISSUE_NUMBER" --add-label "failure:$FAILURE_TYPE" || true
