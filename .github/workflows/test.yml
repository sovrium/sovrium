name: Test
permissions:
  contents: read
  actions: write
  issues: write
  pull-requests: write

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main]

env:
  # Infrastructure retry configuration
  MAX_E2E_RETRIES: 2
  E2E_RETRY_DELAY_SECONDS: 30

jobs:
  test:
    name: Test
    if: github.event_name == 'push' || github.event.action != 'closed'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      e2e_failed: ${{ steps.e2e.outcome == 'failure' && steps.e2e-retry.outcome == 'failure' }}
      has_regressions: ${{ steps.classify-failures.outputs.has_regressions }}
      regression_specs: ${{ steps.classify-failures.outputs.regression_specs }}
      target_spec: ${{ steps.classify-failures.outputs.target_spec }}
      failure_type: ${{ steps.classify-failures.outputs.failure_type }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        id: bun-cache
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Cache ESLint results
        uses: actions/cache@v4
        with:
          path: .eslintcache
          key: ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('eslint.config.ts', '.eslintrc*', '.eslintignore') }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('eslint.config.ts', '.eslintrc*', '.eslintignore') }}-
            ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-

      - name: Lint code
        run: bun run lint

      - name: Type check
        run: bun run typecheck

      - name: Run unit tests
        run: bun test:unit

      - name: Validate spec counts
        run: bun run validate:spec-counts

      - name: Get Playwright version
        id: playwright-version
        run: echo "version=$(bun pm ls @playwright/test | grep '@playwright/test' | awk '{print $2}' | head -n 1)" >> $GITHUB_OUTPUT

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ steps.playwright-version.outputs.version }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: bunx playwright install --with-deps chromium

      - name: Pre-pull Docker images
        run: |
          echo "üê≥ Pre-pulling Docker images to reduce E2E startup time..."
          # Pull images in parallel to speed up the process
          docker pull axllent/mailpit:latest &
          docker pull postgres:16-alpine &
          wait
          echo "‚úÖ Docker images pre-pulled successfully"

      - name: Verify Docker ready
        run: |
          echo "üîç Verifying Docker daemon is ready..."
          docker info > /dev/null 2>&1 || { echo "‚ùå Docker not running"; exit 1; }
          echo "‚úÖ Docker daemon is ready"

      - name: Run E2E tests
        id: e2e
        run: bun test:e2e:regression
        continue-on-error: true

      - name: Retry E2E tests on infrastructure failure
        id: e2e-retry
        if: steps.e2e.outcome == 'failure'
        run: |
          echo "‚ö†Ô∏è E2E tests failed on first attempt"
          echo "üîç Checking if failure is infrastructure-related..."

          # Check for common infrastructure error patterns in test output
          # Give infrastructure time to stabilize
          echo "‚è≥ Waiting ${{ env.E2E_RETRY_DELAY_SECONDS }}s before retry..."
          sleep ${{ env.E2E_RETRY_DELAY_SECONDS }}

          # Clean up any stale containers
          echo "üßπ Cleaning up stale containers..."
          docker ps -aq --filter "name=sovrium-" | xargs -r docker rm -f 2>/dev/null || true
          docker ps -aq --filter "name=mailpit" | xargs -r docker rm -f 2>/dev/null || true

          echo "üîÑ Retrying E2E tests (attempt 2 of 2)..."
          bun test:e2e:regression

      - name: E2E tests final status
        if: always()
        run: |
          if [ "${{ steps.e2e.outcome }}" = "success" ]; then
            echo "‚úÖ E2E tests passed on first attempt"
          elif [ "${{ steps.e2e-retry.outcome }}" = "success" ]; then
            echo "‚úÖ E2E tests passed on retry (infrastructure was flaky)"
          elif [ "${{ steps.e2e-retry.outcome }}" = "failure" ]; then
            echo "‚ùå E2E tests failed after retry - likely a real test failure"
            exit 1
          elif [ "${{ steps.e2e.outcome }}" = "failure" ]; then
            echo "‚ùå E2E tests failed"
            exit 1
          fi

      # Regression Detection: Classify failures as in-scope vs out-of-scope (regressions)
      - name: Classify test failures
        id: classify-failures
        if: |
          failure() &&
          contains(github.event.pull_request.labels.*.name, 'tdd-automation')
        env:
          GH_TOKEN: ${{ github.token }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          echo "üîç Classifying test failures for TDD automation PR..."

          # Extract target spec from PR body (format: "Closes #ISSUE" -> get spec from issue)
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oP 'Closes #\K[0-9]+' | head -1 || echo "")
          TARGET_SPEC=""

          if [ -n "$ISSUE_NUMBER" ]; then
            echo "üìã Found linked issue: #$ISSUE_NUMBER"
            # Get spec file path from issue body
            ISSUE_BODY=$(gh issue view "$ISSUE_NUMBER" --json body --jq '.body' 2>/dev/null || echo "")
            TARGET_SPEC=$(echo "$ISSUE_BODY" | grep -oP '\*\*File\*\*:\s*`\K[^`]+' | head -1 || echo "")

            if [ -z "$TARGET_SPEC" ]; then
              # Fallback: extract from test file path pattern
              TARGET_SPEC=$(echo "$ISSUE_BODY" | grep -oP 'specs/[^\s:]+\.spec\.ts' | head -1 || echo "")
            fi
            echo "üéØ Target spec: $TARGET_SPEC"
          fi

          # Parse failed tests from test output (GitHub Actions annotations)
          # Look for failed test files in the workflow logs
          FAILED_SPECS=""

          # Check test-results directory for failed test traces
          if [ -d "test-results" ]; then
            # Extract unique spec file paths from test-results directory names
            FAILED_SPECS=$(find test-results -type d -name "*.spec.ts*" 2>/dev/null | \
              sed 's|test-results/||' | \
              sed 's|-chromium.*||' | \
              sed 's|--.*||' | \
              tr '-' '/' | \
              sed 's|^|specs/|' | \
              sed 's|$|.spec.ts|' | \
              sort -u | tr '\n' ',' | sed 's/,$//')
          fi

          # Fallback: grep from workflow output if test-results parsing fails
          if [ -z "$FAILED_SPECS" ]; then
            echo "‚ö†Ô∏è Could not parse failed specs from test-results, checking annotations..."
            FAILED_SPECS="unknown"
          fi

          echo "‚ùå Failed specs: $FAILED_SPECS"

          # Classify failures
          HAS_REGRESSIONS="false"
          REGRESSION_SPECS=""
          FAILURE_TYPE="unknown"

          if [ -n "$TARGET_SPEC" ] && [ "$FAILED_SPECS" != "unknown" ]; then
            # Check if any failed spec is NOT the target spec (regression)
            IFS=',' read -ra SPECS_ARRAY <<< "$FAILED_SPECS"
            for spec in "${SPECS_ARRAY[@]}"; do
              spec=$(echo "$spec" | xargs)  # trim whitespace
              if [ -n "$spec" ] && [ "$spec" != "$TARGET_SPEC" ]; then
                HAS_REGRESSIONS="true"
                if [ -z "$REGRESSION_SPECS" ]; then
                  REGRESSION_SPECS="$spec"
                else
                  REGRESSION_SPECS="$REGRESSION_SPECS,$spec"
                fi
              fi
            done

            # Determine failure type
            if [ "$HAS_REGRESSIONS" = "true" ]; then
              # Check if target spec also failed
              if echo "$FAILED_SPECS" | grep -q "$TARGET_SPEC"; then
                FAILURE_TYPE="mixed"  # Both target and regressions
              else
                FAILURE_TYPE="regression_only"  # Only regressions, target passes
              fi
            else
              FAILURE_TYPE="target_only"  # Only target spec failed
            fi
          fi

          echo ""
          echo "üìä Classification Results:"
          echo "  Target spec: $TARGET_SPEC"
          echo "  Failed specs: $FAILED_SPECS"
          echo "  Has regressions: $HAS_REGRESSIONS"
          echo "  Regression specs: $REGRESSION_SPECS"
          echo "  Failure type: $FAILURE_TYPE"

          # Output results
          echo "has_regressions=$HAS_REGRESSIONS" >> $GITHUB_OUTPUT
          echo "regression_specs=$REGRESSION_SPECS" >> $GITHUB_OUTPUT
          echo "target_spec=$TARGET_SPEC" >> $GITHUB_OUTPUT
          echo "failure_type=$FAILURE_TYPE" >> $GITHUB_OUTPUT

      - name: Upload Playwright report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

      - name: Upload test results
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: test-results/
          retention-days: 30

  close-tdd-issue:
    name: Close TDD Issue on PR Merge
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.labels.*.name, 'tdd-automation')
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Extract issue number from PR body
        id: issue
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -o 'Closes #[0-9]*' | head -1 | grep -o '[0-9]*' || echo "")

          if [ -z "$ISSUE_NUMBER" ]; then
            echo "‚ö†Ô∏è No issue number found in PR body"
            echo "has_issue=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found issue #$ISSUE_NUMBER"
            echo "has_issue=true" >> $GITHUB_OUTPUT
            echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          fi

      - name: Close issue
        if: steps.issue.outputs.has_issue == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.issue.outputs.issue_number }}"

          gh issue close "$ISSUE_NUMBER" --reason completed
          gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed"
          gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress"

          echo "‚úÖ Closed issue #$ISSUE_NUMBER"
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}

  verify-issue-closed:
    name: Verify TDD Issue Closed After Merge
    needs: close-tdd-issue
    # Run after close-tdd-issue completes (even if it fails)
    # This ensures we catch cases where GitHub's auto-close or manual close fails
    if: |
      always() &&
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.labels.*.name, 'tdd-automation')
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Extract issue number from PR body
        id: issue
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -o 'Closes #[0-9]*' | head -1 | grep -o '[0-9]*' || echo "")

          if [ -z "$ISSUE_NUMBER" ]; then
            echo "‚ö†Ô∏è No issue number found in PR body - skipping verification"
            echo "has_issue=false" >> $GITHUB_OUTPUT
          else
            echo "üîç Found issue #$ISSUE_NUMBER - verifying closure"
            echo "has_issue=true" >> $GITHUB_OUTPUT
            echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          fi

      - name: Verify issue is closed
        if: steps.issue.outputs.has_issue == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.issue.outputs.issue_number }}"

          echo "üîç Checking if issue #$ISSUE_NUMBER is closed..."

          # Get issue state and labels
          ISSUE_DATA=$(gh issue view "$ISSUE_NUMBER" --json state,labels --jq '{state: .state, labels: [.labels[].name]}')
          STATE=$(echo "$ISSUE_DATA" | jq -r '.state')
          LABELS=$(echo "$ISSUE_DATA" | jq -r '.labels | join(", ")')

          echo "  Current state: $STATE"
          echo "  Current labels: $LABELS"

          # Check if issue is properly closed
          if [ "$STATE" = "CLOSED" ]; then
            # Verify labels are correct
            HAS_COMPLETED=$(echo "$LABELS" | grep -c "tdd-spec:completed" || echo "0")
            HAS_IN_PROGRESS=$(echo "$LABELS" | grep -c "tdd-spec:in-progress" || echo "0")

            if [ "$HAS_COMPLETED" -eq 1 ] && [ "$HAS_IN_PROGRESS" -eq 0 ]; then
              echo "‚úÖ Issue #$ISSUE_NUMBER is properly closed with correct labels"
            else
              echo "‚ö†Ô∏è Issue #$ISSUE_NUMBER is closed but has incorrect labels - fixing..."
              gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed" || true
              gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true
              echo "‚úÖ Fixed labels on issue #$ISSUE_NUMBER"
            fi
          else
            echo "‚ùå CRITICAL: Issue #$ISSUE_NUMBER failed to close - forcing closure"
            echo ""
            echo "This is the safeguard that prevents queue blocking when issue closure fails."
            echo "Without this, the queue would be blocked indefinitely (like issue #1317)."
            echo ""

            # Force close the issue with correct labels
            gh issue close "$ISSUE_NUMBER" --reason completed || {
              echo "‚ùå Failed to close issue - retrying with gh api..."
              gh api --method PATCH "/repos/${{ github.repository }}/issues/$ISSUE_NUMBER" \
                -f state='closed' \
                -f state_reason='completed'
            }

            gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed" || true
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true

            # Verify it worked
            NEW_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state')
            if [ "$NEW_STATE" = "CLOSED" ]; then
              echo "‚úÖ Successfully force-closed issue #$ISSUE_NUMBER"
              echo "üîì Queue unblocked - processor can continue with next spec"
            else
              echo "‚ùå FAILED to close issue #$ISSUE_NUMBER - manual intervention required"
              echo "::error::Failed to close issue #$ISSUE_NUMBER after PR merge - queue may be blocked"
              exit 1
            fi
          fi
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}

  delete-tdd-branch:
    name: Delete TDD Branch on PR Close
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == false &&
      (startsWith(github.event.pull_request.head.ref, 'tdd/') ||
       startsWith(github.event.pull_request.head.ref, 'claude/'))
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Delete branch
        run: |
          BRANCH="${{ github.event.pull_request.head.ref }}"
          echo "üóëÔ∏è  Deleting unmerged branch: $BRANCH"

          gh api \
            --method DELETE \
            /repos/${{ github.repository }}/git/refs/heads/$BRANCH \
            && echo "‚úÖ Branch deleted successfully" \
            || echo "‚ö†Ô∏è  Branch may already be deleted"
        env:
          GH_TOKEN: ${{ github.token }}

  # Regression Handler: Trigger Claude to fix regressions detected in TDD PRs
  handle-regressions:
    name: Handle TDD Regressions
    needs: test
    if: |
      failure() &&
      needs.test.outputs.has_regressions == 'true' &&
      contains(github.event.pull_request.labels.*.name, 'tdd-automation')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: Add regression label to PR
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          echo "üè∑Ô∏è  Adding failure:regression label to PR #$PR_NUMBER"
          gh pr edit "$PR_NUMBER" --add-label "failure:regression" || true

      - name: Extract issue and failure details
        id: details
        env:
          GH_TOKEN: ${{ github.token }}
          PR_BODY: ${{ github.event.pull_request.body }}
          REGRESSION_SPECS: ${{ needs.test.outputs.regression_specs }}
          TARGET_SPEC: ${{ needs.test.outputs.target_spec }}
          FAILURE_TYPE: ${{ needs.test.outputs.failure_type }}
        run: |
          # Extract issue number
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oP 'Closes #\K[0-9]+' | head -1 || echo "")
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

          # Get spec ID from issue
          SPEC_ID=""
          if [ -n "$ISSUE_NUMBER" ]; then
            ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title --jq '.title' 2>/dev/null || echo "")
            SPEC_ID=$(echo "$ISSUE_TITLE" | grep -oP '[A-Z]+-[A-Z]+-[0-9]+' | head -1 || echo "unknown")
          fi
          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT

          echo ""
          echo "üìã Regression Details:"
          echo "  Issue: #$ISSUE_NUMBER"
          echo "  Spec ID: $SPEC_ID"
          echo "  Target spec: $TARGET_SPEC"
          echo "  Regression specs: $REGRESSION_SPECS"
          echo "  Failure type: $FAILURE_TYPE"

      - name: Post regression fix instructions to PR
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          ISSUE_NUMBER: ${{ steps.details.outputs.issue_number }}
          SPEC_ID: ${{ steps.details.outputs.spec_id }}
          REGRESSION_SPECS: ${{ needs.test.outputs.regression_specs }}
          TARGET_SPEC: ${{ needs.test.outputs.target_spec }}
          FAILURE_TYPE: ${{ needs.test.outputs.failure_type }}
          BRANCH: ${{ github.event.pull_request.head.ref }}
        run: |
          cat << 'EOF' > /tmp/comment.md
          ## üîß Regression Detected - Auto-Fix Required

          @claude This PR has **regressions** - tests failing in files OTHER than the target spec.

          ### üìä Failure Analysis
          - **Target Spec**: `$TARGET_SPEC`
          - **Regression Specs**: `$REGRESSION_SPECS`
          - **Failure Type**: `$FAILURE_TYPE`
          - **Spec ID**: `$SPEC_ID`
          - **Issue**: #$ISSUE_NUMBER

          ### ü§ñ Auto-Fix Instructions

          **CRITICAL**: Your changes broke tests in other files. This is a **regression** that must be fixed.

          1. **Analyze the regression cause**:
             - Run `bun test:e2e -- $REGRESSION_SPECS` to see the failing tests
             - Check what code you changed that could affect these tests
             - Look for **catch-all patterns** that are too greedy (like `Schema.String` catching valid types)

          2. **Common regression causes**:
             - **Greedy catch-all schemas**: `UnknownFieldSchema` with `type: Schema.String` will match ANY field type, including valid ones that fail validation on their specific schema
             - **Changed validation logic**: Making validation more permissive can let invalid data through
             - **Type changes**: Changing a type signature can break dependent code

          3. **Fix the regression**:
             - Ensure your changes don't bypass existing validation
             - For catch-all schemas: explicitly EXCLUDE known types
             - Test that BOTH your target spec AND regression specs pass

          4. **Verify the fix**:
             ```bash
             bun run quality
             bun test:e2e -- $TARGET_SPEC
             bun test:e2e -- $REGRESSION_SPECS
             bun test:e2e:regression
             ```

          5. **Push the fix**:
             ```bash
             bun run license
             git add -A
             git commit -m "fix: resolve regression in $SPEC_ID"
             git push
             ```

          ### ‚ö†Ô∏è DO NOT:
          - Modify the failing tests to make them pass
          - Revert your entire implementation
          - Skip regression tests

          ---
          *ü§ñ Regression Handler - [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*
          EOF

          # Substitute environment variables in the comment
          envsubst < /tmp/comment.md > /tmp/comment_final.md

          gh pr comment "$PR_NUMBER" --body-file /tmp/comment_final.md

          echo "‚úÖ Posted regression fix instructions to PR #$PR_NUMBER"

      - name: Update issue with regression status
        if: steps.details.outputs.issue_number != ''
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.details.outputs.issue_number }}
          REGRESSION_SPECS: ${{ needs.test.outputs.regression_specs }}
        run: |
          gh issue comment "$ISSUE_NUMBER" --body "‚ö†Ô∏è **Regression Detected**

          The PR for this spec has introduced regressions in other test files:
          - **Regression specs**: \`$REGRESSION_SPECS\`

          Claude Code will attempt to auto-fix the regression. If unsuccessful after 3 attempts, this issue will be marked as \`tdd-spec:failed\`.

          ---
          *ü§ñ Regression Handler*"

          # Add regression label to issue
          gh issue edit "$ISSUE_NUMBER" --add-label "failure:regression" || true
