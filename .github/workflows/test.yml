name: Test
permissions:
  contents: read
  actions: write

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main]

env:
  # Infrastructure retry configuration
  MAX_E2E_RETRIES: 2
  E2E_RETRY_DELAY_SECONDS: 30

jobs:
  test:
    name: Test
    if: github.event_name == 'push' || github.event.action != 'closed'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      e2e_failed: ${{ steps.e2e.outcome == 'failure' && steps.e2e-retry.outcome == 'failure' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        id: bun-cache
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Cache ESLint results
        uses: actions/cache@v4
        with:
          path: .eslintcache
          key: ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('eslint.config.ts', '.eslintrc*', '.eslintignore') }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-${{ hashFiles('eslint.config.ts', '.eslintrc*', '.eslintignore') }}-
            ${{ runner.os }}-eslint-${{ hashFiles('**/bun.lockb') }}-

      - name: Lint code
        run: bun run lint

      - name: Type check
        run: bun run typecheck

      - name: Effect diagnostics
        run: bun node_modules/@effect/language-service/cli.js diagnostics --project tsconfig.json

      - name: Run unit tests
        run: bun test:unit

      - name: Validate spec counts
        run: bun run validate:spec-counts

      - name: Get Playwright version
        id: playwright-version
        run: echo "version=$(bun pm ls @playwright/test | grep '@playwright/test' | awk '{print $2}' | head -n 1)" >> $GITHUB_OUTPUT

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ steps.playwright-version.outputs.version }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: bunx playwright install --with-deps chromium

      - name: Pre-pull Docker images
        run: |
          echo "üê≥ Pre-pulling Docker images to reduce E2E startup time..."
          # Pull images in parallel to speed up the process
          docker pull axllent/mailpit:latest &
          docker pull postgres:16-alpine &
          wait
          echo "‚úÖ Docker images pre-pulled successfully"

      - name: Verify Docker ready
        run: |
          echo "üîç Verifying Docker daemon is ready..."
          docker info > /dev/null 2>&1 || { echo "‚ùå Docker not running"; exit 1; }
          echo "‚úÖ Docker daemon is ready"

      - name: Run E2E tests
        id: e2e
        run: bun test:e2e:regression
        continue-on-error: true

      - name: Retry E2E tests on infrastructure failure
        id: e2e-retry
        if: steps.e2e.outcome == 'failure'
        run: |
          echo "‚ö†Ô∏è E2E tests failed on first attempt"
          echo "üîç Checking if failure is infrastructure-related..."

          # Check for common infrastructure error patterns in test output
          # Give infrastructure time to stabilize
          echo "‚è≥ Waiting ${{ env.E2E_RETRY_DELAY_SECONDS }}s before retry..."
          sleep ${{ env.E2E_RETRY_DELAY_SECONDS }}

          # Clean up any stale containers
          echo "üßπ Cleaning up stale containers..."
          docker ps -aq --filter "name=sovrium-" | xargs -r docker rm -f 2>/dev/null || true
          docker ps -aq --filter "name=mailpit" | xargs -r docker rm -f 2>/dev/null || true

          echo "üîÑ Retrying E2E tests (attempt 2 of 2)..."
          bun test:e2e:regression

      - name: E2E tests final status
        if: always()
        run: |
          if [ "${{ steps.e2e.outcome }}" = "success" ]; then
            echo "‚úÖ E2E tests passed on first attempt"
          elif [ "${{ steps.e2e-retry.outcome }}" = "success" ]; then
            echo "‚úÖ E2E tests passed on retry (infrastructure was flaky)"
          elif [ "${{ steps.e2e-retry.outcome }}" = "failure" ]; then
            echo "‚ùå E2E tests failed after retry - likely a real test failure"
            exit 1
          elif [ "${{ steps.e2e.outcome }}" = "failure" ]; then
            echo "‚ùå E2E tests failed"
            exit 1
          fi

      - name: Upload Playwright report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

      - name: Upload test results
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: test-results/
          retention-days: 30

  close-tdd-issue:
    name: Close TDD Issue on PR Merge
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.labels.*.name, 'tdd-automation')
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Extract issue number from PR body
        id: issue
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -o 'Closes #[0-9]*' | head -1 | grep -o '[0-9]*' || echo "")

          if [ -z "$ISSUE_NUMBER" ]; then
            echo "‚ö†Ô∏è No issue number found in PR body"
            echo "has_issue=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found issue #$ISSUE_NUMBER"
            echo "has_issue=true" >> $GITHUB_OUTPUT
            echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          fi

      - name: Close issue
        if: steps.issue.outputs.has_issue == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.issue.outputs.issue_number }}"

          gh issue close "$ISSUE_NUMBER" --reason completed
          gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed"
          gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress"

          echo "‚úÖ Closed issue #$ISSUE_NUMBER"
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}

  verify-issue-closed:
    name: Verify TDD Issue Closed After Merge
    needs: close-tdd-issue
    # Run after close-tdd-issue completes (even if it fails)
    # This ensures we catch cases where GitHub's auto-close or manual close fails
    if: |
      always() &&
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.labels.*.name, 'tdd-automation')
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Extract issue number from PR body
        id: issue
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -o 'Closes #[0-9]*' | head -1 | grep -o '[0-9]*' || echo "")

          if [ -z "$ISSUE_NUMBER" ]; then
            echo "‚ö†Ô∏è No issue number found in PR body - skipping verification"
            echo "has_issue=false" >> $GITHUB_OUTPUT
          else
            echo "üîç Found issue #$ISSUE_NUMBER - verifying closure"
            echo "has_issue=true" >> $GITHUB_OUTPUT
            echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          fi

      - name: Verify issue is closed
        if: steps.issue.outputs.has_issue == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.issue.outputs.issue_number }}"

          echo "üîç Checking if issue #$ISSUE_NUMBER is closed..."

          # Get issue state and labels
          ISSUE_DATA=$(gh issue view "$ISSUE_NUMBER" --json state,labels --jq '{state: .state, labels: [.labels[].name]}')
          STATE=$(echo "$ISSUE_DATA" | jq -r '.state')
          LABELS=$(echo "$ISSUE_DATA" | jq -r '.labels | join(", ")')

          echo "  Current state: $STATE"
          echo "  Current labels: $LABELS"

          # Check if issue is properly closed
          if [ "$STATE" = "CLOSED" ]; then
            # Verify labels are correct
            HAS_COMPLETED=$(echo "$LABELS" | grep -c "tdd-spec:completed" || echo "0")
            HAS_IN_PROGRESS=$(echo "$LABELS" | grep -c "tdd-spec:in-progress" || echo "0")

            if [ "$HAS_COMPLETED" -eq 1 ] && [ "$HAS_IN_PROGRESS" -eq 0 ]; then
              echo "‚úÖ Issue #$ISSUE_NUMBER is properly closed with correct labels"
            else
              echo "‚ö†Ô∏è Issue #$ISSUE_NUMBER is closed but has incorrect labels - fixing..."
              gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed" || true
              gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true
              echo "‚úÖ Fixed labels on issue #$ISSUE_NUMBER"
            fi
          else
            echo "‚ùå CRITICAL: Issue #$ISSUE_NUMBER failed to close - forcing closure"
            echo ""
            echo "This is the safeguard that prevents queue blocking when issue closure fails."
            echo "Without this, the queue would be blocked indefinitely (like issue #1317)."
            echo ""

            # Force close the issue with correct labels
            gh issue close "$ISSUE_NUMBER" --reason completed || {
              echo "‚ùå Failed to close issue - retrying with gh api..."
              gh api --method PATCH "/repos/${{ github.repository }}/issues/$ISSUE_NUMBER" \
                -f state='closed' \
                -f state_reason='completed'
            }

            gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed" || true
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true

            # Verify it worked
            NEW_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state')
            if [ "$NEW_STATE" = "CLOSED" ]; then
              echo "‚úÖ Successfully force-closed issue #$ISSUE_NUMBER"
              echo "üîì Queue unblocked - processor can continue with next spec"
            else
              echo "‚ùå FAILED to close issue #$ISSUE_NUMBER - manual intervention required"
              echo "::error::Failed to close issue #$ISSUE_NUMBER after PR merge - queue may be blocked"
              exit 1
            fi
          fi
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}

  delete-tdd-branch:
    name: Delete TDD Branch on PR Close
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == false &&
      (startsWith(github.event.pull_request.head.ref, 'tdd/') ||
       startsWith(github.event.pull_request.head.ref, 'claude/'))
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Delete branch
        run: |
          BRANCH="${{ github.event.pull_request.head.ref }}"
          echo "üóëÔ∏è  Deleting unmerged branch: $BRANCH"

          gh api \
            --method DELETE \
            /repos/${{ github.repository }}/git/refs/heads/$BRANCH \
            && echo "‚úÖ Branch deleted successfully" \
            || echo "‚ö†Ô∏è  Branch may already be deleted"
        env:
          GH_TOKEN: ${{ github.token }}
