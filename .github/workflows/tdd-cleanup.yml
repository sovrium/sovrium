name: TDD Cleanup

on:
  # Run every 6 hours to clean up stale locks
  schedule:
    - cron: '0 */6 * * *'

  # Manual trigger
  workflow_dispatch:
    inputs:
      force:
        description: 'Force cleanup even if locks are recent'
        required: false
        type: boolean
        default: false

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.6

      - name: Install dependencies
        run: bun install

      - name: Fetch state from tdd-state branch
        id: fetch_state
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üìñ Fetching state from tdd-state branch..."

          STATE_BRANCH="tdd-state"
          STATE_URL="https://api.github.com/repos/${{ github.repository }}/contents/.github/tdd-state.json?ref=${STATE_BRANCH}"

          STATE_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "$STATE_URL")

          HTTP_CODE=$(echo "$STATE_RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$STATE_RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" = "404" ]; then
            echo "‚ùå State file not found on branch '${STATE_BRANCH}'"
            echo "state_found=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Failed to fetch state file (HTTP $HTTP_CODE)"
            echo "$RESPONSE_BODY"
            echo "state_found=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Decode base64 content and save to temp file
          echo "$RESPONSE_BODY" | jq -r '.content' | base64 -d > /tmp/tdd-state.json
          echo "state_found=true" >> "$GITHUB_OUTPUT"
          echo "‚úÖ State file fetched successfully"

      - name: Check for stale locks
        if: steps.fetch_state.outputs.state_found == 'true'
        id: stale
        shell: bash
        run: |
          echo "üîç Checking for stale file locks..."

          STATE_FILE="/tmp/tdd-state.json"

          # Get active files (handle empty array and errors)
          ACTIVE_FILES=$(jq -r '.activeFiles[]?' "$STATE_FILE" 2>/dev/null || echo "")

          if [ -z "$ACTIVE_FILES" ]; then
            echo "‚úÖ No active file locks"
            echo "has_stale=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "üìã Active files:"
          echo "$ACTIVE_FILES"

          # Get queue state to check timestamps
          QUEUE_JSON=$(jq '.queue // {}' "$STATE_FILE" 2>/dev/null || echo "{}")

          # Track stale files
          STALE_FILES=()
          CURRENT_TIME=$(date +%s)
          STALE_THRESHOLD=$((30 * 60)) # 30 minutes in seconds

          # Check each active file
          while IFS= read -r file; do
            # Skip empty lines
            [ -z "$file" ] && continue

            # Find the file in active queue
            STARTED_AT=$(echo "$QUEUE_JSON" | jq -r --arg file "$file" '.active[]? | select(.filePath == $file) | .startedAt // empty' 2>/dev/null || echo "")

            if [ -z "$STARTED_AT" ] || [ "$STARTED_AT" = "null" ]; then
              echo "‚ö†Ô∏è  File locked but not in active queue: $file"
              STALE_FILES+=("$file")
              continue
            fi

            # Calculate age (using GNU date -d for ISO 8601 parsing)
            STARTED_TIMESTAMP=$(date -d "$STARTED_AT" +%s 2>/dev/null || echo "0")
            if [ "$STARTED_TIMESTAMP" = "0" ]; then
              echo "‚ö†Ô∏è  Invalid timestamp for file: $file"
              STALE_FILES+=("$file")
              continue
            fi
            AGE=$((CURRENT_TIME - STARTED_TIMESTAMP))

            echo "  - $file: ${AGE}s old (started: $STARTED_AT)"

            # Check if stale (> 30 minutes)
            if [ "$AGE" -gt "$STALE_THRESHOLD" ] || [ "${{ inputs.force }}" = "true" ]; then
              echo "    üî¥ STALE (threshold: ${STALE_THRESHOLD}s)"
              STALE_FILES+=("$file")
            else
              echo "    ‚úÖ OK"
            fi
          done <<< "$ACTIVE_FILES"

          # Output stale files
          if [ ${#STALE_FILES[@]} -gt 0 ]; then
            echo "has_stale=true" >> "$GITHUB_OUTPUT"
            printf '%s\n' "${STALE_FILES[@]}" > /tmp/stale-files.txt
            echo "üö® Found ${#STALE_FILES[@]} stale lock(s)"
          else
            echo "has_stale=false" >> "$GITHUB_OUTPUT"
            echo "‚úÖ No stale locks found"
          fi

      - name: Remove stale locks
        if: steps.stale.outputs.has_stale == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          echo "üßπ Removing stale locks..."

          STATE_FILE="/tmp/tdd-state.json"

          # Read stale files
          while IFS= read -r file; do
            echo "  - Unlocking: $file"

            # Use unlock-file service
            bun run scripts/tdd-automation/core/unlock-file.ts --file "$file" || true

            # Check if there's an active PR for this file
            PR_NUMBER=$(jq -r --arg file "$file" '.queue.active[] | select(.filePath == $file) | .prNumber' "$STATE_FILE" 2>/dev/null || echo "")
            BRANCH_NAME=$(jq -r --arg file "$file" '.queue.active[] | select(.filePath == $file) | .branch' "$STATE_FILE" 2>/dev/null || echo "")

            if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ] && [ "$PR_NUMBER" != "" ]; then
              echo "    - Found PR #$PR_NUMBER"

              # Check PR state
              PR_STATE=$(gh pr view "$PR_NUMBER" --json state -q .state 2>/dev/null || echo "UNKNOWN")

              if [ "$PR_STATE" = "OPEN" ]; then
                # Check for failed checks
                CHECKS=$(gh pr view "$PR_NUMBER" --json statusCheckRollup -q '.statusCheckRollup[] | select(.conclusion == "FAILURE" or .conclusion == "CANCELLED") | .name' 2>/dev/null | wc -l || echo "0")

                if [ "$CHECKS" -gt 0 ]; then
                  echo "    - Closing PR (failed checks detected)"

                  gh pr close "$PR_NUMBER" --comment "Cleanup: PR locked for 30+ minutes with failed checks. File lock released for retry. Closed by TDD Cleanup Workflow." --delete-branch 2>/dev/null || {
                    echo "    - Failed to close PR, attempting to delete branch directly..."
                    if [ -n "$BRANCH_NAME" ] && [ "$BRANCH_NAME" != "null" ]; then
                      gh api -X DELETE "repos/${{ github.repository }}/git/refs/heads/${BRANCH_NAME}" 2>/dev/null || true
                    fi
                  }
                else
                  # No failed checks, just add a comment
                  gh pr comment "$PR_NUMBER" --body "Cleanup Notice: PR locked for 30+ minutes. File lock released. Check workflow logs if still processing." 2>/dev/null || true
                fi
              else
                echo "    - PR is not open (state: ${PR_STATE})"
                # Still try to delete the branch if it exists
                if [ -n "$BRANCH_NAME" ] && [ "$BRANCH_NAME" != "null" ]; then
                  gh api -X DELETE "repos/${{ github.repository }}/git/refs/heads/${BRANCH_NAME}" 2>/dev/null || true
                fi
              fi
            fi
          done < /tmp/stale-files.txt

          echo "‚úÖ Stale locks removed"

      - name: Check for abandoned specs
        if: steps.fetch_state.outputs.state_found == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          echo "üîç Checking for abandoned specs in active queue..."

          STATE_FILE="/tmp/tdd-state.json"

          # Get specs in active queue without PR numbers
          ABANDONED=$(jq -r '.queue.active[] | select(.prNumber == null or .prNumber == 0) | .specId' "$STATE_FILE" 2>/dev/null || echo "")

          if [ -z "$ABANDONED" ]; then
            echo "‚úÖ No abandoned specs"
            exit 0
          fi

          echo "‚ö†Ô∏è  Found abandoned specs (active but no PR):"
          echo "$ABANDONED"

          # Use unlock-spec to release the locks - this also moves them back to pending
          while IFS= read -r spec_id; do
            [ -z "$spec_id" ] && continue
            echo "  - Unlocking abandoned spec: $spec_id"
            bun run scripts/tdd-automation/core/unlock-spec.ts --spec-id "$spec_id" || true
          done <<< "$ABANDONED"

          echo "‚úÖ Abandoned specs cleaned up"

      - name: Report cleanup summary
        if: always()
        shell: bash
        run: |
          echo "üìä Cleanup Summary"
          echo "=================="

          STATE_FILE="/tmp/tdd-state.json"

          # Check if state file was fetched
          if [ ! -f "$STATE_FILE" ]; then
            echo "‚ÑπÔ∏è  State file not available - cannot generate summary"
            exit 0
          fi

          # Active files count
          ACTIVE_COUNT=$(jq '.activeFiles | length' "$STATE_FILE" 2>/dev/null || echo "0")
          echo "Active files: $ACTIVE_COUNT"

          # Active specs count
          ACTIVE_SPECS=$(jq '.activeSpecs | length' "$STATE_FILE" 2>/dev/null || echo "0")
          echo "Active specs: $ACTIVE_SPECS"

          # Queue stats
          PENDING=$(jq '.queue.pending | length' "$STATE_FILE" 2>/dev/null || echo "0")
          ACTIVE=$(jq '.queue.active | length' "$STATE_FILE" 2>/dev/null || echo "0")
          COMPLETED=$(jq '.queue.completed | length' "$STATE_FILE" 2>/dev/null || echo "0")
          FAILED=$(jq '.queue.failed | length' "$STATE_FILE" 2>/dev/null || echo "0")

          echo "Queue status:"
          echo "  - Pending: $PENDING"
          echo "  - Active: $ACTIVE"
          echo "  - Completed: $COMPLETED"
          echo "  - Failed: $FAILED"

          # Manual intervention count
          MANUAL_COUNT=$(jq '.metrics.manualInterventionCount // 0' "$STATE_FILE" 2>/dev/null || echo "0")
          echo "Manual interventions: $MANUAL_COUNT"

          # Last updated
          LAST_UPDATED=$(jq -r '.lastUpdated // "unknown"' "$STATE_FILE" 2>/dev/null || echo "unknown")
          echo "Last updated: $LAST_UPDATED"