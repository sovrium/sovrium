name: TDD Worker

on:
  # PRIMARY TRIGGER: PR creation enables track_progress for real-time updates
  # The orchestrator creates PRs with the "tdd-automation" label, which triggers this workflow
  pull_request:
    types: [opened]
    branches: [main]

  # FALLBACK: Manual trigger for debugging/retries (track_progress will be disabled)
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to process'
        required: true
        type: number
      force:
        description: 'Force processing even if PR is not labeled'
        required: false
        type: boolean
        default: false

# Prevent multiple workers from processing the same PR
concurrency:
  group: tdd-worker-${{ github.event.pull_request.number || inputs.pr_number }}
  cancel-in-progress: false

jobs:
  process-spec:
    # Only run if PR has the tdd-automation label (or forced via workflow_dispatch)
    if: |
      (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'tdd-automation')) ||
      (github.event_name == 'workflow_dispatch' && inputs.force)
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Determine PR context
        id: context
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          else
            PR_NUMBER="${{ inputs.pr_number }}"
            BRANCH_NAME=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json headRefName -q .headRefName)
          fi

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

          # Determine if track_progress should be enabled
          # Only works with pull_request events, not workflow_dispatch
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "track_progress=true" >> $GITHUB_OUTPUT
          else
            echo "track_progress=false" >> $GITHUB_OUTPUT
          fi

          echo "PR: #$PR_NUMBER"
          echo "Branch: $BRANCH_NAME"
          echo "Track Progress: ${{ github.event_name == 'pull_request' }}"

      - name: Extract spec details from PR
        id: spec
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ steps.context.outputs.pr_number }}"

          # Get PR body which contains spec details
          PR_DATA=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json body,title,labels)
          PR_BODY=$(echo "$PR_DATA" | jq -r '.body')
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')

          # Extract spec details from PR body metadata section
          # Format: <!-- TDD_METADATA: {"specId":"...", "filePath":"...", ...} -->
          # Use sed for better portability (grep -P not reliable across platforms)
          METADATA=$(echo "$PR_BODY" | sed -n 's/.*<!-- TDD_METADATA: \(.*\) -->.*/\1/p' | head -1)

          # Handle empty result
          if [ -z "$METADATA" ]; then
            METADATA="{}"
          fi

          if [ "$METADATA" = "{}" ] || [ -z "$METADATA" ]; then
            echo "::error::No TDD metadata found in PR body"
            exit 1
          fi

          # Parse metadata
          SPEC_ID=$(echo "$METADATA" | jq -r '.specId')
          FILE_PATH=$(echo "$METADATA" | jq -r '.filePath')
          TEST_NAME=$(echo "$METADATA" | jq -r '.testName')
          PRIORITY=$(echo "$METADATA" | jq -r '.priority')
          RETRY_COUNT=$(echo "$METADATA" | jq -r '.retryCount // 0')
          PREVIOUS_ERRORS=$(echo "$METADATA" | jq -c '.previousErrors // []')

          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT
          echo "file_path=$FILE_PATH" >> $GITHUB_OUTPUT
          echo "test_name=$TEST_NAME" >> $GITHUB_OUTPUT
          echo "priority=$PRIORITY" >> $GITHUB_OUTPUT
          echo "retry_count=$RETRY_COUNT" >> $GITHUB_OUTPUT
          echo "previous_errors=$PREVIOUS_ERRORS" >> $GITHUB_OUTPUT

          echo "Spec ID: $SPEC_ID"
          echo "File: $FILE_PATH"
          echo "Test: $TEST_NAME"
          echo "Retry: $RETRY_COUNT/3"

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.context.outputs.branch }}
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.6

      - name: Install dependencies
        run: bun install

      - name: Configure git identity
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Verify locks acquired by orchestrator
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "Verifying file/spec locks (acquired by orchestrator)..."

          # Fetch state from tdd-state branch
          STATE_JSON=$(gh api repos/${{ github.repository }}/contents/.github/tdd-state.json?ref=tdd-state \
            --jq '.content' | base64 -d 2>/dev/null || echo '{"activeFiles":[],"activeSpecs":[]}')

          # Verify file is locked
          FILE_LOCKED=$(echo "$STATE_JSON" | jq --arg file "${{ steps.spec.outputs.file_path }}" '.activeFiles | index($file) != null')
          if [ "$FILE_LOCKED" != "true" ]; then
            echo "Warning: File ${{ steps.spec.outputs.file_path }} is not locked."
          else
            echo "File lock verified: ${{ steps.spec.outputs.file_path }}"
          fi

          # Verify spec is locked
          SPEC_LOCKED=$(echo "$STATE_JSON" | jq --arg spec "${{ steps.spec.outputs.spec_id }}" '.activeSpecs | index($spec) != null')
          if [ "$SPEC_LOCKED" != "true" ]; then
            echo "Warning: Spec ${{ steps.spec.outputs.spec_id }} is not locked."
          else
            echo "Spec lock verified: ${{ steps.spec.outputs.spec_id }}"
          fi

      - name: Pre-validate spec (remove .fixme and test)
        id: precheck
        continue-on-error: true
        run: |
          echo "Pre-validating spec: removing .fixme() and running test..."

          # Store original file content for restoration if needed
          cp "${{ steps.spec.outputs.file_path }}" /tmp/original-spec-file.ts

          # Run pre-validate script which:
          # 1. Removes .fixme() from the specific test
          # 2. Runs the test with Playwright
          # 3. Outputs results to JSON file
          bun run scripts/tdd-automation/core/pre-validate.ts \
            --file "${{ steps.spec.outputs.file_path }}" \
            --spec-id "${{ steps.spec.outputs.spec_id }}" \
            --test-name "${{ steps.spec.outputs.test_name }}" \
            --output /tmp/precheck-result.json

          # Read the results
          if [ -f /tmp/precheck-result.json ]; then
            PASSED=$(cat /tmp/precheck-result.json | jq -r '.passed // 0')
            FAILED=$(cat /tmp/precheck-result.json | jq -r '.failed // 0')

            echo "Pre-validation result: passed=$PASSED, failed=$FAILED"

            if [ "$PASSED" -gt 0 ] && [ "$FAILED" -eq 0 ]; then
              echo "fast_path=true" >> $GITHUB_OUTPUT
              echo "Tests pass without Claude - fast path eligible"
            else
              echo "fast_path=false" >> $GITHUB_OUTPUT
              echo "Tests fail - Claude implementation needed"
              # Restore original file (with .fixme()) for Claude to work with
              cp /tmp/original-spec-file.ts "${{ steps.spec.outputs.file_path }}"
            fi
          else
            echo "fast_path=false" >> $GITHUB_OUTPUT
            echo "Pre-validation failed to produce results"
            # Restore original file
            cp /tmp/original-spec-file.ts "${{ steps.spec.outputs.file_path }}"
          fi

      - name: Fast path - Commit and merge
        if: steps.precheck.outputs.fast_path == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "Tests pass without Claude implementation! Fast path activated."

          # Add fast-path label
          gh api repos/${{ github.repository }}/issues/${{ steps.context.outputs.pr_number }}/labels \
            -f "labels[]=tdd:fast-path" || echo "Failed to add label, continuing..."

          # Commit the .fixme() removal
          git add "${{ steps.spec.outputs.file_path }}"
          if ! git diff --staged --quiet; then
            SPEC_ID="${{ steps.spec.outputs.spec_id }}"
            git commit -m "test: enable ${SPEC_ID} (fast-path)" -m "Test passes without implementation - .fixme() removal only" -m "Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
            git push origin ${{ steps.context.outputs.branch }}
            echo "Committed .fixme() removal to PR #${{ steps.context.outputs.pr_number }}"
          else
            echo "No changes to commit (test was already enabled)"
          fi

          # Wait briefly for CI to start on the new commit
          echo "Waiting for CI to pick up the commit..."
          sleep 10

          # Auto-merge (CI will validate the commit)
          bun run scripts/tdd-automation/services/pr-manager.ts merge \
            --pr ${{ steps.context.outputs.pr_number }}

          # Unlock file and spec
          bun run scripts/tdd-automation/core/unlock-file.ts \
            --file "${{ steps.spec.outputs.file_path }}" || true
          bun run scripts/tdd-automation/core/unlock-spec.ts \
            --spec-id "${{ steps.spec.outputs.spec_id }}" || true

      - name: Run Claude Code (e2e-test-fixer)
        if: steps.precheck.outputs.fast_path == 'false'
        id: claude_fixer
        uses: anthropics/claude-code-action@v1
        timeout-minutes: 60
        continue-on-error: true
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GH_PAT_WORKFLOW }}
          allowed_bots: '*'
          additional_permissions: |
            actions: read
          # track_progress enabled for pull_request events - shows real-time progress in PR
          track_progress: ${{ steps.context.outputs.track_progress }}
          prompt: |
            You are working on the TDD Workflow automation. Your task is to implement code to make a failing E2E test pass.

            **Spec ID**: ${{ steps.spec.outputs.spec_id }}
            **Test Name**: ${{ steps.spec.outputs.test_name }}
            **Spec File**: ${{ steps.spec.outputs.file_path }}
            **Retry Count**: ${{ steps.spec.outputs.retry_count }}/3 (0 = first attempt)
            ${{ steps.spec.outputs.retry_count != '0' && format('**Previous Errors**: {0}', steps.spec.outputs.previous_errors) || '' }}

            **Instructions**:
            1. Use the e2e-test-fixer agent to implement the code needed to pass this specific test
            2. First, remove the .fixme() from the test in ${{ steps.spec.outputs.file_path }}
               - Find `test.fixme('${{ steps.spec.outputs.test_name }}'` and change it to `test('${{ steps.spec.outputs.test_name }}'`
            3. Implement minimal code to make this test pass (follow TDD best practices)
            4. Run bun test:e2e:regression to verify your implementation
            5. Do NOT run quality checks or add license headers (automated in next steps)

            **Critical Requirements**:
            - Use Effect.ts for business logic in application layer
            - Follow Sovrium layer-based architecture patterns
            - Keep implementation minimal (just enough to pass this specific test)
            - Focus only on ${{ steps.spec.outputs.spec_id }} - do not modify other tests

            **Important Notes**:
            - If src/ files are modified, the codebase-refactor-auditor will run next
            - Quality checks and license headers are added automatically
            - Focus only on making this specific test pass with minimal implementation
          claude_args: >-
            --model claude-sonnet-4-5-20250929
            --max-budget-usd 50.00
            --allowedTools Edit,Read,Write,Bash,Glob,Grep,Task,TodoWrite,Skill,LSP
            --disallowedTools WebFetch,WebSearch,AskUserQuestion,NotebookEdit,SlashCommand

      - name: Check if src/ modified
        if: steps.precheck.outputs.fast_path == 'false'
        id: src_check
        run: |
          if git diff --name-only | grep '^src/'; then
            echo "modified=true" >> $GITHUB_OUTPUT
          else
            echo "modified=false" >> $GITHUB_OUTPUT
          fi

      - name: Run Claude Code (codebase-refactor-auditor)
        if: steps.precheck.outputs.fast_path == 'false' && steps.src_check.outputs.modified == 'true'
        id: claude_refactor
        uses: anthropics/claude-code-action@v1
        timeout-minutes: 30
        continue-on-error: true
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GH_PAT_WORKFLOW }}
          allowed_bots: '*'
          additional_permissions: |
            actions: read
          # track_progress enabled for pull_request events - shows real-time progress in PR
          track_progress: ${{ steps.context.outputs.track_progress }}
          prompt: |
            You are working on the TDD Workflow automation. The e2e-test-fixer agent has implemented code to pass E2E test ${{ steps.spec.outputs.spec_id }} in ${{ steps.spec.outputs.file_path }}.

            **Your Task**: Audit the implementation and refactor for code quality while maintaining test behavior.

            **Instructions**:
            1. Use the codebase-refactor-auditor agent to review recent changes in src/
            2. Eliminate code duplication using DRY principles
            3. Ensure proper layer-based architecture (domain, application, infrastructure, presentation)
            4. Verify Effect.ts patterns are followed correctly
            5. Optimize for readability and maintainability

            **Critical Requirements**:
            - Do NOT change test behavior (all tests must still pass after refactoring)
            - Focus on code quality improvements only
            - Maintain functional programming patterns
            - Keep changes minimal and focused
            - Ensure bun run quality --skip-e2e passes after your changes

            **Important Notes**:
            - Tests are already passing - your job is to improve code quality
            - Quality checks and license headers will be added automatically next
            - Run bun test:e2e:regression to verify tests still pass after refactoring
          claude_args: >-
            --model claude-sonnet-4-5-20250929
            --max-budget-usd 25.00
            --allowedTools Edit,Read,Write,Bash,Glob,Grep,Task,TodoWrite,Skill,LSP
            --disallowedTools WebFetch,WebSearch,AskUserQuestion,NotebookEdit,SlashCommand

      - name: Format and lint code
        if: steps.precheck.outputs.fast_path == 'false'
        run: |
          echo "Formatting code before quality checks..."
          bun run format || true
          echo "Running lint fix..."
          bun run lint:fix || true
          echo "Pre-commit formatting complete"

      - name: Run quality checks
        if: steps.precheck.outputs.fast_path == 'false'
        id: quality
        run: |
          echo "Running quality checks..."
          bun run quality --skip-e2e --skip-format

      - name: Add license headers
        if: steps.precheck.outputs.fast_path == 'false'
        run: |
          echo "Adding license headers..."
          bun run license

      - name: Commit and push changes
        if: steps.precheck.outputs.fast_path == 'false'
        run: |
          echo "Committing Claude's implementation..."

          git add .

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            SPEC_ID="${{ steps.spec.outputs.spec_id }}"
            git commit -m "feat: implement ${SPEC_ID}" -m "Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
            git push origin ${{ steps.context.outputs.branch }}
            echo "Changes pushed to PR #${{ steps.context.outputs.pr_number }}"
          fi

      - name: Wait for CI checks
        if: steps.precheck.outputs.fast_path == 'false'
        id: ci
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "Waiting for CI checks..."

          RESULT=$(bun run scripts/tdd-automation/services/ci-waiter.ts \
            --pr ${{ steps.context.outputs.pr_number }} \
            --timeout 600)

          echo "result=$RESULT" >> $GITHUB_OUTPUT

      - name: Auto-merge on success
        if: steps.precheck.outputs.fast_path == 'false' && steps.ci.outputs.result == 'success'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "CI passed! Auto-merging PR..."

          bun run scripts/tdd-automation/services/pr-manager.ts merge \
            --pr ${{ steps.context.outputs.pr_number }}

      - name: Analyze failure
        if: steps.precheck.outputs.fast_path == 'false' && steps.ci.outputs.result == 'failure'
        id: analyze
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "CI failed. Analyzing failure type..."

          FAILURE_TYPE=$(bun run scripts/tdd-automation/services/failure-analyzer.ts \
            --pr ${{ steps.context.outputs.pr_number }})

          echo "type=$FAILURE_TYPE" >> $GITHUB_OUTPUT

      # ============================================================
      # SMART RETRY STRATEGY - Different handling based on failure type
      # ============================================================

      - name: Handle regression failure (3 retries then park)
        if: steps.precheck.outputs.fast_path == 'false' && steps.analyze.outputs.type == 'regression'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          RETRY_COUNT="${{ steps.spec.outputs.retry_count }}"
          NEXT_ATTEMPT=$((RETRY_COUNT + 1))

          echo "Regression detected (attempt ${NEXT_ATTEMPT}/3)"

          if [ "$NEXT_ATTEMPT" -ge 3 ]; then
            echo "Max retries exhausted - parking for manual intervention"
          else
            echo "Will retry (${NEXT_ATTEMPT}/3 attempts used)"
          fi

          bun run scripts/tdd-automation/services/failure-handler.ts \
            --spec-id "${{ steps.spec.outputs.spec_id }}" \
            --pr ${{ steps.context.outputs.pr_number }} \
            --type regression \
            --retry-count "${{ steps.spec.outputs.retry_count }}" \
            --branch "${{ steps.context.outputs.branch }}"

      - name: Handle spec failure (3 retries then park)
        if: steps.precheck.outputs.fast_path == 'false' && steps.analyze.outputs.type == 'spec-failure'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          RETRY_COUNT="${{ steps.spec.outputs.retry_count }}"
          NEXT_ATTEMPT=$((RETRY_COUNT + 1))

          echo "Spec failure detected (attempt ${NEXT_ATTEMPT}/3)"

          if [ "$NEXT_ATTEMPT" -ge 3 ]; then
            echo "Max retries exhausted - parking for manual intervention"
          else
            echo "Will retry (${NEXT_ATTEMPT}/3 attempts used)"
          fi

          bun run scripts/tdd-automation/services/failure-handler.ts \
            --spec-id "${{ steps.spec.outputs.spec_id }}" \
            --pr ${{ steps.context.outputs.pr_number }} \
            --type spec-failure \
            --retry-count "${{ steps.spec.outputs.retry_count }}" \
            --branch "${{ steps.context.outputs.branch }}"

      - name: Handle infrastructure failure (immediate cleanup, no retry penalty)
        if: steps.precheck.outputs.fast_path == 'false' && steps.analyze.outputs.type == 'infrastructure'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "Infrastructure failure detected (NOT a code issue)"
          echo "Immediate cleanup: PR will be closed, branch deleted"
          echo "Retry counter will NOT be incremented"

          bun run scripts/tdd-automation/services/failure-handler.ts \
            --spec-id "${{ steps.spec.outputs.spec_id }}" \
            --pr ${{ steps.context.outputs.pr_number }} \
            --type infrastructure \
            --retry-count "${{ steps.spec.outputs.retry_count }}" \
            --branch "${{ steps.context.outputs.branch }}"

          echo "Spec re-queued for retry (no penalty applied)"

      - name: Cleanup - Close PR and delete branch on failure
        if: failure() && steps.context.outputs.pr_number
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "Cleaning up failed worker resources..."

          PR_NUMBER="${{ steps.context.outputs.pr_number }}"
          BRANCH_NAME="${{ steps.context.outputs.branch }}"
          SPEC_ID="${{ steps.spec.outputs.spec_id }}"
          RETRY_COUNT="${{ steps.spec.outputs.retry_count }}"
          NEXT_ATTEMPT=$((RETRY_COUNT + 1))

          if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
            PR_STATE=$(gh pr view "$PR_NUMBER" --json state -q .state 2>/dev/null || echo "UNKNOWN")

            if [ "$PR_STATE" = "OPEN" ]; then
              HAS_MANUAL_LABEL=$(gh pr view "$PR_NUMBER" --json labels -q '.labels[].name' 2>/dev/null | grep -c "tdd-spec:manual-intervention" || echo "0")

              if [ "$HAS_MANUAL_LABEL" -gt "0" ]; then
                echo "PR #${PR_NUMBER} has manual-intervention label - keeping open for review"
              else
                echo "Closing PR #${PR_NUMBER} due to worker failure..."
                gh pr close "$PR_NUMBER" --comment "Worker failure - PR closed automatically. Spec ID ${SPEC_ID} will be retried." --delete-branch 2>/dev/null || {
                  gh api -X DELETE "repos/${{ github.repository }}/git/refs/heads/${BRANCH_NAME}" 2>/dev/null || true
                }
              fi
            fi
          fi

      - name: Cleanup - Record failure and update state
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "Recording failure in state..."

          SPEC_ID="${{ steps.spec.outputs.spec_id }}"
          RETRY_COUNT="${{ steps.spec.outputs.retry_count }}"
          BRANCH_NAME="${{ steps.context.outputs.branch }}"

          # Determine failure type based on step outcomes
          FAILURE_TYPE="infrastructure"
          CLAUDE_FIXER_OUTCOME="${{ steps.claude_fixer.outcome }}"
          CLAUDE_REFACTOR_OUTCOME="${{ steps.claude_refactor.outcome }}"
          QUALITY_OUTCOME="${{ steps.quality.outcome }}"

          if [ "$QUALITY_OUTCOME" = "failure" ]; then
            FAILURE_TYPE="quality-failure"
          elif [ "$CLAUDE_FIXER_OUTCOME" = "failure" ]; then
            FAILURE_TYPE="spec-failure"
          elif [ "$CLAUDE_REFACTOR_OUTCOME" = "failure" ]; then
            FAILURE_TYPE="spec-failure"
          fi

          echo "Failure type: $FAILURE_TYPE"

          if [ -f scripts/tdd-automation/services/failure-handler.ts ] && [ -n "${{ steps.context.outputs.pr_number }}" ]; then
            bun run scripts/tdd-automation/services/failure-handler.ts \
              --spec-id "$SPEC_ID" \
              --pr "${{ steps.context.outputs.pr_number }}" \
              --type "$FAILURE_TYPE" \
              --retry-count "$RETRY_COUNT" \
              --branch "$BRANCH_NAME" 2>/dev/null || true
          fi

      - name: Cleanup - Release locks
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          GITHUB_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "Releasing spec and file locks..."

          # Only release locks if we have spec info (may not have parsed if early failure)
          if [ -n "${{ steps.spec.outputs.spec_id }}" ]; then
            bun run scripts/tdd-automation/core/unlock-spec.ts \
              --spec-id "${{ steps.spec.outputs.spec_id }}" || true

            bun run scripts/tdd-automation/core/unlock-file.ts \
              --file "${{ steps.spec.outputs.file_path }}" || true
          fi

          echo "Lock cleanup complete"
