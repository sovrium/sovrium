name: TDD - Monitor (Health & Recovery)

# Monitoring workflow that consolidates:
# - Circuit breaker (health monitoring)
# - Stuck spec recovery (timeout detection)
# - PR monitoring (auto-merge, stuck PRs)
# - Conflict resolution (merge conflicts)
# - Retry monitoring (stuck retries)
# - Failed PR recovery (regression fix retry)
# - Branch cleanup (weekly stale branch removal)

on:
  # Event-driven triggers (immediate response)
  workflow_run:
    workflows: ['TDD - Execute (Claude Code)']
    types: [completed]
  push:
    branches:
      - main

  # Scheduled backup (every 30 min)
  schedule:
    - cron: '*/30 * * * *'

  # Manual trigger
  workflow_dispatch:
    inputs:
      force_recovery:
        description: 'Force recovery of all stuck specs'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

# Only one monitor run at a time - cancel queued runs to prevent pile-up
concurrency:
  group: tdd-monitor
  cancel-in-progress: true

env:
  STUCK_TIMEOUT_MINUTES: 105 # Specs stuck >105 min are recovered (15 min buffer above Claude timeout)
  PR_STUCK_TIMEOUT_MINUTES: 120 # PRs stuck >120 min are force-closed
  RETRY_STUCK_TIMEOUT_MINUTES: 30 # Retries stuck >30 min are recovered
  FAILED_PR_COOLDOWN_MINUTES: 30 # Wait 30 min between regression fix attempts

jobs:
  # Job 1: Health Check & Circuit Breaker
  # Monitors overall pipeline health and disables queue on high failure rate
  health-check:
    name: üè• Health Check & Circuit Breaker
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      failure_rate: ${{ steps.analyze.outputs.failure_rate }}
      should_open_circuit: ${{ steps.analyze.outputs.should_open_circuit }}
      is_circuit_open: ${{ steps.circuit_status.outputs.is_open }}

    steps:
      - name: Analyze pipeline health
        id: analyze
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üìä Analyzing TDD pipeline health..."

          # Get last 10 workflow runs from tdd-execute.yml
          RECENT_RUNS=$(gh run list \
            --repo ${{ github.repository }} \
            --workflow="tdd-execute.yml" \
            --limit 10 \
            --json conclusion,createdAt,displayTitle)

          TOTAL=$(echo "$RECENT_RUNS" | jq 'length')
          FAILURES=$(echo "$RECENT_RUNS" | jq '[.[] | select(.conclusion == "failure" or .conclusion == "cancelled")] | length')

          # Count specs in retry state (both infrastructure and code retries)
          # Uses standardized label format: retry:infra:N and retry:spec:N
          INFRA_RETRY_1=$(gh issue list --repo ${{ github.repository }} --label "retry:infra:1" --json number --jq 'length')
          INFRA_RETRY_2=$(gh issue list --repo ${{ github.repository }} --label "retry:infra:2" --json number --jq 'length')
          INFRA_RETRY_3=$(gh issue list --repo ${{ github.repository }} --label "retry:infra:3" --json number --jq 'length')
          CODE_RETRY_1=$(gh issue list --repo ${{ github.repository }} --label "retry:spec:1" --json number --jq 'length')
          CODE_RETRY_2=$(gh issue list --repo ${{ github.repository }} --label "retry:spec:2" --json number --jq 'length')
          CODE_RETRY_3=$(gh issue list --repo ${{ github.repository }} --label "retry:spec:3" --json number --jq 'length')
          INFRA_RETRY_ISSUES=$((INFRA_RETRY_1 + INFRA_RETRY_2 + INFRA_RETRY_3))
          CODE_RETRY_ISSUES=$((CODE_RETRY_1 + CODE_RETRY_2 + CODE_RETRY_3))
          RETRY_ISSUES=$((INFRA_RETRY_ISSUES + CODE_RETRY_ISSUES))

          # Calculate failure rate
          if [ "$TOTAL" -eq 0 ]; then
            FAILURE_RATE=0
          else
            FAILURE_RATE=$((FAILURES * 100 / TOTAL))
          fi

          echo "üìà Health metrics:"
          echo "   Recent runs: $TOTAL"
          echo "   Failures: $FAILURES"
          echo "   Failure rate: ${FAILURE_RATE}%"
          echo "   Issues in retry: $RETRY_ISSUES (infra: $INFRA_RETRY_ISSUES, code: $CODE_RETRY_ISSUES)"

          # Output results
          echo "failure_rate=$FAILURE_RATE" >> $GITHUB_OUTPUT
          echo "failures=$FAILURES" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "retry_issues=$RETRY_ISSUES" >> $GITHUB_OUTPUT

          # Determine if circuit should open
          # Open if: >50% failure rate OR >20% of queue in retry state (min 5)
          QUEUE_SIZE=$(gh issue list --repo ${{ github.repository }} --label "tdd-spec:queued" --json number --jq 'length' 2>/dev/null || echo "0")
          # Dynamic threshold: 20% of queue size, minimum 5
          RETRY_THRESHOLD=$((QUEUE_SIZE / 5))
          if [ "$RETRY_THRESHOLD" -lt 5 ]; then RETRY_THRESHOLD=5; fi

          echo "   Queue size: $QUEUE_SIZE"
          echo "   Retry threshold: $RETRY_THRESHOLD (20% of queue, min 5)"

          if [ "$TOTAL" -ge 5 ] && [ "$FAILURE_RATE" -gt 50 ]; then
            echo "should_open_circuit=true" >> $GITHUB_OUTPUT
            echo "üö® THRESHOLD EXCEEDED: ${FAILURE_RATE}% failure rate"
          elif [ "$RETRY_ISSUES" -gt "$RETRY_THRESHOLD" ]; then
            echo "should_open_circuit=true" >> $GITHUB_OUTPUT
            echo "üö® THRESHOLD EXCEEDED: $RETRY_ISSUES issues in retry (threshold: $RETRY_THRESHOLD)"
          else
            echo "should_open_circuit=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Health is acceptable"
          fi

      - name: Check circuit breaker status
        id: circuit_status
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Check if queue processor is disabled
          STATUS=$(gh workflow list \
            --repo ${{ github.repository }} \
            --all \
            --json name,state \
            --jq '.[] | select(.name == "TDD Queue - Processor") | .state')

          if [ "$STATUS" = "disabled_manually" ]; then
            echo "is_open=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Circuit breaker is OPEN (queue disabled)"
          else
            echo "is_open=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Circuit breaker is CLOSED (queue active)"
          fi

      - name: Open circuit breaker
        if: steps.analyze.outputs.should_open_circuit == 'true' && steps.circuit_status.outputs.is_open != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üö® Opening circuit breaker - disabling queue..."

          gh workflow disable "tdd-dispatch.yml" --repo ${{ github.repository }}

          # Create incident issue (ignore label errors if labels don't exist)
          gh issue create \
            --repo ${{ github.repository }} \
            --title "üö® TDD Circuit Breaker: High Failure Rate" \
            --body "## üö® Circuit Breaker Activated

          **Failure Rate**: ${{ steps.analyze.outputs.failure_rate }}%
          **Recent Runs**: ${{ steps.analyze.outputs.failures }}/${{ steps.analyze.outputs.total }} failed
          **Issues in Retry**: ${{ steps.analyze.outputs.retry_issues }}
          **Action**: Queue processor disabled

          ### Investigation
          1. Check recent runs: [tdd-execute.yml](https://github.com/${{ github.repository }}/actions/workflows/tdd-execute.yml)
          2. Check retry issues: \`gh issue list --label retry:infra:1\`
          3. Look for error patterns

          ### Recovery
          Once resolved:
          1. Re-enable queue: \`gh workflow enable tdd-dispatch.yml\`
          2. Close this issue

          ---
          *ü§ñ TDD Monitor*" \
            --label "tdd-automation" || true

      - name: Close circuit breaker
        if: steps.analyze.outputs.should_open_circuit == 'false' && steps.circuit_status.outputs.is_open == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "‚úÖ Health recovered - closing circuit breaker..."

          gh workflow enable "tdd-dispatch.yml" --repo ${{ github.repository }}

          # Close incident issues
          gh issue list \
            --repo ${{ github.repository }} \
            --label "incident" \
            --state open \
            --json number,title \
            --jq '.[] | select(.title | contains("TDD Circuit Breaker")) | .number' \
            | while read -r ISSUE; do
              gh issue comment "$ISSUE" --repo ${{ github.repository }} \
                --body "‚úÖ **Circuit Breaker Recovered**

          **Current Failure Rate**: ${{ steps.analyze.outputs.failure_rate }}%
          **Action**: Queue processor re-enabled

          Pipeline operating normally.

          ---
          *ü§ñ TDD Monitor*"

              gh issue close "$ISSUE" --repo ${{ github.repository }}
            done

  # Job 2: Stuck Spec Recovery
  # Finds specs stuck in-progress >90 min and re-queues or fails them
  stuck-spec-recovery:
    name: üîÑ Stuck Spec Recovery
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Find and recover stuck specs
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          TIMEOUT_MINUTES: ${{ env.STUCK_TIMEOUT_MINUTES }}
          FORCE_RECOVERY: ${{ github.event.inputs.force_recovery || 'false' }}
        run: |
          echo "üîç Looking for specs stuck >$TIMEOUT_MINUTES min..."

          ISSUES=$(gh issue list \
            --repo ${{ github.repository }} \
            --label "tdd-spec:in-progress" \
            --json number,title,updatedAt,labels \
            --limit 100)

          NOW=$(date +%s)
          TIMEOUT_SECONDS=$((TIMEOUT_MINUTES * 60))
          STUCK_COUNT=0

          # Use process substitution to avoid subshell variable scope issue
          while read -r issue; do
            [ -z "$issue" ] && continue

            ISSUE_NUMBER=$(echo "$issue" | jq -r '.number')
            TITLE=$(echo "$issue" | jq -r '.title')
            UPDATED_AT=$(echo "$issue" | jq -r '.updatedAt')
            LABELS=$(echo "$issue" | jq -r '.labels[].name' | tr '\n' ' ')

            UPDATED_EPOCH=$(date -d "$UPDATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$UPDATED_AT" +%s 2>/dev/null || echo "0")
            AGE=$((NOW - UPDATED_EPOCH))
            AGE_MIN=$((AGE / 60))

            # Skip if not stuck (or force recovery is enabled)
            if [ "$FORCE_RECOVERY" != "true" ] && [ "$AGE" -le "$TIMEOUT_SECONDS" ]; then
              continue
            fi

            echo ""
            echo "‚è±Ô∏è  STUCK: Issue #$ISSUE_NUMBER (${AGE_MIN} min old)"

            # Check if there's an open PR with failed tests linked to this issue
            # If so, skip re-queuing - let the failed-pr-recovery job handle it
            LINKED_PR=$(gh pr list \
              --repo ${{ github.repository }} \
              --label "tdd-automation" \
              --state open \
              --json number,body,statusCheckRollup \
              --jq ".[] | select(.body | test(\"Closes #$ISSUE_NUMBER(\\\\s|$)\"))" 2>/dev/null | head -1)

            if [ -n "$LINKED_PR" ]; then
              PR_NUM=$(echo "$LINKED_PR" | jq -r '.number')
              # Check if Test check failed
              TEST_FAILED=$(echo "$LINKED_PR" | jq -r '.statusCheckRollup[]? | select(.name == "Test" and .conclusion == "FAILURE") | .name' 2>/dev/null | head -1)

              if [ -n "$TEST_FAILED" ]; then
                echo "   ‚è≠Ô∏è  Skipping - PR #$PR_NUM exists with failed tests (handled by failed-pr-recovery)"
                continue
              fi
            fi

            STUCK_COUNT=$((STUCK_COUNT + 1))

            # Check for retry label (both infrastructure and code retries)
            # Uses standardized label format: retry:infra:N and retry:spec:N
            RETRY_LABEL=$(echo "$LABELS" | grep -oE 'retry:(spec|infra):[0-9]' || echo "")

            if [ -n "$RETRY_LABEL" ]; then
              RETRY_NUM=$(echo "$RETRY_LABEL" | sed -E 's/retry:(spec|infra)://')
              echo "   Stuck retry attempt #$RETRY_NUM (label: $RETRY_LABEL)"

              if [ "$RETRY_NUM" -ge 3 ]; then
                echo "   ‚ùå Max retries reached - marking as failed"
                gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                  --remove-label "tdd-spec:in-progress" \
                  --remove-label "$RETRY_LABEL" \
                  --add-label "tdd-spec:failed"

                gh issue comment "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                  --body "‚ùå **Max Retries Exhausted**

                Stuck in retry #$RETRY_NUM for $AGE_MIN minutes. Manual intervention required.

                ---
                *ü§ñ TDD Monitor*"
              else
                NEXT_RETRY=$((RETRY_NUM + 1))
                # Preserve retry type (spec vs infra) when incrementing
                RETRY_TYPE=$(echo "$RETRY_LABEL" | sed -E 's/retry:(spec|infra):.*/\1/')

                # Get spec details from issue for context (needed for Claude running check)
                SPEC_ID=$(gh issue view "$ISSUE_NUMBER" --repo ${{ github.repository }} --json title --jq '.title' | grep -oE '[A-Z]+-[A-Z]+-[0-9]+' || echo "unknown")

                # Check if Claude Code is actively processing this spec
                # This prevents posting @claude retry while original Claude is still running
                if [ "$SPEC_ID" != "unknown" ]; then
                  CLAUDE_RUNNING=$(gh run list \
                    --repo ${{ github.repository }} \
                    --workflow "TDD - Execute (Claude Code)" \
                    --json status,displayTitle \
                    --jq "[.[] | select(.status == \"in_progress\" or .status == \"queued\") | select(.displayTitle | contains(\"$SPEC_ID\"))] | length" 2>/dev/null || echo "0")

                  if [ "$CLAUDE_RUNNING" -gt 0 ]; then
                    echo "   ‚è≠Ô∏è  Skipping retry - Claude Code is actively processing spec $SPEC_ID"
                    continue
                  fi
                fi

                echo "   üîÑ Triggering retry #$NEXT_RETRY (type: $RETRY_TYPE)"

                gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                  --remove-label "$RETRY_LABEL" \
                  --add-label "retry:${RETRY_TYPE}:$NEXT_RETRY"
                TEST_FILE=$(gh issue view "$ISSUE_NUMBER" --repo ${{ github.repository }} --json body --jq '.body' | grep -oE 'Test File[^`]*`[^`]+' | sed 's/.*`//' || echo "unknown")

                gh issue comment "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                  --body "üîÑ **Stuck Retry Recovery** (Attempt $NEXT_RETRY of 3)

                Previous attempt stuck for $AGE_MIN minutes. Restarting implementation.

                @claude retry implementation for this spec

                ## üìã Context
                - **Spec ID**: \`$SPEC_ID\`
                - **Test File**: \`$TEST_FILE\`
                - **Issue**: #$ISSUE_NUMBER
                - **Retry Attempt**: $NEXT_RETRY of 3
                - **Previous Failure**: Infrastructure timeout (not code issue)

                ## ü§ñ Automation Mode
                - ‚úÖ Make autonomous decisions - proceed with best judgment
                - ‚ùå DO NOT ask questions

                ## ‚úÖ Instructions

                1. **Check current state**: Run \`git status\` to see if previous work exists
                2. **If branch has changes**: Continue from where it left off
                3. **If no changes**: Start fresh using e2e-test-fixer agent (\`Task\` tool with \`subagent_type='e2e-test-fixer'\`)
                4. **Run codebase-refactor-auditor**: Use \`Task\` tool with \`subagent_type='codebase-refactor-auditor'\` (MANDATORY)
                5. **Verify quality**: Run \`bun run quality\` - all checks must pass
                6. **Commit**: \`fix: implement $SPEC_ID\`
                7. **Create PR**: \`gh pr create --title \"fix: implement $SPEC_ID\" --body \"Closes #$ISSUE_NUMBER\" --label \"tdd-automation\"\`
                8. **Enable auto-merge**: \`gh pr merge \$PR_NUMBER --auto --squash\`
                9. **Verify auto-merge**: \`gh pr view \$PR_NUMBER --json autoMergeRequest\`

                **Reference**: \`@docs/development/tdd-automation-pipeline.md\`

                ---
                *ü§ñ TDD Monitor*"
              fi
            else
              echo "   üìã Re-queueing stuck spec"
              gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:queued"

              gh issue comment "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                --body "‚è±Ô∏è  **Timeout Recovery**

              Stuck for $AGE_MIN min. Re-queued for retry.

              ---
              *ü§ñ TDD Monitor*"
            fi
          done < <(echo "$ISSUES" | jq -r '.[] | @json')

          if [ "$STUCK_COUNT" -gt 0 ]; then
            echo ""
            echo "‚úÖ Recovered $STUCK_COUNT stuck spec(s)"
          else
            echo "‚úÖ No stuck specs found"
          fi

      # FALLBACK MECHANISM: Create PRs for orphaned branches
      # This handles cases where Claude successfully pushed a branch but verify-success was skipped
      # (e.g., claude_success output detection failure)
      - name: Create PRs for orphaned branches
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          TIMEOUT_MINUTES: ${{ env.STUCK_TIMEOUT_MINUTES }}
        run: |
          echo "üîç Looking for orphaned branches (branches with commits but no PR)..."

          # Get issues stuck in-progress for >30 min (shorter window for this check)
          ISSUES=$(gh issue list \
            --repo ${{ github.repository }} \
            --label "tdd-spec:in-progress" \
            --json number,title,updatedAt \
            --limit 100)

          NOW=$(date +%s)
          ORPHAN_TIMEOUT=1800  # 30 minutes - shorter than full stuck timeout
          CREATED_COUNT=0

          while read -r issue; do
            [ -z "$issue" ] && continue

            ISSUE_NUMBER=$(echo "$issue" | jq -r '.number')
            TITLE=$(echo "$issue" | jq -r '.title')
            UPDATED_AT=$(echo "$issue" | jq -r '.updatedAt')

            UPDATED_EPOCH=$(date -d "$UPDATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$UPDATED_AT" +%s 2>/dev/null || echo "0")
            AGE=$((NOW - UPDATED_EPOCH))

            # Only check issues that have been in-progress for >30 minutes
            if [ "$AGE" -le "$ORPHAN_TIMEOUT" ]; then
              continue
            fi

            AGE_MIN=$((AGE / 60))
            echo ""
            echo "üîç Checking issue #$ISSUE_NUMBER (${AGE_MIN} min old) for orphaned branch..."

            # Check if a PR already exists for this issue
            EXISTING_PR=$(gh pr list \
              --repo ${{ github.repository }} \
              --json number,body \
              --jq "[.[] | select(.body | test(\"Closes #$ISSUE_NUMBER(\\\\s|$)\"))][0].number" 2>/dev/null || echo "")

            if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
              echo "   ‚úÖ PR #$EXISTING_PR already exists - skipping"
              continue
            fi

            # Check if a branch exists for this issue
            BRANCH_PATTERN="claude/issue-${ISSUE_NUMBER}-"
            BRANCH_NAME=$(gh api "/repos/${{ github.repository }}/branches" \
              --jq "[.[] | select(.name | startswith(\"$BRANCH_PATTERN\"))][0].name" 2>/dev/null || echo "")

            if [ -z "$BRANCH_NAME" ] || [ "$BRANCH_NAME" = "null" ]; then
              echo "   ‚ö†Ô∏è  No branch found - cannot create PR"
              continue
            fi

            echo "   üåø Found orphaned branch: $BRANCH_NAME"

            # Check if branch has commits ahead of main
            COMMITS_AHEAD=$(gh api "/repos/${{ github.repository }}/compare/main...$BRANCH_NAME" \
              --jq '.ahead_by' 2>/dev/null || echo "0")

            if [ "$COMMITS_AHEAD" -eq 0 ]; then
              echo "   ‚ö†Ô∏è  Branch has no commits ahead of main - skipping"
              continue
            fi

            echo "   üìù Branch has $COMMITS_AHEAD commit(s) ahead of main"

            # Extract spec ID from issue title
            SPEC_ID=$(echo "$TITLE" | grep -oE '[A-Z]+-[A-Z]+-[A-Z0-9-]+' | head -1 || echo "unknown-spec")

            echo "   üöÄ Creating PR from orphaned branch..."

            # Create the PR
            PR_NUMBER=$(gh pr create \
              --repo ${{ github.repository }} \
              --head "$BRANCH_NAME" \
              --base main \
              --title "fix: implement $SPEC_ID" \
              --body "Closes #${ISSUE_NUMBER}" \
              --label "tdd-automation" \
              --json number --jq '.number' 2>&1)

            if [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
              echo "   ‚úÖ PR #$PR_NUMBER created successfully!"
              CREATED_COUNT=$((CREATED_COUNT + 1))

              # Enable auto-merge
              if gh pr merge "$PR_NUMBER" --repo ${{ github.repository }} --auto --squash 2>/dev/null; then
                echo "   ‚úÖ Auto-merge enabled"
              else
                echo "   ‚ö†Ô∏è  Could not enable auto-merge"
              fi

              # Post comment on issue
              gh issue comment "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                --body "üîß **Orphaned Branch Recovery**

              Found branch \`$BRANCH_NAME\` with $COMMITS_AHEAD commit(s) but no PR.

              **Created**: PR #$PR_NUMBER with auto-merge enabled.

              This recovery was triggered because the original verify-success job was skipped (likely due to output detection issues).

              ---
              *ü§ñ TDD Monitor - Orphaned Branch Recovery*"
            else
              echo "   ‚ùå Failed to create PR: $PR_NUMBER"

              # Check if it's a "PR already exists" error
              if echo "$PR_NUMBER" | grep -qi "already exists"; then
                echo "   ‚ÑπÔ∏è  PR already exists (race condition)"
              fi
            fi
          done < <(echo "$ISSUES" | jq -r '.[] | @json')

          if [ "$CREATED_COUNT" -gt 0 ]; then
            echo ""
            echo "‚úÖ Created $CREATED_COUNT PR(s) from orphaned branches"
          else
            echo "‚úÖ No orphaned branches found"
          fi

  # Job 3: PR Monitoring
  # Monitors PRs for missing auto-merge and stuck validation
  pr-monitoring:
    name: üìã PR Monitoring
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Monitor PRs for auto-merge
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "üîç Checking PRs for missing auto-merge..."

          PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,title,autoMergeRequest,createdAt,mergeable \
            --limit 50)

          NOW=$(date +%s)
          FIXED_COUNT=0

          # Use process substitution to avoid subshell variable scope issue
          while read -r pr; do
            [ -z "$pr" ] && continue

            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            TITLE=$(echo "$pr" | jq -r '.title')
            AUTO_MERGE=$(echo "$pr" | jq -r '.autoMergeRequest')
            CREATED_AT=$(echo "$pr" | jq -r '.createdAt')
            MERGEABLE=$(echo "$pr" | jq -r '.mergeable')

            if [ "$AUTO_MERGE" = "null" ] || [ -z "$AUTO_MERGE" ]; then
              CREATED_EPOCH=$(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s 2>/dev/null || echo "$NOW")
              AGE_MIN=$(( (NOW - CREATED_EPOCH) / 60 ))

              # Only enable auto-merge if PR is >5 min old (give CI time to start)
              if [ "$AGE_MIN" -ge 5 ]; then
                # Check if Claude Code is actively processing the linked issue
                # This prevents race conditions where Monitor enables auto-merge while original Claude is still running
                # NOTE: We use spec ID matching because displayTitle contains spec ID (e.g., "APP-TABLES-001"),
                # NOT issue number. See PR #6113 race condition incident.
                PR_BODY=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json body --jq '.body' 2>/dev/null || echo "")
                LINKED_ISSUE=$(echo "$PR_BODY" | grep -oE 'Closes #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")

                if [ -n "$LINKED_ISSUE" ]; then
                  ISSUE_TITLE=$(gh issue view "$LINKED_ISSUE" --repo ${{ github.repository }} --json title --jq '.title' 2>/dev/null || echo "")
                  SPEC_ID=$(echo "$ISSUE_TITLE" | grep -oE '[A-Z]+-[A-Z]+-[0-9]+' | head -1)

                  if [ -n "$SPEC_ID" ]; then
                    CLAUDE_RUNNING=$(gh run list \
                      --repo ${{ github.repository }} \
                      --workflow "TDD - Execute (Claude Code)" \
                      --json status,displayTitle \
                      --jq "[.[] | select(.status == \"in_progress\" or .status == \"queued\") | select(.displayTitle | contains(\"$SPEC_ID\"))] | length" 2>/dev/null || echo "0")

                    if [ "$CLAUDE_RUNNING" -gt 0 ]; then
                      echo "   ‚è≠Ô∏è  Skipping auto-merge - Claude Code is actively processing spec $SPEC_ID (issue #$LINKED_ISSUE)"
                      continue
                    fi
                  fi
                fi

                echo ""
                echo "‚ö†Ô∏è  PR #$PR_NUMBER missing auto-merge (${AGE_MIN}m old)"
                echo "   Enabling auto-merge..."

                # Try to enable auto-merge
                if gh pr merge "$PR_NUMBER" --repo ${{ github.repository }} --auto --squash 2>/dev/null; then
                  # Verify it was enabled
                  sleep 2
                  VERIFY=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json autoMergeRequest --jq '.autoMergeRequest')

                  if [ "$VERIFY" != "null" ]; then
                    echo "   ‚úÖ Auto-merge enabled"
                    FIXED_COUNT=$((FIXED_COUNT + 1))

                    gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                      --body "üîß **Auto-merge enabled**

                    Detected missing auto-merge after $AGE_MIN minutes.

                    PR will merge automatically when CI passes.

                    ---
                    *ü§ñ TDD Monitor*"
                  else
                    echo "   ‚ö†Ô∏è  Auto-merge command succeeded but not enabled (may not be mergeable)"
                  fi
                else
                  echo "   ‚ö†Ô∏è  Could not enable auto-merge (PR may not be mergeable)"
                fi
              fi
            fi
          done < <(echo "$PRS" | jq -r '.[] | @json')

          if [ "$FIXED_COUNT" -gt 0 ]; then
            echo ""
            echo "‚úÖ Enabled auto-merge on $FIXED_COUNT PR(s)"
          else
            echo "‚úÖ All PRs have auto-merge enabled"
          fi

      - name: Update outdated PR branches
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "üîç Checking for PRs with outdated branches..."

          PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,title,headRefName,mergeable,mergeStateStatus,baseRefName \
            --limit 50)

          UPDATED_COUNT=0
          SKIPPED_COUNT=0
          NOW=$(date +%s)
          # Only post update comment if no similar comment in last 2 hours
          COOLDOWN_SECONDS=7200

          # Use process substitution to avoid subshell variable scope issue
          while read -r pr; do
            [ -z "$pr" ] && continue

            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            HEAD_REF=$(echo "$pr" | jq -r '.headRefName')
            MERGEABLE=$(echo "$pr" | jq -r '.mergeable')
            MERGE_STATE=$(echo "$pr" | jq -r '.mergeStateStatus')

            # Check if branch is behind (but not conflicted)
            if [ "$MERGE_STATE" = "BEHIND" ] || [ "$MERGEABLE" = "UNKNOWN" ]; then
              echo ""
              echo "‚ö†Ô∏è  PR #$PR_NUMBER branch is behind main"

              # Check for recent "@claude update" comment to prevent spam
              # Use broader substring match to catch any update-related @claude mentions
              RECENT_UPDATE_COMMENT=$(gh api \
                "/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
                --jq "[.[] | select(.body | contains(\"@claude update\")) | select(.created_at > \"$(date -u -d '2 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-2H +%Y-%m-%dT%H:%M:%SZ)\")] | length" 2>/dev/null || echo "0")

              if [ "$RECENT_UPDATE_COMMENT" -gt 0 ]; then
                echo "   ‚è≠Ô∏è  Skipping - update already requested within last 2 hours"
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
                continue
              fi

              # Check if Claude Code is actively processing the linked issue
              # This prevents race conditions where Monitor triggers updates while original Claude is still running
              # NOTE: We use spec ID matching because displayTitle contains spec ID (e.g., "APP-TABLES-001"),
              # NOT issue number (e.g., "#5996"). See PR #6092 race condition incident.
              PR_BODY=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json body --jq '.body' 2>/dev/null || echo "")
              LINKED_ISSUE=$(echo "$PR_BODY" | grep -oE 'Closes #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")

              if [ -n "$LINKED_ISSUE" ]; then
                # Get the spec ID from the linked issue title (e.g., "APP-TABLES-TIMEZONE-001")
                ISSUE_TITLE=$(gh issue view "$LINKED_ISSUE" --repo ${{ github.repository }} --json title --jq '.title' 2>/dev/null || echo "")
                SPEC_ID=$(echo "$ISSUE_TITLE" | grep -oE '[A-Z]+-[A-Z]+-[0-9]+' | head -1)

                if [ -n "$SPEC_ID" ]; then
                  CLAUDE_RUNNING=$(gh run list \
                    --repo ${{ github.repository }} \
                    --workflow "TDD - Execute (Claude Code)" \
                    --json status,displayTitle \
                    --jq "[.[] | select(.status == \"in_progress\" or .status == \"queued\") | select(.displayTitle | contains(\"$SPEC_ID\"))] | length" 2>/dev/null || echo "0")

                  if [ "$CLAUDE_RUNNING" -gt 0 ]; then
                    echo "   ‚è≠Ô∏è  Skipping - Claude Code is actively processing spec $SPEC_ID (issue #$LINKED_ISSUE)"
                    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
                    continue
                  fi
                fi
              fi

              echo "   Triggering branch update..."

              # Post @claude comment to update branch
              gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                --body "@claude update this PR branch to include latest main changes

              ## üìã Context
              - **PR**: #$PR_NUMBER
              - **Branch**: \`$HEAD_REF\`
              - **Status**: Branch is behind main and needs to be updated

              ## ü§ñ Automation Mode
              - ‚úÖ Make autonomous decisions - proceed with best judgment
              - ‚ùå DO NOT ask questions

              ## ‚úÖ Instructions

              1. **Fetch latest main**:
                 \`\`\`bash
                 git fetch origin main:main
                 \`\`\`

              2. **Checkout PR branch and merge main**:
                 \`\`\`bash
                 git checkout $HEAD_REF
                 git merge origin/main
                 \`\`\`

              3. **If merge conflicts occur**:
                 - Resolve conflicts (prioritize incoming changes from main for config files)
                 - For code conflicts, keep both implementations if safe, otherwise prefer main
                 - Run \`bun run quality\` to verify resolution is correct

              4. **Push updated branch**:
                 \`\`\`bash
                 git push
                 \`\`\`

              5. **Verify auto-merge still enabled**:
                 \`\`\`bash
                 gh pr view $PR_NUMBER --json autoMergeRequest
                 \`\`\`
                 If autoMergeRequest is null, re-enable: \`gh pr merge $PR_NUMBER --auto --squash\`

              ## ‚ö†Ô∏è Error Handling
              - **If conflicts cannot be resolved automatically**: Add comment explaining the conflict and add label \`needs-manual-resolution\`
              - **If quality checks fail after merge**: Fix the issues before pushing

              Auto-merge will proceed once branch is updated and CI passes.

              ---
              *ü§ñ TDD Monitor*"

              UPDATED_COUNT=$((UPDATED_COUNT + 1))
            fi
          done < <(echo "$PRS" | jq -r '.[] | @json')

          if [ "$UPDATED_COUNT" -gt 0 ]; then
            echo ""
            echo "‚úÖ Triggered branch update for $UPDATED_COUNT PR(s)"
          fi
          if [ "$SKIPPED_COUNT" -gt 0 ]; then
            echo "‚è≠Ô∏è  Skipped $SKIPPED_COUNT PR(s) (update already requested recently)"
          fi
          if [ "$UPDATED_COUNT" -eq 0 ] && [ "$SKIPPED_COUNT" -eq 0 ]; then
            echo "‚úÖ All PR branches are up-to-date"
          fi

      - name: Detect and close empty diff PRs (superseded)
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "üîç Checking for PRs with empty diff (superseded by main)..."

          PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,title,headRefName,body \
            --limit 50)

          CLOSED_COUNT=0

          # Use process substitution to avoid subshell variable scope issue
          while read -r pr; do
            [ -z "$pr" ] && continue

            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            TITLE=$(echo "$pr" | jq -r '.title')
            HEAD_REF=$(echo "$pr" | jq -r '.headRefName')
            BODY=$(echo "$pr" | jq -r '.body')

            # Check if PR has any meaningful diff from main
            # IMPORTANT: Validate command success to avoid false positives
            DIFF_OUTPUT=$(gh pr diff "$PR_NUMBER" --repo ${{ github.repository }} 2>&1)
            DIFF_STATUS=$?
            DIFF_LINES=$(echo "$DIFF_OUTPUT" | wc -l | tr -d ' ')

            # Skip if diff command failed (network issues, conflicting PR, etc.)
            if [ "$DIFF_STATUS" -ne 0 ]; then
              echo "   ‚ö†Ô∏è  Could not compute diff for PR #$PR_NUMBER - skipping (may have conflicts)"
              continue
            fi

            if [ "$DIFF_LINES" -eq 0 ] || [ -z "$DIFF_LINES" ]; then
              echo ""
              echo "‚ö†Ô∏è  PR #$PR_NUMBER has empty diff (superseded by main)"
              echo "   Title: $TITLE"
              echo "   Closing as superseded..."

              # Extract linked issue number from PR body
              ISSUE_NUMBER=$(echo "$BODY" | grep -oE 'Closes #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")

              # Close the PR with explanation
              gh pr close "$PR_NUMBER" --repo ${{ github.repository }} \
                --comment "üîÑ **PR Closed: Superseded by Main**

              This PR has an empty diff compared to main, meaning the changes have already been merged through another commit.

              **What happened**:
              - The implementation in this PR was superseded by changes merged to main
              - After syncing with main, there are no unique changes left in this PR
              - This is not a failure - the work is complete, just via a different path

              **Issue status**: $([ -n "$ISSUE_NUMBER" ] && echo "Closing #$ISSUE_NUMBER as completed" || echo "No linked issue found")

              ---
              *ü§ñ TDD Monitor - Empty Diff Detection*"

              CLOSED_COUNT=$((CLOSED_COUNT + 1))

              # Close the linked issue as completed (work is done)
              if [ -n "$ISSUE_NUMBER" ]; then
                # Check current issue state
                ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --repo ${{ github.repository }} --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")

                if [ "$ISSUE_STATE" = "OPEN" ]; then
                  echo "   Closing linked issue #$ISSUE_NUMBER as completed..."
                  gh issue close "$ISSUE_NUMBER" --repo ${{ github.repository }} --reason completed 2>/dev/null || true
                  gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                    --remove-label "tdd-spec:in-progress" \
                    --add-label "tdd-spec:completed" 2>/dev/null || true
                fi
              fi
            fi
          done < <(echo "$PRS" | jq -r '.[] | @json')

          if [ "$CLOSED_COUNT" -gt 0 ]; then
            echo ""
            echo "‚úÖ Closed $CLOSED_COUNT superseded PR(s)"
          else
            echo "‚úÖ No superseded PRs found"
          fi

      - name: Detect stuck PRs
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          STUCK_TIMEOUT: ${{ env.PR_STUCK_TIMEOUT_MINUTES }}
        run: |
          echo "üîç Checking for PRs stuck in validation..."

          PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,title,createdAt,statusCheckRollup \
            --limit 50)

          NOW=$(date +%s)
          STUCK_COUNT=0

          # Use process substitution to avoid subshell variable scope issue
          while read -r pr; do
            [ -z "$pr" ] && continue

            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            CREATED_AT=$(echo "$pr" | jq -r '.createdAt')

            CREATED_EPOCH=$(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s 2>/dev/null || echo "$NOW")
            AGE_MIN=$(( (NOW - CREATED_EPOCH) / 60 ))

            # Check if stuck (>120 min old)
            if [ "$AGE_MIN" -ge "$STUCK_TIMEOUT" ]; then
              echo ""
              echo "‚ö†Ô∏è  PR #$PR_NUMBER stuck for ${AGE_MIN}m"

              # Check if perpetually failing
              CHECKS=$(echo "$pr" | jq -r '.statusCheckRollup')
              FAILURES=$(echo "$CHECKS" | jq '[.[] | select(.conclusion == "FAILURE")] | length' 2>/dev/null || echo "0")

              if [ "$FAILURES" -gt 3 ]; then
                echo "   ‚ùå Perpetual failures detected - force closing"
                STUCK_COUNT=$((STUCK_COUNT + 1))

                # Get linked issue
                ISSUE_NUMBER=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json body --jq '.body' | grep -oP 'Closes #\K\d+' | head -1)

                gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                  --body "‚ùå **PR Force-Closed: Perpetual Failures**

                PR stuck for ${AGE_MIN} minutes with multiple CI failures.

                Marking spec as failed. Manual intervention required.

                ---
                *ü§ñ TDD Monitor*"

                gh pr close "$PR_NUMBER" --repo ${{ github.repository }}

                if [ -n "$ISSUE_NUMBER" ]; then
                  gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                    --remove-label "tdd-spec:in-progress" \
                    --add-label "tdd-spec:failed"
                fi
              else
                echo "   ‚ö†Ô∏è  PR stuck but checks still running - monitoring"
              fi
            fi
          done < <(echo "$PRS" | jq -r '.[] | @json')

          if [ "$STUCK_COUNT" -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è  Force-closed $STUCK_COUNT stuck PR(s)"
          fi

  # Job 4: Conflict Resolution
  # Detects and resolves merge conflicts automatically
  conflict-resolution:
    name: üîÄ Conflict Resolution
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'push' || github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'

    steps:
      # PRE-CHECK: Close superseded PRs BEFORE attempting conflict resolution
      # This prevents wasted Claude runs when changes are already in main
      - name: Close superseded PRs first
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "üîç Pre-checking for superseded PRs before conflict resolution..."

          PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,headRefName,body,mergeable \
            --limit 50)

          CLOSED_COUNT=0

          while read -r pr; do
            [ -z "$pr" ] && continue

            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            MERGEABLE=$(echo "$pr" | jq -r '.mergeable')

            # Only check conflicting PRs - they might be superseded
            if [ "$MERGEABLE" != "CONFLICTING" ]; then
              continue
            fi

            # Check if PR has empty diff (superseded by main)
            DIFF_OUTPUT=$(gh pr diff "$PR_NUMBER" --repo ${{ github.repository }} 2>&1)
            DIFF_STATUS=$?

            # Skip if diff command failed (actual conflicts exist that need resolution)
            if [ "$DIFF_STATUS" -ne 0 ]; then
              continue
            fi

            DIFF_LINES=$(echo "$DIFF_OUTPUT" | wc -l | tr -d ' ')

            if [ "$DIFF_LINES" -eq 0 ] || [ -z "$DIFF_OUTPUT" ]; then
              echo "‚ö†Ô∏è  PR #$PR_NUMBER has empty diff - closing as superseded (not conflicted)"

              BODY=$(echo "$pr" | jq -r '.body')
              ISSUE_NUMBER=$(echo "$BODY" | grep -oE 'Closes #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")

              gh pr close "$PR_NUMBER" --repo ${{ github.repository }} \
                --comment "üîÑ **PR Closed: Superseded by Main**

              This PR appeared to have conflicts, but actually has no diff - the changes have already been merged through another PR.

              **Issue status**: $([ -n "$ISSUE_NUMBER" ] && echo "Closing #$ISSUE_NUMBER as completed" || echo "No linked issue")

              ---
              *ü§ñ TDD Monitor - Pre-Conflict Superseded Check*"

              CLOSED_COUNT=$((CLOSED_COUNT + 1))

              if [ -n "$ISSUE_NUMBER" ]; then
                ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --repo ${{ github.repository }} --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")
                if [ "$ISSUE_STATE" = "OPEN" ]; then
                  gh issue close "$ISSUE_NUMBER" --repo ${{ github.repository }} --reason completed 2>/dev/null || true
                  gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                    --remove-label "tdd-spec:in-progress" \
                    --add-label "tdd-spec:completed" 2>/dev/null || true
                fi
              fi
            fi
          done < <(echo "$PRS" | jq -r '.[] | @json')

          if [ "$CLOSED_COUNT" -gt 0 ]; then
            echo "‚úÖ Closed $CLOSED_COUNT superseded PR(s) before conflict resolution"
          else
            echo "‚úÖ No superseded PRs found"
          fi

      - name: Find and resolve conflicts
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "üîç Scanning for conflicted PRs..."

          CONFLICTED=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,mergeable,mergeStateStatus,headRefName,labels \
            --jq '.[] | select(.mergeable == "CONFLICTING" or .mergeStateStatus == "DIRTY")')

          if [ -z "$CONFLICTED" ]; then
            echo "‚úÖ No conflicted PRs found"
            exit 0
          fi

          echo "$CONFLICTED" | jq -r '.number' | while read -r PR_NUMBER; do
            echo ""
            echo "‚ö†Ô∏è  PR #$PR_NUMBER has conflicts"

            # COOLDOWN CHECK: Skip if any @claude comment was posted in last 10 minutes
            # This prevents duplicate Claude runs when multiple jobs trigger simultaneously
            RECENT_CLAUDE_COMMENT=$(gh api \
              "/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
              --jq "[.[] | select(.body | contains(\"@claude\")) | select(.created_at > \"$(date -u -d '10 minutes ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-10M +%Y-%m-%dT%H:%M:%SZ)\")] | length" 2>/dev/null || echo "0")

            if [ "$RECENT_CLAUDE_COMMENT" -gt 0 ]; then
              echo "   ‚è≠Ô∏è  Skipping - @claude comment already posted within last 10 minutes"
              continue
            fi

            # Check if Claude Code is actively processing the linked issue
            # This prevents posting @claude resolve conflicts while original Claude is still running
            PR_BODY=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json body --jq '.body' 2>/dev/null || echo "")
            LINKED_ISSUE=$(echo "$PR_BODY" | grep -oE 'Closes #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")

            if [ -n "$LINKED_ISSUE" ]; then
              ISSUE_TITLE=$(gh issue view "$LINKED_ISSUE" --repo ${{ github.repository }} --json title --jq '.title' 2>/dev/null || echo "")
              SPEC_ID=$(echo "$ISSUE_TITLE" | grep -oE '[A-Z]+-[A-Z]+-[0-9]+' | head -1)

              if [ -n "$SPEC_ID" ]; then
                CLAUDE_RUNNING=$(gh run list \
                  --repo ${{ github.repository }} \
                  --workflow "TDD - Execute (Claude Code)" \
                  --json status,displayTitle \
                  --jq "[.[] | select(.status == \"in_progress\" or .status == \"queued\") | select(.displayTitle | contains(\"$SPEC_ID\"))] | length" 2>/dev/null || echo "0")

                if [ "$CLAUDE_RUNNING" -gt 0 ]; then
                  echo "   ‚è≠Ô∏è  Skipping conflict resolution - Claude Code is actively processing spec $SPEC_ID (issue #$LINKED_ISSUE)"
                  continue
                fi
              fi
            fi

            # Check if already attempted resolution
            HAS_RETRY=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json labels --jq '.labels[].name' | grep "conflict-resolution:attempted" || echo "")

            if [ -n "$HAS_RETRY" ]; then
              # ESCALATION WAIT: Check when the label was added - only escalate if >15 min old
              # This gives Claude time to finish resolution before marking as manual
              LABEL_ADDED_AT=$(gh api "/repos/${{ github.repository }}/issues/${PR_NUMBER}/events" \
                --jq '[.[] | select(.event == "labeled" and .label.name == "conflict-resolution:attempted")] | last | .created_at' 2>/dev/null || echo "")

              if [ -n "$LABEL_ADDED_AT" ] && [ "$LABEL_ADDED_AT" != "null" ]; then
                LABEL_EPOCH=$(date -d "$LABEL_ADDED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$LABEL_ADDED_AT" +%s 2>/dev/null || echo "0")
                NOW=$(date +%s)
                AGE_MIN=$(( (NOW - LABEL_EPOCH) / 60 ))

                # Only escalate if >15 minutes since first attempt (Claude can take 10+ min)
                if [ "$AGE_MIN" -lt 15 ]; then
                  echo "   ‚è≥ First resolution attempt only ${AGE_MIN}m old - waiting for Claude to finish (need 15m)"
                  continue
                fi

                echo "   First attempt was ${AGE_MIN}m ago (>15m threshold) - escalating to manual"
              fi

              echo "   Already attempted - marking for manual review"

              gh pr edit "$PR_NUMBER" --repo ${{ github.repository }} \
                --add-label "needs-manual-resolution"

              gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                --body "ü§ñ **Manual Resolution Required**

              Automatic conflict resolution failed after >15 minutes. Please resolve manually:

              1. \`git fetch origin main:main\`
              2. \`git checkout [branch] && git rebase origin/main\`
              3. Resolve conflicts
              4. \`git push --force-with-lease\`

              ---
              *ü§ñ TDD Monitor*"
            else
              echo "   Triggering automatic resolution"

              gh pr edit "$PR_NUMBER" --repo ${{ github.repository }} \
                --add-label "conflict-resolution:attempted"

              HEAD_REF=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json headRefName --jq '.headRefName')

              gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                --body "@claude resolve merge conflicts in this PR

              ## üìã Context
              - **PR**: #$PR_NUMBER
              - **Branch**: \`$HEAD_REF\`
              - **Status**: Has merge conflicts that need resolution

              ## ü§ñ Automation Mode
              - ‚úÖ Make autonomous decisions - proceed with best judgment
              - ‚ùå DO NOT ask questions
              - ‚ö†Ô∏è This is the FIRST automatic resolution attempt

              ## ‚úÖ Instructions

              1. **Fetch latest main**:
                 \`\`\`bash
                 git fetch origin main:main
                 \`\`\`

              2. **Checkout branch and rebase on main**:
                 \`\`\`bash
                 git checkout $HEAD_REF
                 git rebase origin/main
                 \`\`\`

              3. **Resolve conflicts with these priorities**:
                 - **Config files** (package.json, tsconfig.json, etc.): Accept incoming (main) version
                 - **Source code** (src/): Keep both implementations if compatible, otherwise prefer main
                 - **Test files** (specs/): Keep both test cases, merge test logic carefully
                 - **Generated files** (SPEC-PROGRESS.md, etc.): Accept incoming (main) version

              4. **Verify resolution is correct**:
                 \`\`\`bash
                 bun run quality
                 \`\`\`
                 ALL checks must pass (ESLint, TypeScript, Effect diagnostics, unit tests, E2E regression)

              5. **Push resolved changes**:
                 \`\`\`bash
                 git push --force-with-lease
                 \`\`\`

              6. **Re-enable auto-merge**:
                 \`\`\`bash
                 gh pr merge $PR_NUMBER --auto --squash
                 \`\`\`

              7. **Verify auto-merge enabled**:
                 \`\`\`bash
                 gh pr view $PR_NUMBER --json autoMergeRequest
                 \`\`\`

              ## ‚ö†Ô∏è Error Handling

              - **If rebase fails with complex conflicts**: Try merge instead: \`git merge origin/main\`
              - **If quality checks fail after resolution**: Fix the failing checks before pushing
              - **If automatic resolution is not possible**:
                1. Add comment explaining which files have irresolvable conflicts
                2. Add label \`needs-manual-resolution\`
                3. Do NOT push broken code

              ---
              *ü§ñ TDD Monitor*"
            fi
          done

  # Job 5: Failed PR Recovery
  # Detects TDD PRs with failed CI and triggers Claude to fix regressions
  failed-pr-recovery:
    name: üîß Failed PR Recovery
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Find and recover PRs with failed CI
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          COOLDOWN_MINUTES: ${{ env.FAILED_PR_COOLDOWN_MINUTES }}
        run: |
          echo "üîç Looking for TDD PRs with failed CI..."

          PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,title,headRefName,statusCheckRollup,labels,body \
            --limit 50)

          RECOVERED_COUNT=0
          ESCALATED_COUNT=0

          # Pre-calculate cooldown cutoff time (fixes variable expansion in jq)
          CUTOFF_TIME=$(date -u -d "${COOLDOWN_MINUTES} minutes ago" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-${COOLDOWN_MINUTES}M +%Y-%m-%dT%H:%M:%SZ)

          # Use process substitution to avoid subshell variable scope issue
          while read -r pr; do
            [ -z "$pr" ] && continue

            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            HEAD_REF=$(echo "$pr" | jq -r '.headRefName')
            LABELS=$(echo "$pr" | jq -r '.labels[].name' | tr '\n' ' ')
            BODY=$(echo "$pr" | jq -r '.body')

            # Extract linked issue number from PR body
            ISSUE_NUMBER=$(echo "$BODY" | grep -oE 'Closes #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")

            # Check if any Test* check failed (matches "Test", "Test E2E", etc.)
            TEST_FAILED=$(echo "$pr" | jq -r '.statusCheckRollup[]? | select(.name | startswith("Test")) | select(.conclusion == "FAILURE") | .name' 2>/dev/null | head -1)

            if [ -z "$TEST_FAILED" ]; then
              continue
            fi

            echo ""
            echo "‚ö†Ô∏è  PR #$PR_NUMBER has failed CI (check: $TEST_FAILED)"

            # Skip if already marked for manual resolution
            if echo "$LABELS" | grep -q "needs-manual-resolution"; then
              echo "   ‚è≠Ô∏è  Skipping - already marked for manual resolution"
              continue
            fi

            # Check for recent fix comments (cooldown period)
            # Matches both this job's comments AND test.yml's handle-regressions comments
            # NOTE: test.yml now posts "Regression Auto-Fix Required" comments WITH @claude for immediate response
            #       This job serves as a backup safety net for any missed regressions
            RECENT_FIX_COMMENT=$(gh api \
              "/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
              --jq "[.[] | select(.body | contains(\"Failed PR Recovery\") or contains(\"Regression Auto-Fix Required\") or contains(\"Regression Detected\")) | select(.created_at > \"${CUTOFF_TIME}\")] | length" 2>/dev/null || echo "0")

            if [ "$RECENT_FIX_COMMENT" -gt 0 ]; then
              echo "   ‚è≠Ô∏è  Skipping - fix already triggered within last ${COOLDOWN_MINUTES} minutes"
              continue
            fi

            # Check if Claude Code is already processing this PR (prevents duplicate @claude mentions)
            # NOTE: We use spec ID matching because headBranch is always "main" for issue_comment triggers,
            # not the PR branch. displayTitle contains spec ID (e.g., "APP-TABLES-001").
            # See PR #6092 race condition incident.
            if [ -n "$ISSUE_NUMBER" ]; then
              ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --repo ${{ github.repository }} --json title --jq '.title' 2>/dev/null || echo "")
              SPEC_ID=$(echo "$ISSUE_TITLE" | grep -oE '[A-Z]+-[A-Z]+-[0-9]+' | head -1)

              if [ -n "$SPEC_ID" ]; then
                CLAUDE_RUNNING=$(gh run list \
                  --repo ${{ github.repository }} \
                  --workflow "TDD - Execute (Claude Code)" \
                  --json status,displayTitle \
                  --jq "[.[] | select(.status == \"in_progress\" or .status == \"queued\") | select(.displayTitle | contains(\"$SPEC_ID\"))] | length" 2>/dev/null || echo "0")

                if [ "$CLAUDE_RUNNING" -gt 0 ]; then
                  echo "   ‚è≠Ô∏è  Skipping - Claude Code already processing spec $SPEC_ID (issue #$ISSUE_NUMBER)"
                  continue
                fi
              fi
            fi

            # Count total fix attempts (by counting "Failed PR Recovery" comments)
            FIX_ATTEMPTS=$(gh api \
              "/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
              --jq "[.[] | select(.body | contains(\"Failed PR Recovery\"))] | length" 2>/dev/null || echo "0")

            # Synchronize retry label with comment-based count
          # This ensures labels match actual retry attempts (fixes label drift issue)
          if [ "$FIX_ATTEMPTS" -ge 1 ]; then
            # Remove old retry labels first
            for i in 1 2 3; do
              gh pr edit "$PR_NUMBER" --repo ${{ github.repository }} --remove-label "retry:infra:$i" 2>/dev/null || true
              gh pr edit "$PR_NUMBER" --repo ${{ github.repository }} --remove-label "retry:spec:$i" 2>/dev/null || true
            done
            # Add current retry label (use infra for monitor-initiated retries)
            gh pr edit "$PR_NUMBER" --repo ${{ github.repository }} --add-label "retry:infra:$FIX_ATTEMPTS" 2>/dev/null || true
            echo "   üìä Updated retry label to retry:infra:$FIX_ATTEMPTS"

            # Also update the linked issue labels
            if [ -n "$ISSUE_NUMBER" ]; then
              for i in 1 2 3; do
                gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} --remove-label "retry:infra:$i" 2>/dev/null || true
                gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} --remove-label "retry:spec:$i" 2>/dev/null || true
              done
              gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} --add-label "retry:infra:$FIX_ATTEMPTS" 2>/dev/null || true
            fi
          fi

          if [ "$FIX_ATTEMPTS" -ge 3 ]; then
              echo "   ‚ùå Max fix attempts (3) reached - marking for manual resolution"
              ESCALATED_COUNT=$((ESCALATED_COUNT + 1))

              gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                --body "‚ùå **Max Regression Fix Attempts Exhausted**

              This PR has failed to fix regressions after 3 automated attempts.

              **Manual intervention required**:
              1. Review the [test failures](https://github.com/${{ github.repository }}/actions)
              2. Analyze the root cause of the regression
              3. Fix the issue manually or close the PR

              **Common causes**:
              - Greedy catch-all schemas that match valid field types
              - Validation logic changes that are too permissive
              - Type changes that break dependent code

              ---
              *ü§ñ TDD Monitor*"

              gh pr edit "$PR_NUMBER" --repo ${{ github.repository }} \
                --add-label "needs-manual-resolution"

              # Also update the linked issue
              if [ -n "$ISSUE_NUMBER" ]; then
                gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                  --remove-label "tdd-spec:in-progress" \
                  --add-label "tdd-spec:failed" 2>/dev/null || true
              else
                echo "   ‚ö†Ô∏è  No linked issue found - cannot update issue state"
              fi
            else
              NEXT_ATTEMPT=$((FIX_ATTEMPTS + 1))
              echo "   üîÑ Triggering regression fix attempt $NEXT_ATTEMPT of 3"
              RECOVERED_COUNT=$((RECOVERED_COUNT + 1))

              gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                --body "## üîß Failed PR Recovery (Attempt $NEXT_ATTEMPT of 3)

              @claude The CI tests are failing. Please fix the regressions.

              ### ü§ñ Automation Mode
              - ‚úÖ Make autonomous decisions - proceed with best judgment
              - ‚ùå DO NOT ask questions

              ### ‚úÖ Instructions

              1. **Pull latest and check test failures**:
                 \`\`\`bash
                 git fetch origin $HEAD_REF
                 git checkout $HEAD_REF
                 bun test:e2e:regression
                 \`\`\`

              2. **Identify the regression cause**:
                 - Look at which tests are failing (may be different from target spec)
                 - Check what your changes may have affected
                 - Common issue: catch-all schemas that are too greedy

              3. **Fix without modifying the failing tests**:
                 - Preserve existing validation behavior
                 - For catch-all schemas: explicitly EXCLUDE known types
                 - Example fix for UnknownFieldSchema:
                   \`\`\`typescript
                   // BAD: catches all types including valid ones
                   type: Schema.String

                   // GOOD: only catches truly unknown types
                   type: Schema.String.pipe(
                     Schema.filter((t) => !KNOWN_FIELD_TYPES.includes(t))
                   )
                   \`\`\`

              4. **Verify all tests pass**:
                 \`\`\`bash
                 bun run quality
                 bun test:e2e:regression
                 \`\`\`

              5. **Push the fix**:
                 \`\`\`bash
                 bun run license
                 git add -A
                 git commit -m \"fix: resolve regression\"
                 git push
                 \`\`\`

              6. **Re-enable auto-merge** (if disabled):
                 \`\`\`bash
                 gh pr merge $PR_NUMBER --auto --squash
                 \`\`\`

              ---
              *ü§ñ TDD Monitor*"
            fi
          done < <(echo "$PRS" | jq -r '.[] | @json')

          if [ "$RECOVERED_COUNT" -gt 0 ]; then
            echo ""
            echo "‚úÖ Triggered fix for $RECOVERED_COUNT PR(s)"
          fi
          if [ "$ESCALATED_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è  Escalated $ESCALATED_COUNT PR(s) for manual resolution"
          fi
          if [ "$RECOVERED_COUNT" -eq 0 ] && [ "$ESCALATED_COUNT" -eq 0 ]; then
            echo "‚úÖ No PRs with failed CI need recovery"
          fi

  # Job 6: Update Spec State
  # Runs analyze:specs and commits SPEC-PROGRESS.md after successful test implementation
  update-spec-state:
    name: üìà Update Spec State
    runs-on: ubuntu-latest
    timeout-minutes: 10
    # Only run on push to main (when TDD PRs are merged)
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.3.3'

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run spec analysis
        run: |
          echo "üìä Running spec analysis..."
          bun run analyze:specs --no-error || true

      - name: Check for changes
        id: changes
        run: |
          # Check both files that analyze-specs.ts may update
          SPEC_CHANGED=false
          README_CHANGED=false

          if ! git diff --quiet SPEC-PROGRESS.md 2>/dev/null; then
            SPEC_CHANGED=true
            echo "üìù SPEC-PROGRESS.md has changes"
          fi

          if ! git diff --quiet README.md 2>/dev/null; then
            README_CHANGED=true
            echo "üìù README.md has changes (badges updated)"
          fi

          if [ "$SPEC_CHANGED" = "true" ] || [ "$README_CHANGED" = "true" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No changes to SPEC-PROGRESS.md or README.md"
          fi

      - name: Commit and push changes
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Add both files (git add only stages if file has changes)
          git add SPEC-PROGRESS.md README.md
          git commit -m "chore: update SPEC-PROGRESS.md [skip ci]

          ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

          Co-Authored-By: Claude <noreply@anthropic.com>"

          git push

          echo "‚úÖ SPEC-PROGRESS.md and README.md committed and pushed"

  # Job 7: Branch Cleanup (Weekly)
  # Cleans up stale TDD branches - runs only on Sundays
  branch-cleanup:
    name: üóëÔ∏è Branch Cleanup (Weekly)
    runs-on: ubuntu-latest
    timeout-minutes: 10
    # Only run on scheduled runs AND on Sundays (day 0)
    if: github.event_name == 'schedule'

    steps:
      - name: Check if Sunday
        id: check-day
        run: |
          DAY_OF_WEEK=$(date -u +%u)
          HOUR=$(date -u +%H)
          # Run only on Sunday (7) between 1-3 AM UTC
          if [ "$DAY_OF_WEEK" = "7" ] && [ "$HOUR" -ge 1 ] && [ "$HOUR" -le 3 ]; then
            echo "is_cleanup_time=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Sunday cleanup window - proceeding"
          else
            echo "is_cleanup_time=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è Not Sunday cleanup window (day=$DAY_OF_WEEK, hour=$HOUR) - skipping"
          fi

      - name: Checkout code
        if: steps.check-day.outputs.is_cleanup_time == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cleanup stale branches
        if: steps.check-day.outputs.is_cleanup_time == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üîç Scanning for stale TDD branches..."

          # Get all tdd/ and claude/ branches
          ALL_TDD_BRANCHES=$(git ls-remote --heads origin | awk '{print $2}' | sed 's|refs/heads/||' | grep -E '^(tdd|claude)/' || true)

          if [ -z "$ALL_TDD_BRANCHES" ]; then
            echo "‚úÖ No TDD branches found - nothing to clean up"
            exit 0
          fi

          echo "Found $(echo "$ALL_TDD_BRANCHES" | wc -l | tr -d ' ') TDD branches"

          # Check each branch against PRs
          DELETED_COUNT=0
          KEPT_COUNT=0

          while IFS= read -r branch; do
            [ -z "$branch" ] && continue

            # Check if there's an open PR for this branch
            OPEN_PR=$(gh pr list --head "$branch" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")

            if [ -n "$OPEN_PR" ]; then
              echo "‚è≠Ô∏è  Keeping branch (open PR #$OPEN_PR): $branch"
              KEPT_COUNT=$((KEPT_COUNT + 1))
              continue
            fi

            # Check if there's a closed/merged PR for this branch
            CLOSED_PR=$(gh pr list --head "$branch" --state closed --json number --jq '.[0].number' 2>/dev/null || echo "")
            MERGED_PR=$(gh pr list --head "$branch" --state merged --json number --jq '.[0].number' 2>/dev/null || echo "")

            if [ -n "$CLOSED_PR" ] || [ -n "$MERGED_PR" ]; then
              echo "üóëÔ∏è  Deleting stale branch: $branch (PR closed/merged)"
              if gh api --method DELETE "/repos/${{ github.repository }}/git/refs/heads/$branch" 2>/dev/null; then
                DELETED_COUNT=$((DELETED_COUNT + 1))
              else
                echo "‚ö†Ô∏è  Failed to delete $branch (may already be deleted)"
              fi
            else
              # No PR found - check branch age (only delete if older than 7 days)
              BRANCH_AGE_DAYS=$(( ($(date +%s) - $(git log -1 --format=%ct origin/$branch 2>/dev/null || echo 0)) / 86400 ))

              if [ "$BRANCH_AGE_DAYS" -gt 7 ]; then
                echo "üóëÔ∏è  Deleting orphaned branch (>7 days old, no PR): $branch"
                if gh api --method DELETE "/repos/${{ github.repository }}/git/refs/heads/$branch" 2>/dev/null; then
                  DELETED_COUNT=$((DELETED_COUNT + 1))
                else
                  echo "‚ö†Ô∏è  Failed to delete $branch"
                fi
              else
                echo "‚è≠Ô∏è  Keeping recent branch (no PR yet): $branch"
                KEPT_COUNT=$((KEPT_COUNT + 1))
              fi
            fi
          done <<< "$ALL_TDD_BRANCHES"

          echo ""
          echo "üìä Cleanup Summary:"
          echo "  - Deleted: $DELETED_COUNT branches"
          echo "  - Kept: $KEPT_COUNT branches"
          echo "‚úÖ Cleanup complete"

  # Job 8: Summary Report
  # Generates summary of monitoring actions
  summary:
    name: üìä Summary
    runs-on: ubuntu-latest
    needs: [health-check, stuck-spec-recovery, pr-monitoring, conflict-resolution, failed-pr-recovery, update-spec-state, branch-cleanup]
    if: always()
    timeout-minutes: 2

    steps:
      - name: Generate summary
        run: |
          echo "üìä TDD Monitor Summary"
          echo "===================="
          echo ""
          echo "üè• Health Check:"
          echo "   Failure rate: ${{ needs.health-check.outputs.failure_rate }}%"
          echo "   Circuit: ${{ needs.health-check.outputs.is_circuit_open == 'true' && 'OPEN (queue disabled)' || 'CLOSED (queue active)' }}"
          echo ""
          echo "üîß Failed PR Recovery:"
          echo "   Status: ${{ needs.failed-pr-recovery.result }}"
          echo ""
          echo "üìà Spec State Update:"
          echo "   Status: ${{ needs.update-spec-state.result }}"
          echo ""
          echo "üóëÔ∏è Branch Cleanup (Weekly):"
          echo "   Status: ${{ needs.branch-cleanup.result }}"
          echo ""
          echo "‚úÖ All monitoring jobs completed"
