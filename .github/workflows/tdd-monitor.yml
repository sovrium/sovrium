name: TDD - Monitor (Health & Recovery)

# Monitoring workflow that consolidates:
# - Circuit breaker (health monitoring)
# - Stuck spec recovery (timeout detection)
# - PR monitoring (auto-merge, stuck PRs)
# - Conflict resolution (merge conflicts)
# - Retry monitoring (stuck retries)
# - Failed PR recovery (regression fix retry)

on:
  # Event-driven triggers (immediate response)
  workflow_run:
    workflows: ['TDD - Execute (Claude Code)']
    types: [completed]
  push:
    branches:
      - main

  # Scheduled backup (every 30 min)
  schedule:
    - cron: '*/30 * * * *'

  # Manual trigger
  workflow_dispatch:
    inputs:
      force_recovery:
        description: 'Force recovery of all stuck specs'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

# Only one monitor run at a time - cancel queued runs to prevent pile-up
concurrency:
  group: tdd-monitor
  cancel-in-progress: true

env:
  STUCK_TIMEOUT_MINUTES: 90 # Specs stuck >90 min are recovered
  PR_STUCK_TIMEOUT_MINUTES: 120 # PRs stuck >120 min are force-closed
  RETRY_STUCK_TIMEOUT_MINUTES: 30 # Retries stuck >30 min are recovered
  FAILED_PR_COOLDOWN_MINUTES: 30 # Wait 30 min between regression fix attempts

jobs:
  # Job 1: Health Check & Circuit Breaker
  # Monitors overall pipeline health and disables queue on high failure rate
  health-check:
    name: üè• Health Check & Circuit Breaker
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      failure_rate: ${{ steps.analyze.outputs.failure_rate }}
      should_open_circuit: ${{ steps.analyze.outputs.should_open_circuit }}
      is_circuit_open: ${{ steps.circuit_status.outputs.is_open }}

    steps:
      - name: Analyze pipeline health
        id: analyze
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üìä Analyzing TDD pipeline health..."

          # Get last 10 workflow runs from tdd-execute.yml
          RECENT_RUNS=$(gh run list \
            --repo ${{ github.repository }} \
            --workflow="tdd-execute.yml" \
            --limit 10 \
            --json conclusion,createdAt,displayTitle)

          TOTAL=$(echo "$RECENT_RUNS" | jq 'length')
          FAILURES=$(echo "$RECENT_RUNS" | jq '[.[] | select(.conclusion == "failure" or .conclusion == "cancelled")] | length')

          # Count specs in retry state (both infrastructure and code retries)
          # Uses standardized label format: retry:infra:N and retry:spec:N
          INFRA_RETRY_1=$(gh issue list --repo ${{ github.repository }} --label "retry:infra:1" --json number --jq 'length')
          INFRA_RETRY_2=$(gh issue list --repo ${{ github.repository }} --label "retry:infra:2" --json number --jq 'length')
          INFRA_RETRY_3=$(gh issue list --repo ${{ github.repository }} --label "retry:infra:3" --json number --jq 'length')
          CODE_RETRY_1=$(gh issue list --repo ${{ github.repository }} --label "retry:spec:1" --json number --jq 'length')
          CODE_RETRY_2=$(gh issue list --repo ${{ github.repository }} --label "retry:spec:2" --json number --jq 'length')
          CODE_RETRY_3=$(gh issue list --repo ${{ github.repository }} --label "retry:spec:3" --json number --jq 'length')
          INFRA_RETRY_ISSUES=$((INFRA_RETRY_1 + INFRA_RETRY_2 + INFRA_RETRY_3))
          CODE_RETRY_ISSUES=$((CODE_RETRY_1 + CODE_RETRY_2 + CODE_RETRY_3))
          RETRY_ISSUES=$((INFRA_RETRY_ISSUES + CODE_RETRY_ISSUES))

          # Calculate failure rate
          if [ "$TOTAL" -eq 0 ]; then
            FAILURE_RATE=0
          else
            FAILURE_RATE=$((FAILURES * 100 / TOTAL))
          fi

          echo "üìà Health metrics:"
          echo "   Recent runs: $TOTAL"
          echo "   Failures: $FAILURES"
          echo "   Failure rate: ${FAILURE_RATE}%"
          echo "   Issues in retry: $RETRY_ISSUES (infra: $INFRA_RETRY_ISSUES, code: $CODE_RETRY_ISSUES)"

          # Output results
          echo "failure_rate=$FAILURE_RATE" >> $GITHUB_OUTPUT
          echo "failures=$FAILURES" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "retry_issues=$RETRY_ISSUES" >> $GITHUB_OUTPUT

          # Determine if circuit should open
          # Open if: >50% failure rate OR >5 issues in retry state
          if [ "$TOTAL" -ge 5 ] && [ "$FAILURE_RATE" -gt 50 ]; then
            echo "should_open_circuit=true" >> $GITHUB_OUTPUT
            echo "üö® THRESHOLD EXCEEDED: ${FAILURE_RATE}% failure rate"
          elif [ "$RETRY_ISSUES" -gt 5 ]; then
            echo "should_open_circuit=true" >> $GITHUB_OUTPUT
            echo "üö® THRESHOLD EXCEEDED: $RETRY_ISSUES issues in retry"
          else
            echo "should_open_circuit=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Health is acceptable"
          fi

      - name: Check circuit breaker status
        id: circuit_status
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Check if queue processor is disabled
          STATUS=$(gh workflow list \
            --repo ${{ github.repository }} \
            --all \
            --json name,state \
            --jq '.[] | select(.name == "TDD Queue - Processor") | .state')

          if [ "$STATUS" = "disabled_manually" ]; then
            echo "is_open=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Circuit breaker is OPEN (queue disabled)"
          else
            echo "is_open=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Circuit breaker is CLOSED (queue active)"
          fi

      - name: Open circuit breaker
        if: steps.analyze.outputs.should_open_circuit == 'true' && steps.circuit_status.outputs.is_open != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üö® Opening circuit breaker - disabling queue..."

          gh workflow disable "tdd-dispatch.yml" --repo ${{ github.repository }}

          # Create incident issue (ignore label errors if labels don't exist)
          gh issue create \
            --repo ${{ github.repository }} \
            --title "üö® TDD Circuit Breaker: High Failure Rate" \
            --body "## üö® Circuit Breaker Activated

          **Failure Rate**: ${{ steps.analyze.outputs.failure_rate }}%
          **Recent Runs**: ${{ steps.analyze.outputs.failures }}/${{ steps.analyze.outputs.total }} failed
          **Issues in Retry**: ${{ steps.analyze.outputs.retry_issues }}
          **Action**: Queue processor disabled

          ### Investigation
          1. Check recent runs: [tdd-execute.yml](https://github.com/${{ github.repository }}/actions/workflows/tdd-execute.yml)
          2. Check retry issues: \`gh issue list --label retry:infra:1\`
          3. Look for error patterns

          ### Recovery
          Once resolved:
          1. Re-enable queue: \`gh workflow enable tdd-dispatch.yml\`
          2. Close this issue

          ---
          *ü§ñ TDD Monitor*" \
            --label "tdd-automation" || true

      - name: Close circuit breaker
        if: steps.analyze.outputs.should_open_circuit == 'false' && steps.circuit_status.outputs.is_open == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "‚úÖ Health recovered - closing circuit breaker..."

          gh workflow enable "tdd-dispatch.yml" --repo ${{ github.repository }}

          # Close incident issues
          gh issue list \
            --repo ${{ github.repository }} \
            --label "incident" \
            --state open \
            --json number,title \
            --jq '.[] | select(.title | contains("TDD Circuit Breaker")) | .number' \
            | while read -r ISSUE; do
              gh issue comment "$ISSUE" --repo ${{ github.repository }} \
                --body "‚úÖ **Circuit Breaker Recovered**

          **Current Failure Rate**: ${{ steps.analyze.outputs.failure_rate }}%
          **Action**: Queue processor re-enabled

          Pipeline operating normally.

          ---
          *ü§ñ TDD Monitor*"

              gh issue close "$ISSUE" --repo ${{ github.repository }}
            done

  # Job 2: Stuck Spec Recovery
  # Finds specs stuck in-progress >90 min and re-queues or fails them
  stuck-spec-recovery:
    name: üîÑ Stuck Spec Recovery
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Find and recover stuck specs
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          TIMEOUT_MINUTES: ${{ env.STUCK_TIMEOUT_MINUTES }}
          FORCE_RECOVERY: ${{ github.event.inputs.force_recovery || 'false' }}
        run: |
          echo "üîç Looking for specs stuck >$TIMEOUT_MINUTES min..."

          ISSUES=$(gh issue list \
            --repo ${{ github.repository }} \
            --label "tdd-spec:in-progress" \
            --json number,title,updatedAt,labels \
            --limit 100)

          NOW=$(date +%s)
          TIMEOUT_SECONDS=$((TIMEOUT_MINUTES * 60))
          STUCK_COUNT=0

          # Use process substitution to avoid subshell variable scope issue
          while read -r issue; do
            [ -z "$issue" ] && continue

            ISSUE_NUMBER=$(echo "$issue" | jq -r '.number')
            TITLE=$(echo "$issue" | jq -r '.title')
            UPDATED_AT=$(echo "$issue" | jq -r '.updatedAt')
            LABELS=$(echo "$issue" | jq -r '.labels[].name' | tr '\n' ' ')

            UPDATED_EPOCH=$(date -d "$UPDATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$UPDATED_AT" +%s 2>/dev/null || echo "0")
            AGE=$((NOW - UPDATED_EPOCH))
            AGE_MIN=$((AGE / 60))

            # Skip if not stuck (or force recovery is enabled)
            if [ "$FORCE_RECOVERY" != "true" ] && [ "$AGE" -le "$TIMEOUT_SECONDS" ]; then
              continue
            fi

            echo ""
            echo "‚è±Ô∏è  STUCK: Issue #$ISSUE_NUMBER (${AGE_MIN} min old)"

            # Check if there's an open PR with failed tests linked to this issue
            # If so, skip re-queuing - let the failed-pr-recovery job handle it
            LINKED_PR=$(gh pr list \
              --repo ${{ github.repository }} \
              --label "tdd-automation" \
              --state open \
              --json number,body,statusCheckRollup \
              --jq ".[] | select(.body | test(\"Closes #$ISSUE_NUMBER(\\\\s|$)\"))" 2>/dev/null | head -1)

            if [ -n "$LINKED_PR" ]; then
              PR_NUM=$(echo "$LINKED_PR" | jq -r '.number')
              # Check if Test check failed
              TEST_FAILED=$(echo "$LINKED_PR" | jq -r '.statusCheckRollup[]? | select(.name == "Test" and .conclusion == "FAILURE") | .name' 2>/dev/null | head -1)

              if [ -n "$TEST_FAILED" ]; then
                echo "   ‚è≠Ô∏è  Skipping - PR #$PR_NUM exists with failed tests (handled by failed-pr-recovery)"
                continue
              fi
            fi

            STUCK_COUNT=$((STUCK_COUNT + 1))

            # Check for retry label (both infrastructure and code retries)
            # Uses standardized label format: retry:infra:N and retry:spec:N
            RETRY_LABEL=$(echo "$LABELS" | grep -oE 'retry:(spec|infra):[0-9]' || echo "")

            if [ -n "$RETRY_LABEL" ]; then
              RETRY_NUM=$(echo "$RETRY_LABEL" | sed -E 's/retry:(spec|infra)://')
              echo "   Stuck retry attempt #$RETRY_NUM (label: $RETRY_LABEL)"

              if [ "$RETRY_NUM" -ge 3 ]; then
                echo "   ‚ùå Max retries reached - marking as failed"
                gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                  --remove-label "tdd-spec:in-progress" \
                  --remove-label "$RETRY_LABEL" \
                  --add-label "tdd-spec:failed"

                gh issue comment "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                  --body "‚ùå **Max Retries Exhausted**

                Stuck in retry #$RETRY_NUM for $AGE_MIN minutes. Manual intervention required.

                ---
                *ü§ñ TDD Monitor*"
              else
                NEXT_RETRY=$((RETRY_NUM + 1))
                # Preserve retry type (spec vs infra) when incrementing
                RETRY_TYPE=$(echo "$RETRY_LABEL" | sed -E 's/retry:(spec|infra):.*/\1/')
                echo "   üîÑ Triggering retry #$NEXT_RETRY (type: $RETRY_TYPE)"

                gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                  --remove-label "$RETRY_LABEL" \
                  --add-label "retry:${RETRY_TYPE}:$NEXT_RETRY"

                # Get spec details from issue for context
                SPEC_ID=$(gh issue view "$ISSUE_NUMBER" --repo ${{ github.repository }} --json title --jq '.title' | grep -oE '[A-Z]+-[A-Z]+-[0-9]+' || echo "unknown")
                TEST_FILE=$(gh issue view "$ISSUE_NUMBER" --repo ${{ github.repository }} --json body --jq '.body' | grep -oE 'Test File[^`]*`[^`]+' | sed 's/.*`//' || echo "unknown")

                gh issue comment "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                  --body "üîÑ **Stuck Retry Recovery** (Attempt $NEXT_RETRY of 3)

                Previous attempt stuck for $AGE_MIN minutes. Restarting implementation.

                @claude retry implementation for this spec

                ## üìã Context
                - **Spec ID**: \`$SPEC_ID\`
                - **Test File**: \`$TEST_FILE\`
                - **Issue**: #$ISSUE_NUMBER
                - **Retry Attempt**: $NEXT_RETRY of 3
                - **Previous Failure**: Infrastructure timeout (not code issue)

                ## ü§ñ Automation Mode
                - ‚úÖ Make autonomous decisions - proceed with best judgment
                - ‚ùå DO NOT ask questions

                ## ‚úÖ Instructions

                1. **Check current state**: Run \`git status\` to see if previous work exists
                2. **If branch has changes**: Continue from where it left off
                3. **If no changes**: Start fresh using e2e-test-fixer agent (\`Task\` tool with \`subagent_type='e2e-test-fixer'\`)
                4. **Run codebase-refactor-auditor**: Use \`Task\` tool with \`subagent_type='codebase-refactor-auditor'\` (MANDATORY)
                5. **Verify quality**: Run \`bun run quality\` - all checks must pass
                6. **Commit**: \`fix: implement $SPEC_ID\`
                7. **Create PR**: \`gh pr create --title \"fix: implement $SPEC_ID\" --body \"Closes #$ISSUE_NUMBER\" --label \"tdd-automation\"\`
                8. **Enable auto-merge**: \`gh pr merge \$PR_NUMBER --auto --squash\`
                9. **Verify auto-merge**: \`gh pr view \$PR_NUMBER --json autoMergeRequest\`

                **Reference**: \`@docs/development/tdd-automation-pipeline.md\`

                ---
                *ü§ñ TDD Monitor*"
              fi
            else
              echo "   üìã Re-queueing stuck spec"
              gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:queued"

              gh issue comment "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                --body "‚è±Ô∏è  **Timeout Recovery**

              Stuck for $AGE_MIN min. Re-queued for retry.

              ---
              *ü§ñ TDD Monitor*"
            fi
          done < <(echo "$ISSUES" | jq -r '.[] | @json')

          if [ "$STUCK_COUNT" -gt 0 ]; then
            echo ""
            echo "‚úÖ Recovered $STUCK_COUNT stuck spec(s)"
          else
            echo "‚úÖ No stuck specs found"
          fi

  # Job 3: PR Monitoring
  # Monitors PRs for missing auto-merge and stuck validation
  pr-monitoring:
    name: üìã PR Monitoring
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Monitor PRs for auto-merge
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "üîç Checking PRs for missing auto-merge..."

          PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,title,autoMergeRequest,createdAt,mergeable \
            --limit 50)

          NOW=$(date +%s)
          FIXED_COUNT=0

          # Use process substitution to avoid subshell variable scope issue
          while read -r pr; do
            [ -z "$pr" ] && continue

            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            TITLE=$(echo "$pr" | jq -r '.title')
            AUTO_MERGE=$(echo "$pr" | jq -r '.autoMergeRequest')
            CREATED_AT=$(echo "$pr" | jq -r '.createdAt')
            MERGEABLE=$(echo "$pr" | jq -r '.mergeable')

            if [ "$AUTO_MERGE" = "null" ] || [ -z "$AUTO_MERGE" ]; then
              CREATED_EPOCH=$(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s 2>/dev/null || echo "$NOW")
              AGE_MIN=$(( (NOW - CREATED_EPOCH) / 60 ))

              # Only enable auto-merge if PR is >5 min old (give CI time to start)
              if [ "$AGE_MIN" -ge 5 ]; then
                echo ""
                echo "‚ö†Ô∏è  PR #$PR_NUMBER missing auto-merge (${AGE_MIN}m old)"
                echo "   Enabling auto-merge..."

                # Try to enable auto-merge
                if gh pr merge "$PR_NUMBER" --repo ${{ github.repository }} --auto --squash 2>/dev/null; then
                  # Verify it was enabled
                  sleep 2
                  VERIFY=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json autoMergeRequest --jq '.autoMergeRequest')

                  if [ "$VERIFY" != "null" ]; then
                    echo "   ‚úÖ Auto-merge enabled"
                    FIXED_COUNT=$((FIXED_COUNT + 1))

                    gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                      --body "üîß **Auto-merge enabled**

                    Detected missing auto-merge after $AGE_MIN minutes.

                    PR will merge automatically when CI passes.

                    ---
                    *ü§ñ TDD Monitor*"
                  else
                    echo "   ‚ö†Ô∏è  Auto-merge command succeeded but not enabled (may not be mergeable)"
                  fi
                else
                  echo "   ‚ö†Ô∏è  Could not enable auto-merge (PR may not be mergeable)"
                fi
              fi
            fi
          done < <(echo "$PRS" | jq -r '.[] | @json')

          if [ "$FIXED_COUNT" -gt 0 ]; then
            echo ""
            echo "‚úÖ Enabled auto-merge on $FIXED_COUNT PR(s)"
          else
            echo "‚úÖ All PRs have auto-merge enabled"
          fi

      - name: Update outdated PR branches
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "üîç Checking for PRs with outdated branches..."

          PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,title,headRefName,mergeable,mergeStateStatus,baseRefName \
            --limit 50)

          UPDATED_COUNT=0
          SKIPPED_COUNT=0
          NOW=$(date +%s)
          # Only post update comment if no similar comment in last 2 hours
          COOLDOWN_SECONDS=7200

          # Use process substitution to avoid subshell variable scope issue
          while read -r pr; do
            [ -z "$pr" ] && continue

            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            HEAD_REF=$(echo "$pr" | jq -r '.headRefName')
            MERGEABLE=$(echo "$pr" | jq -r '.mergeable')
            MERGE_STATE=$(echo "$pr" | jq -r '.mergeStateStatus')

            # Check if branch is behind (but not conflicted)
            if [ "$MERGE_STATE" = "BEHIND" ] || [ "$MERGEABLE" = "UNKNOWN" ]; then
              echo ""
              echo "‚ö†Ô∏è  PR #$PR_NUMBER branch is behind main"

              # Check for recent "@claude update" comment to prevent spam
              # Use broader substring match to catch any update-related @claude mentions
              RECENT_UPDATE_COMMENT=$(gh api \
                "/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
                --jq "[.[] | select(.body | contains(\"@claude update\")) | select(.created_at > \"$(date -u -d '2 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-2H +%Y-%m-%dT%H:%M:%SZ)\")] | length" 2>/dev/null || echo "0")

              if [ "$RECENT_UPDATE_COMMENT" -gt 0 ]; then
                echo "   ‚è≠Ô∏è  Skipping - update already requested within last 2 hours"
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
                continue
              fi

              echo "   Triggering branch update..."

              # Post @claude comment to update branch
              gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                --body "@claude update this PR branch to include latest main changes

              ## üìã Context
              - **PR**: #$PR_NUMBER
              - **Branch**: \`$HEAD_REF\`
              - **Status**: Branch is behind main and needs to be updated

              ## ü§ñ Automation Mode
              - ‚úÖ Make autonomous decisions - proceed with best judgment
              - ‚ùå DO NOT ask questions

              ## ‚úÖ Instructions

              1. **Fetch latest main**:
                 \`\`\`bash
                 git fetch origin main:main
                 \`\`\`

              2. **Checkout PR branch and merge main**:
                 \`\`\`bash
                 git checkout $HEAD_REF
                 git merge origin/main
                 \`\`\`

              3. **If merge conflicts occur**:
                 - Resolve conflicts (prioritize incoming changes from main for config files)
                 - For code conflicts, keep both implementations if safe, otherwise prefer main
                 - Run \`bun run quality\` to verify resolution is correct

              4. **Push updated branch**:
                 \`\`\`bash
                 git push
                 \`\`\`

              5. **Verify auto-merge still enabled**:
                 \`\`\`bash
                 gh pr view $PR_NUMBER --json autoMergeRequest
                 \`\`\`
                 If autoMergeRequest is null, re-enable: \`gh pr merge $PR_NUMBER --auto --squash\`

              ## ‚ö†Ô∏è Error Handling
              - **If conflicts cannot be resolved automatically**: Add comment explaining the conflict and add label \`needs-manual-resolution\`
              - **If quality checks fail after merge**: Fix the issues before pushing

              Auto-merge will proceed once branch is updated and CI passes.

              ---
              *ü§ñ TDD Monitor*"

              UPDATED_COUNT=$((UPDATED_COUNT + 1))
            fi
          done < <(echo "$PRS" | jq -r '.[] | @json')

          if [ "$UPDATED_COUNT" -gt 0 ]; then
            echo ""
            echo "‚úÖ Triggered branch update for $UPDATED_COUNT PR(s)"
          fi
          if [ "$SKIPPED_COUNT" -gt 0 ]; then
            echo "‚è≠Ô∏è  Skipped $SKIPPED_COUNT PR(s) (update already requested recently)"
          fi
          if [ "$UPDATED_COUNT" -eq 0 ] && [ "$SKIPPED_COUNT" -eq 0 ]; then
            echo "‚úÖ All PR branches are up-to-date"
          fi

      - name: Detect stuck PRs
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          STUCK_TIMEOUT: ${{ env.PR_STUCK_TIMEOUT_MINUTES }}
        run: |
          echo "üîç Checking for PRs stuck in validation..."

          PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,title,createdAt,statusCheckRollup \
            --limit 50)

          NOW=$(date +%s)
          STUCK_COUNT=0

          # Use process substitution to avoid subshell variable scope issue
          while read -r pr; do
            [ -z "$pr" ] && continue

            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            CREATED_AT=$(echo "$pr" | jq -r '.createdAt')

            CREATED_EPOCH=$(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s 2>/dev/null || echo "$NOW")
            AGE_MIN=$(( (NOW - CREATED_EPOCH) / 60 ))

            # Check if stuck (>120 min old)
            if [ "$AGE_MIN" -ge "$STUCK_TIMEOUT" ]; then
              echo ""
              echo "‚ö†Ô∏è  PR #$PR_NUMBER stuck for ${AGE_MIN}m"

              # Check if perpetually failing
              CHECKS=$(echo "$pr" | jq -r '.statusCheckRollup')
              FAILURES=$(echo "$CHECKS" | jq '[.[] | select(.conclusion == "FAILURE")] | length' 2>/dev/null || echo "0")

              if [ "$FAILURES" -gt 3 ]; then
                echo "   ‚ùå Perpetual failures detected - force closing"
                STUCK_COUNT=$((STUCK_COUNT + 1))

                # Get linked issue
                ISSUE_NUMBER=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json body --jq '.body' | grep -oP 'Closes #\K\d+' | head -1)

                gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                  --body "‚ùå **PR Force-Closed: Perpetual Failures**

                PR stuck for ${AGE_MIN} minutes with multiple CI failures.

                Marking spec as failed. Manual intervention required.

                ---
                *ü§ñ TDD Monitor*"

                gh pr close "$PR_NUMBER" --repo ${{ github.repository }}

                if [ -n "$ISSUE_NUMBER" ]; then
                  gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                    --remove-label "tdd-spec:in-progress" \
                    --add-label "tdd-spec:failed"
                fi
              else
                echo "   ‚ö†Ô∏è  PR stuck but checks still running - monitoring"
              fi
            fi
          done < <(echo "$PRS" | jq -r '.[] | @json')

          if [ "$STUCK_COUNT" -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è  Force-closed $STUCK_COUNT stuck PR(s)"
          fi

  # Job 4: Conflict Resolution
  # Detects and resolves merge conflicts automatically
  conflict-resolution:
    name: üîÄ Conflict Resolution
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'push' || github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Find and resolve conflicts
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "üîç Scanning for conflicted PRs..."

          CONFLICTED=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,mergeable,mergeStateStatus,headRefName,labels \
            --jq '.[] | select(.mergeable == "CONFLICTING" or .mergeStateStatus == "DIRTY")')

          if [ -z "$CONFLICTED" ]; then
            echo "‚úÖ No conflicted PRs found"
            exit 0
          fi

          echo "$CONFLICTED" | jq -r '.number' | while read -r PR_NUMBER; do
            echo ""
            echo "‚ö†Ô∏è  PR #$PR_NUMBER has conflicts"

            # Check if already attempted resolution
            HAS_RETRY=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json labels --jq '.labels[].name' | grep "conflict-resolution:attempted" || echo "")

            if [ -n "$HAS_RETRY" ]; then
              echo "   Already attempted - marking for manual review"

              gh pr edit "$PR_NUMBER" --repo ${{ github.repository }} \
                --add-label "needs-manual-resolution"

              gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                --body "ü§ñ **Manual Resolution Required**

              Automatic conflict resolution failed. Please resolve manually:

              1. \`git fetch origin main:main\`
              2. \`git checkout [branch] && git rebase origin/main\`
              3. Resolve conflicts
              4. \`git push --force-with-lease\`

              ---
              *ü§ñ TDD Monitor*"
            else
              echo "   Triggering automatic resolution"

              gh pr edit "$PR_NUMBER" --repo ${{ github.repository }} \
                --add-label "conflict-resolution:attempted"

              HEAD_REF=$(gh pr view "$PR_NUMBER" --repo ${{ github.repository }} --json headRefName --jq '.headRefName')

              gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                --body "@claude resolve merge conflicts in this PR

              ## üìã Context
              - **PR**: #$PR_NUMBER
              - **Branch**: \`$HEAD_REF\`
              - **Status**: Has merge conflicts that need resolution

              ## ü§ñ Automation Mode
              - ‚úÖ Make autonomous decisions - proceed with best judgment
              - ‚ùå DO NOT ask questions
              - ‚ö†Ô∏è This is the FIRST automatic resolution attempt

              ## ‚úÖ Instructions

              1. **Fetch latest main**:
                 \`\`\`bash
                 git fetch origin main:main
                 \`\`\`

              2. **Checkout branch and rebase on main**:
                 \`\`\`bash
                 git checkout $HEAD_REF
                 git rebase origin/main
                 \`\`\`

              3. **Resolve conflicts with these priorities**:
                 - **Config files** (package.json, tsconfig.json, etc.): Accept incoming (main) version
                 - **Source code** (src/): Keep both implementations if compatible, otherwise prefer main
                 - **Test files** (specs/): Keep both test cases, merge test logic carefully
                 - **Generated files** (SPEC-STATE.md, etc.): Accept incoming (main) version

              4. **Verify resolution is correct**:
                 \`\`\`bash
                 bun run quality
                 \`\`\`
                 ALL checks must pass (ESLint, TypeScript, Effect diagnostics, unit tests, E2E regression)

              5. **Push resolved changes**:
                 \`\`\`bash
                 git push --force-with-lease
                 \`\`\`

              6. **Re-enable auto-merge**:
                 \`\`\`bash
                 gh pr merge $PR_NUMBER --auto --squash
                 \`\`\`

              7. **Verify auto-merge enabled**:
                 \`\`\`bash
                 gh pr view $PR_NUMBER --json autoMergeRequest
                 \`\`\`

              ## ‚ö†Ô∏è Error Handling

              - **If rebase fails with complex conflicts**: Try merge instead: \`git merge origin/main\`
              - **If quality checks fail after resolution**: Fix the failing checks before pushing
              - **If automatic resolution is not possible**:
                1. Add comment explaining which files have irresolvable conflicts
                2. Add label \`needs-manual-resolution\`
                3. Do NOT push broken code

              ---
              *ü§ñ TDD Monitor*"
            fi
          done

  # Job 5: Failed PR Recovery
  # Detects TDD PRs with failed CI and triggers Claude to fix regressions
  failed-pr-recovery:
    name: üîß Failed PR Recovery
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Find and recover PRs with failed CI
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          COOLDOWN_MINUTES: ${{ env.FAILED_PR_COOLDOWN_MINUTES }}
        run: |
          echo "üîç Looking for TDD PRs with failed CI..."

          PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --label "tdd-automation" \
            --state open \
            --json number,title,headRefName,statusCheckRollup,labels,body \
            --limit 50)

          RECOVERED_COUNT=0
          ESCALATED_COUNT=0

          # Pre-calculate cooldown cutoff time (fixes variable expansion in jq)
          CUTOFF_TIME=$(date -u -d "${COOLDOWN_MINUTES} minutes ago" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-${COOLDOWN_MINUTES}M +%Y-%m-%dT%H:%M:%SZ)

          # Use process substitution to avoid subshell variable scope issue
          while read -r pr; do
            [ -z "$pr" ] && continue

            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            HEAD_REF=$(echo "$pr" | jq -r '.headRefName')
            LABELS=$(echo "$pr" | jq -r '.labels[].name' | tr '\n' ' ')
            BODY=$(echo "$pr" | jq -r '.body')

            # Extract linked issue number from PR body
            ISSUE_NUMBER=$(echo "$BODY" | grep -oE 'Closes #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")

            # Check if any Test* check failed (matches "Test", "Test E2E", etc.)
            TEST_FAILED=$(echo "$pr" | jq -r '.statusCheckRollup[]? | select(.name | startswith("Test")) | select(.conclusion == "FAILURE") | .name' 2>/dev/null | head -1)

            if [ -z "$TEST_FAILED" ]; then
              continue
            fi

            echo ""
            echo "‚ö†Ô∏è  PR #$PR_NUMBER has failed CI (check: $TEST_FAILED)"

            # Skip if already marked for manual resolution
            if echo "$LABELS" | grep -q "needs-manual-resolution"; then
              echo "   ‚è≠Ô∏è  Skipping - already marked for manual resolution"
              continue
            fi

            # Check for recent fix comments (cooldown period)
            # Matches both this job's comments AND test.yml's handle-regressions comments
            RECENT_FIX_COMMENT=$(gh api \
              "/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
              --jq "[.[] | select(.body | contains(\"Failed PR Recovery\") or contains(\"Regression Detected - Auto-Fix Required\")) | select(.created_at > \"${CUTOFF_TIME}\")] | length" 2>/dev/null || echo "0")

            if [ "$RECENT_FIX_COMMENT" -gt 0 ]; then
              echo "   ‚è≠Ô∏è  Skipping - fix already triggered within last ${COOLDOWN_MINUTES} minutes"
              continue
            fi

            # Count total fix attempts (by counting "Failed PR Recovery" comments)
            FIX_ATTEMPTS=$(gh api \
              "/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
              --jq "[.[] | select(.body | contains(\"Failed PR Recovery\"))] | length" 2>/dev/null || echo "0")

            if [ "$FIX_ATTEMPTS" -ge 3 ]; then
              echo "   ‚ùå Max fix attempts (3) reached - marking for manual resolution"
              ESCALATED_COUNT=$((ESCALATED_COUNT + 1))

              gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                --body "‚ùå **Max Regression Fix Attempts Exhausted**

              This PR has failed to fix regressions after 3 automated attempts.

              **Manual intervention required**:
              1. Review the [test failures](https://github.com/${{ github.repository }}/actions)
              2. Analyze the root cause of the regression
              3. Fix the issue manually or close the PR

              **Common causes**:
              - Greedy catch-all schemas that match valid field types
              - Validation logic changes that are too permissive
              - Type changes that break dependent code

              ---
              *ü§ñ TDD Monitor*"

              gh pr edit "$PR_NUMBER" --repo ${{ github.repository }} \
                --add-label "needs-manual-resolution"

              # Also update the linked issue
              if [ -n "$ISSUE_NUMBER" ]; then
                gh issue edit "$ISSUE_NUMBER" --repo ${{ github.repository }} \
                  --remove-label "tdd-spec:in-progress" \
                  --add-label "tdd-spec:failed" 2>/dev/null || true
              else
                echo "   ‚ö†Ô∏è  No linked issue found - cannot update issue state"
              fi
            else
              NEXT_ATTEMPT=$((FIX_ATTEMPTS + 1))
              echo "   üîÑ Triggering regression fix attempt $NEXT_ATTEMPT of 3"
              RECOVERED_COUNT=$((RECOVERED_COUNT + 1))

              gh pr comment "$PR_NUMBER" --repo ${{ github.repository }} \
                --body "## üîß Failed PR Recovery (Attempt $NEXT_ATTEMPT of 3)

              @claude The CI tests are failing. Please fix the regressions.

              ### ü§ñ Automation Mode
              - ‚úÖ Make autonomous decisions - proceed with best judgment
              - ‚ùå DO NOT ask questions

              ### ‚úÖ Instructions

              1. **Pull latest and check test failures**:
                 \`\`\`bash
                 git fetch origin $HEAD_REF
                 git checkout $HEAD_REF
                 bun test:e2e:regression
                 \`\`\`

              2. **Identify the regression cause**:
                 - Look at which tests are failing (may be different from target spec)
                 - Check what your changes may have affected
                 - Common issue: catch-all schemas that are too greedy

              3. **Fix without modifying the failing tests**:
                 - Preserve existing validation behavior
                 - For catch-all schemas: explicitly EXCLUDE known types
                 - Example fix for UnknownFieldSchema:
                   \`\`\`typescript
                   // BAD: catches all types including valid ones
                   type: Schema.String

                   // GOOD: only catches truly unknown types
                   type: Schema.String.pipe(
                     Schema.filter((t) => !KNOWN_FIELD_TYPES.includes(t))
                   )
                   \`\`\`

              4. **Verify all tests pass**:
                 \`\`\`bash
                 bun run quality
                 bun test:e2e:regression
                 \`\`\`

              5. **Push the fix**:
                 \`\`\`bash
                 bun run license
                 git add -A
                 git commit -m \"fix: resolve regression\"
                 git push
                 \`\`\`

              6. **Re-enable auto-merge** (if disabled):
                 \`\`\`bash
                 gh pr merge $PR_NUMBER --auto --squash
                 \`\`\`

              ---
              *ü§ñ TDD Monitor*"
            fi
          done < <(echo "$PRS" | jq -r '.[] | @json')

          if [ "$RECOVERED_COUNT" -gt 0 ]; then
            echo ""
            echo "‚úÖ Triggered fix for $RECOVERED_COUNT PR(s)"
          fi
          if [ "$ESCALATED_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è  Escalated $ESCALATED_COUNT PR(s) for manual resolution"
          fi
          if [ "$RECOVERED_COUNT" -eq 0 ] && [ "$ESCALATED_COUNT" -eq 0 ]; then
            echo "‚úÖ No PRs with failed CI need recovery"
          fi

  # Job 6: Update Spec State
  # Runs analyze:specs and commits SPEC-STATE.md after successful test implementation
  update-spec-state:
    name: üìà Update Spec State
    runs-on: ubuntu-latest
    timeout-minutes: 10
    # Only run on push to main (when TDD PRs are merged)
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.3.3'

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run spec analysis
        run: |
          echo "üìä Running spec analysis..."
          bun run analyze:specs --no-error || true

      - name: Check for changes
        id: changes
        run: |
          # Check both files that analyze-specs.ts may update
          SPEC_CHANGED=false
          README_CHANGED=false

          if ! git diff --quiet SPEC-STATE.md 2>/dev/null; then
            SPEC_CHANGED=true
            echo "üìù SPEC-STATE.md has changes"
          fi

          if ! git diff --quiet README.md 2>/dev/null; then
            README_CHANGED=true
            echo "üìù README.md has changes (badges updated)"
          fi

          if [ "$SPEC_CHANGED" = "true" ] || [ "$README_CHANGED" = "true" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No changes to SPEC-STATE.md or README.md"
          fi

      - name: Commit and push changes
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Add both files (git add only stages if file has changes)
          git add SPEC-STATE.md README.md
          git commit -m "chore: update SPEC-STATE.md [skip ci]

          ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

          Co-Authored-By: Claude <noreply@anthropic.com>"

          git push

          echo "‚úÖ SPEC-STATE.md and README.md committed and pushed"

  # Job 7: Summary Report
  # Generates summary of monitoring actions
  summary:
    name: üìä Summary
    runs-on: ubuntu-latest
    needs: [health-check, stuck-spec-recovery, pr-monitoring, conflict-resolution, failed-pr-recovery, update-spec-state]
    if: always()
    timeout-minutes: 2

    steps:
      - name: Generate summary
        run: |
          echo "üìä TDD Monitor Summary"
          echo "===================="
          echo ""
          echo "üè• Health Check:"
          echo "   Failure rate: ${{ needs.health-check.outputs.failure_rate }}%"
          echo "   Circuit: ${{ needs.health-check.outputs.is_circuit_open == 'true' && 'OPEN (queue disabled)' || 'CLOSED (queue active)' }}"
          echo ""
          echo "üîß Failed PR Recovery:"
          echo "   Status: ${{ needs.failed-pr-recovery.result }}"
          echo ""
          echo "üìà Spec State Update:"
          echo "   Status: ${{ needs.update-spec-state.result }}"
          echo ""
          echo "‚úÖ All monitoring jobs completed"
