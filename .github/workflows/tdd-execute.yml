name: TDD - Execute (Claude Code)

# This workflow handles all Claude Code execution with infrastructure-level retry logic
# It handles both automated queue processing and manual @claude mentions
# Infrastructure errors (EPERM, timeouts, crashes) are automatically retried up to 3 times

on:
  # Manual trigger: Process specific issue number with optional retry
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process'
        required: true
        type: number
      retry_attempt:
        description: 'Current retry attempt (1-3)'
        required: false
        type: number
        default: 1

  # Manual triggers: @claude mentions in issues/PRs (interactive use)
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

# Concurrency control: One run per issue/PR, QUEUE don't cancel
# Groups runs by issue/PR number to prevent duplicate execution
# cancel-in-progress: false preserves work-in-progress (Claude can run 60+ min)
# Duplicate PRs prevented via application-level checks (pre-PR validation in CLAUDE.md)
# Note: claude[bot] comments are filtered in validate-context job (lines 80-98)
concurrency:
  group: claude-issue-${{ github.event.issue.number || github.event.pull_request.number || github.event.inputs.issue_number || 'default' }}
  cancel-in-progress: false

env:
  MAX_INFRASTRUCTURE_RETRIES: 3
  CLAUDE_TIMEOUT_MINUTES: 90

jobs:
  # Pre-check job: Validate context exists before running Claude Code
  # Prevents wasted resources when there's no spec to process
  validate-context:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      issues: read
    outputs:
      has_context: ${{ steps.check.outputs.has_context }}
      issue_number: ${{ steps.check.outputs.issue_number }}
      issue_body: ${{ steps.check.outputs.issue_body }}
    steps:
      - name: Check for valid context
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
          # Security: Use env vars for untrusted user input to prevent code injection
          EVENT_COMMENT_BODY: ${{ github.event.comment.body }}
          EVENT_ISSUE_BODY: ${{ github.event.issue.body }}
          EVENT_ISSUE_TITLE: ${{ github.event.issue.title }}
          EVENT_REVIEW_BODY: ${{ github.event.review.body }}
          COMMENT_USER: ${{ github.event.comment.user.login }}
        run: |
          HAS_CONTEXT="false"
          ISSUE_NUMBER=""
          ISSUE_BODY=""

          # Skip if comment is from Claude bot (prevents race condition with error comments)
          # Also skip "Claude Code is working" status comments (prevents self-cancellation)
          if [ "${{ github.event_name }}" = "issue_comment" ]; then
            if [ "$COMMENT_USER" = "claude[bot]" ]; then
              echo "‚ö†Ô∏è  Comment from Claude bot - skipping to prevent cancellation race"
              echo "has_context=false" >> $GITHUB_OUTPUT
              echo "issue_number=" >> $GITHUB_OUTPUT
              echo "issue_body<<EOF" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 0
            elif [[ "$EVENT_COMMENT_BODY" == *"Claude Code is working"* ]]; then
              echo "‚ö†Ô∏è  Claude Code status comment - skipping to prevent self-cancellation"
              echo "has_context=false" >> $GITHUB_OUTPUT
              echo "issue_number=" >> $GITHUB_OUTPUT
              echo "issue_body<<EOF" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # workflow_dispatch: Must have valid issue number
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ISSUE_NUMBER="${{ github.event.inputs.issue_number }}"
            if [ -n "$ISSUE_NUMBER" ]; then
              echo "üîç Validating issue #$ISSUE_NUMBER (workflow_dispatch trigger)..."
              if gh issue view "$ISSUE_NUMBER" &>/dev/null; then
                ISSUE_BODY=$(gh issue view "$ISSUE_NUMBER" --json body --jq '.body')
                HAS_CONTEXT="true"
                echo "‚úÖ Valid issue found: #$ISSUE_NUMBER"
              else
                echo "‚ùå Issue #$ISSUE_NUMBER not found - skipping workflow"
              fi
            else
              echo "‚ùå No issue number provided - skipping workflow"
            fi

          # issue_comment/PR review: Must have @claude mention and valid issue/PR
          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            if [[ "$EVENT_COMMENT_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.issue.number }}"
              ISSUE_BODY="$EVENT_ISSUE_BODY"
              HAS_CONTEXT="true"
              echo "‚úÖ Valid @claude mention in issue #$ISSUE_NUMBER"
            else
              echo "‚ö†Ô∏è  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
            if [[ "$EVENT_COMMENT_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.pull_request.number }}"
              HAS_CONTEXT="true"
              echo "‚úÖ Valid @claude mention in PR #$ISSUE_NUMBER"
            else
              echo "‚ö†Ô∏è  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "pull_request_review" ]; then
            if [[ "$EVENT_REVIEW_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.pull_request.number }}"
              HAS_CONTEXT="true"
              echo "‚úÖ Valid @claude mention in PR review #$ISSUE_NUMBER"
            else
              echo "‚ö†Ô∏è  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "issues" ]; then
            if [[ "$EVENT_ISSUE_BODY" == *"@claude"* ]] || [[ "$EVENT_ISSUE_TITLE" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.issue.number }}"
              ISSUE_BODY="$EVENT_ISSUE_BODY"
              HAS_CONTEXT="true"
              echo "‚úÖ Valid @claude mention in issue #$ISSUE_NUMBER"
            else
              echo "‚ö†Ô∏è  No @claude mention found - skipping workflow"
            fi
          fi

          # Additional validation: Check if issue is closed or has existing PRs
          if [ "$HAS_CONTEXT" = "true" ] && [ -n "$ISSUE_NUMBER" ]; then
            echo ""
            echo "üîç Checking issue state and existing PRs for #$ISSUE_NUMBER..."

            # Check if issue is closed
            ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")

            if [ "$ISSUE_STATE" = "CLOSED" ]; then
              echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER is CLOSED - skipping to prevent duplicate PR"
              echo "   A PR has already been merged or the issue was closed manually"
              HAS_CONTEXT="false"
              ISSUE_NUMBER=""
              ISSUE_BODY=""
            else
              # Check for any existing PR (open or closed) for this issue
              EXISTING_PR_COUNT=$(gh pr list \
                --repo ${{ github.repository }} \
                --search "Closes #$ISSUE_NUMBER in:body" \
                --state all \
                --json number \
                --jq 'length' 2>/dev/null || echo "0")

              if [ "$EXISTING_PR_COUNT" -gt 0 ]; then
                EXISTING_PRS=$(gh pr list \
                  --repo ${{ github.repository }} \
                  --search "Closes #$ISSUE_NUMBER in:body" \
                  --state all \
                  --json number,state \
                  --jq '[.[] | "#\(.number) (\(.state))"] | join(", ")' 2>/dev/null || echo "")

                echo "‚ö†Ô∏è  Found $EXISTING_PR_COUNT existing PR(s) for issue #$ISSUE_NUMBER: $EXISTING_PRS"
                echo "   Skipping to prevent duplicate PR creation"
                echo "   If you need to retry, close/delete the existing PR first"

                # Post comment on issue explaining why we're skipping
                COMMENT_BODY="ü§ñ **Duplicate PR Prevention**

                Skipping Claude Code execution because PR(s) already exist for this issue: $EXISTING_PRS

                **To retry this spec:**
                1. Close or delete the existing PR if it's invalid
                2. Re-open this issue if it was closed
                3. Post a new @claude comment to trigger the workflow

                ---
                *ü§ñ Automated via Claude TDD Workflow*"

                gh issue comment "$ISSUE_NUMBER" --body "$COMMENT_BODY" 2>/dev/null || true

                HAS_CONTEXT="false"
                ISSUE_NUMBER=""
                ISSUE_BODY=""
              else
                echo "‚úÖ Issue is open with no existing PRs - safe to proceed"
              fi
            fi
          fi

          # Output results
          echo "has_context=$HAS_CONTEXT" >> $GITHUB_OUTPUT
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Log concurrency group status for debugging workflow trigger issues
      # This helps diagnose cases where @claude comments don't trigger Claude Code
      - name: Log concurrency group status
        if: steps.check.outputs.has_context == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
        run: |
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üîÑ CONCURRENCY GROUP DEBUG INFO"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

          CONCURRENCY_GROUP="claude-issue-$ISSUE_NUMBER"
          echo "üìã Concurrency Group: $CONCURRENCY_GROUP"
          echo "üìÖ Triggered at: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "üéØ Event: ${{ github.event_name }}"
          echo "üë§ Sender: ${{ github.event.sender.login }}"

          # Check for other running workflows in the same concurrency group
          echo ""
          echo "üîç Checking for other running workflows for issue #$ISSUE_NUMBER..."

          RUNNING_WORKFLOWS=$(gh run list \
            --workflow="TDD - Execute (Claude Code)" \
            --status=in_progress \
            --json databaseId,displayTitle,createdAt,event \
            --jq "[.[] | select(.displayTitle | contains(\"#$ISSUE_NUMBER\"))]" 2>/dev/null || echo "[]")

          RUNNING_COUNT=$(echo "$RUNNING_WORKFLOWS" | jq 'length' 2>/dev/null || echo "0")

          if [ "$RUNNING_COUNT" -gt 1 ]; then
            echo "‚ö†Ô∏è  WARNING: $RUNNING_COUNT workflows running for this issue!"
            echo "   This run may be queued due to concurrency group"
            echo ""
            echo "   Running workflows:"
            echo "$RUNNING_WORKFLOWS" | jq -r '.[] | "   - Run \(.databaseId) started \(.createdAt) via \(.event)"'
          elif [ "$RUNNING_COUNT" -eq 1 ]; then
            echo "‚úÖ This is the only running workflow for issue #$ISSUE_NUMBER"
          else
            echo "‚ÑπÔ∏è  No in-progress workflows found (this workflow is still starting)"
          fi

          # Check for queued workflows
          QUEUED_WORKFLOWS=$(gh run list \
            --workflow="TDD - Execute (Claude Code)" \
            --status=queued \
            --json databaseId,displayTitle,createdAt \
            --jq "[.[] | select(.displayTitle | contains(\"#$ISSUE_NUMBER\"))] | length" 2>/dev/null || echo "0")

          if [ "$QUEUED_WORKFLOWS" -gt 0 ]; then
            echo ""
            echo "üì• $QUEUED_WORKFLOWS workflow(s) queued for this issue"
            echo "   These will run after current workflow completes"
          fi

          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

  # Error classification: Determine if error is retriable at infrastructure level
  classify-previous-error:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.retry_attempt > 1
    permissions:
      actions: read
    outputs:
      is_infrastructure_error: ${{ steps.classify.outputs.is_infrastructure_error }}
      error_type: ${{ steps.classify.outputs.error_type }}
      should_retry: ${{ steps.classify.outputs.should_retry }}
    steps:
      - name: Classify previous run error
        id: classify
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
        run: |
          echo "üîç Analyzing previous workflow run for error classification..."

          # Get the most recent failed run for this issue
          RECENT_RUN=$(gh run list \
            --workflow="tdd-execute.yml" \
            --status failure \
            --limit 5 \
            --json databaseId,conclusion,displayTitle \
            --jq ".[] | select(.displayTitle | contains(\"#$ISSUE_NUMBER\")) | .databaseId" \
            | head -1)

          if [ -z "$RECENT_RUN" ]; then
            echo "‚ö†Ô∏è  No recent failed run found - assuming infrastructure error"
            echo "is_infrastructure_error=true" >> $GITHUB_OUTPUT
            echo "error_type=unknown" >> $GITHUB_OUTPUT
            echo "should_retry=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "üìã Analyzing run #$RECENT_RUN..."

          # Get failure logs
          LOGS=$(gh run view "$RECENT_RUN" --log-failed || echo "")

          # Classify error type
          IS_INFRA_ERROR=false
          ERROR_TYPE="unknown"

          # Infrastructure errors (retriable at workflow level)
          if echo "$LOGS" | grep -q "EPERM: Operation not permitted"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="permission_error"
            echo "üîß Detected: Permission error (EPERM)"
          elif echo "$LOGS" | grep -q "ETIMEDOUT\|timeout\|timed out"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="timeout"
            echo "‚è±Ô∏è  Detected: Timeout error"
          elif echo "$LOGS" | grep -q "ECONNRESET\|ENOTFOUND\|socket hang up"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="network_error"
            echo "üåê Detected: Network error"
          elif echo "$LOGS" | grep -q "out of memory\|OOM\|killed"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="resource_exhaustion"
            echo "üíæ Detected: Resource exhaustion"
          elif echo "$LOGS" | grep -q "ENOSPC\|no space left"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="disk_full"
            echo "üíΩ Detected: Disk space error"
          elif echo "$LOGS" | grep -q "cancelled\|canceled"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="workflow_cancelled"
            echo "üö´ Detected: Workflow cancellation"
          # Code/test errors - NOW RETRIABLE with error context for Claude to self-correct
          elif echo "$LOGS" | grep -q "lint.*error\|ESLint.*error\|functional/immutable-data\|no-restricted-syntax"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="lint_error"
            echo "üîß Detected: Lint error - WILL RETRY with fix instructions"
          elif echo "$LOGS" | grep -q "Test.*failed\|FAIL\|AssertionError"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="test_failure"
            echo "üîß Detected: Test failure - WILL RETRY with fix instructions"
          elif echo "$LOGS" | grep -q "SyntaxError\|TypeError\|ReferenceError"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="code_error"
            echo "üîß Detected: Code error - WILL RETRY with fix instructions"
          fi

          # Determine if should retry
          SHOULD_RETRY=false
          if [ "$IS_INFRA_ERROR" = true ]; then
            SHOULD_RETRY=true
            echo "‚úÖ Error detected - WILL RETRY (Claude can self-correct)"
          else
            echo "‚ö†Ô∏è  Unknown error - will NOT retry"
          fi

          # Output results
          echo "is_infrastructure_error=$IS_INFRA_ERROR" >> $GITHUB_OUTPUT
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT
          echo "should_retry=$SHOULD_RETRY" >> $GITHUB_OUTPUT

  # Main Claude Code execution with timeout monitoring
  execute-claude:
    runs-on: ubuntu-latest
    timeout-minutes: 95 # Slightly longer than Claude timeout (90) to allow cleanup
    needs: [validate-context, classify-previous-error]
    if: |
      always() &&
      needs.validate-context.outputs.has_context == 'true' &&
      (needs.classify-previous-error.result == 'skipped' ||
       needs.classify-previous-error.outputs.should_retry == 'true') &&
      github.event.sender.login != 'claude[bot]' &&
      (
        github.event_name == 'workflow_dispatch' ||
        (github.event_name != 'workflow_dispatch' && (
          github.event.comment.author_association == 'OWNER' ||
          github.event.comment.author_association == 'MEMBER' ||
          github.event.comment.author_association == 'COLLABORATOR' ||
          github.event.issue.author_association == 'OWNER' ||
          github.event.issue.author_association == 'MEMBER' ||
          github.event.issue.author_association == 'COLLABORATOR' ||
          github.event.review.author_association == 'OWNER' ||
          github.event.review.author_association == 'MEMBER' ||
          github.event.review.author_association == 'COLLABORATOR' ||
          github.event.sender.login == 'github-actions[bot]' ||
          github.event.sender.login == 'github-actions' ||
          github.event.sender.login == 'app/github-actions' ||
          github.event.issue.user.login == 'github-actions[bot]' ||
          github.event.issue.user.login == 'github-actions' ||
          github.event.issue.user.login == 'app/github-actions' ||
          github.event.comment.user.login == 'github-actions[bot]' ||
          github.event.comment.user.login == 'github-actions' ||
          github.event.comment.user.login == 'app/github-actions'
        ))
      )
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read
    outputs:
      claude_success: ${{ steps.set_success.outputs.claude_success }}
      claude_exit_code: ${{ steps.claude.outcome }}
      error_type: ${{ steps.detect_error.outputs.error_type }}
      is_infrastructure_error: ${{ steps.detect_error.outputs.is_infrastructure_error }}
      has_branch: ${{ steps.set_success.outputs.has_branch }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set issue context
        id: issue
        env:
          # Security: Use env var to prevent code injection from untrusted issue body
          ISSUE_BODY_INPUT: ${{ needs.validate-context.outputs.issue_body }}
        run: |
          echo "issue_number=${{ needs.validate-context.outputs.issue_number }}" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY_INPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@v1
        timeout-minutes: 90
        continue-on-error: true # Capture exit code instead of failing immediately
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          # Use PAT with 'workflows' scope for git push operations
          # GitHub requires 'workflows' scope to push to repos containing .github/workflows/ files
          # Comments will appear from your personal account (not claude[bot])
          github_token: ${{ secrets.GH_PAT_WORKFLOW }}
          additional_permissions: |
            actions: read
          # NO prompt field - Claude Code will read the @claude comment naturally
          # This allows the queue processor's detailed instructions to be used
          # Agents are auto-discovered from .claude/agents/ directory (no --agents flag needed)
          #
          # Claude Code Best Practices (per https://code.claude.com/docs/github-actions):
          # - --model: Explicit model for cost predictability (Sonnet 4 is cost-effective for TDD)
          # - --max-budget-usd: Cost-based limit instead of turn-based (complex specs need 55-90+ turns)
          #   Using $10 budget allows complex specs to complete while preventing runaway costs
          #   The 90-minute timeout acts as the ultimate time-based backstop
          # - --allowedTools: Principle of least privilege - only tools needed for TDD workflow
          # - --disallowedTools: Block tools not needed for autonomous code implementation
          #   - AskUserQuestion: No human present in automation (would hang or skip)
          #   - WebFetch/WebSearch: External content not needed
          #   - NotebookEdit: No Jupyter notebooks in project
          #   - SlashCommand: Prevents unintended command execution
          claude_args: >-
            --model claude-sonnet-4-5-20250929
            --max-budget-usd 10.00
            --allowedTools Edit,Read,Write,Bash,Glob,Grep,Task,TodoWrite,Skill,LSP
            --disallowedTools WebFetch,WebSearch,AskUserQuestion,NotebookEdit,SlashCommand

      - name: Detect error type
        id: detect_error
        if: always()
        run: |
          echo "üîç Analyzing Claude Code execution..."

          # Check Claude Code exit behavior
          CLAUDE_OUTCOME="${{ steps.claude.outcome }}"

          IS_INFRA_ERROR=false
          ERROR_TYPE="unknown"

          # Calculate step duration to detect timeout (GitHub marks some timeouts as "success")
          START_TIME="${{ steps.claude.outputs.startedAt || '' }}"
          END_TIME="${{ steps.claude.outputs.completedAt || '' }}"

          # If timestamps are available, calculate duration
          if [ -n "$START_TIME" ] && [ -n "$END_TIME" ]; then
            START_EPOCH=$(date -d "$START_TIME" +%s 2>/dev/null || echo "0")
            END_EPOCH=$(date -d "$END_TIME" +%s 2>/dev/null || echo "0")

            if [ "$START_EPOCH" -ne 0 ] && [ "$END_EPOCH" -ne 0 ]; then
              DURATION=$((END_EPOCH - START_EPOCH))
              echo "üìä Step duration: ${DURATION}s"

              # Timeout detection: anything > 74 minutes (4440 seconds) is likely a timeout
              if [ "$DURATION" -ge 4440 ]; then
                IS_INFRA_ERROR=true
                ERROR_TYPE="timeout_confirmed"
                echo "‚è±Ô∏è TIMEOUT DETECTED: Step ran for ${DURATION}s (>= 4440s threshold)"
              fi
            fi
          fi

          # If not already classified as timeout, check outcome
          if [ "$ERROR_TYPE" = "unknown" ]; then
            if [ "$CLAUDE_OUTCOME" = "cancelled" ]; then
              # Cancelled usually means timeout or manual cancellation
              IS_INFRA_ERROR=true
              ERROR_TYPE="cancelled_timeout"
              echo "‚è±Ô∏è Step was cancelled - treating as timeout"
            elif [ "$CLAUDE_OUTCOME" = "failure" ]; then
              # For failures, check if it's infrastructure or code issue
              # Look for common infrastructure error patterns in logs if available
              ERROR_TYPE="claude_failure"
              echo "‚ùå Claude Code failed - checking for infrastructure issues..."

              # Default to infrastructure error for retries (conservative approach)
              IS_INFRA_ERROR=true
            elif [ "$CLAUDE_OUTCOME" = "success" ]; then
              # Even success might be a timeout if duration is suspicious
              if [ "$ERROR_TYPE" != "timeout_confirmed" ]; then
                ERROR_TYPE="success"
                echo "‚úÖ Claude Code completed successfully"
              fi
            else
              ERROR_TYPE="unknown_outcome"
              echo "‚ùì Unknown outcome: $CLAUDE_OUTCOME"
              IS_INFRA_ERROR=true
            fi
          fi

          echo "is_infrastructure_error=$IS_INFRA_ERROR" >> $GITHUB_OUTPUT
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT

      # CRITICAL: Explicitly set success output to fix detection issue
      # GitHub Actions has issues with expression-based outputs when steps use continue-on-error
      # This step explicitly captures both success state and branch existence for fallback
      - name: Set success output
        id: set_success
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
          CLAUDE_OUTCOME: ${{ steps.claude.outcome }}
        run: |
          echo "üîç Setting success output..."
          echo "   Claude outcome: $CLAUDE_OUTCOME"

          # Explicitly set claude_success based on outcome
          if [ "$CLAUDE_OUTCOME" = "success" ]; then
            echo "claude_success=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Claude completed successfully"
          else
            echo "claude_success=false" >> $GITHUB_OUTPUT
            echo "‚ùå Claude did not complete successfully (outcome: $CLAUDE_OUTCOME)"
          fi

          # Also check if a branch was created (fallback indicator)
          # This allows verify-success to run even if claude_success detection fails
          BRANCH_PATTERN="claude/issue-${ISSUE_NUMBER}-"
          BRANCH_EXISTS=$(gh api "/repos/$REPO/branches" \
            --jq "[.[] | select(.name | startswith(\"$BRANCH_PATTERN\"))][0].name" 2>/dev/null || echo "")

          if [ -n "$BRANCH_EXISTS" ] && [ "$BRANCH_EXISTS" != "null" ]; then
            echo "has_branch=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Branch exists: $BRANCH_EXISTS"
          else
            echo "has_branch=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  No branch found with pattern: $BRANCH_PATTERN"
          fi

      - name: Update issue on failure
        if: steps.claude.outcome != 'success'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
          RETRY_ATTEMPT: ${{ github.event.inputs.retry_attempt || 1 }}
          ERROR_TYPE: ${{ steps.detect_error.outputs.error_type }}
        run: |
          echo "üìù Updating issue #$ISSUE_NUMBER with failure information..."

          gh issue comment "$ISSUE_NUMBER" --body "‚ö†Ô∏è **Claude Code Execution Failed (Attempt $RETRY_ATTEMPT)**

          **Error Type**: \`$ERROR_TYPE\`
          **Workflow Run**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          The automation system will analyze this error and retry if appropriate.

          ---
          *ü§ñ Infrastructure Error Handler*"

  # Retry logic: Automatically retry infrastructure errors
  handle-retry:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [execute-claude]
    if: |
      always() &&
      needs.execute-claude.outputs.claude_success != 'true' &&
      needs.execute-claude.outputs.is_infrastructure_error == 'true'
    permissions:
      actions: write
      issues: write
    steps:
      - name: Determine retry action
        id: retry
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          CURRENT_RETRY: ${{ github.event.inputs.retry_attempt || 1 }}
          MAX_RETRIES: ${{ env.MAX_INFRASTRUCTURE_RETRIES }}
          ERROR_TYPE: ${{ needs.execute-claude.outputs.error_type }}
        run: |
          echo "üîÑ Error detected: $ERROR_TYPE"
          echo "üìä Current retry attempt: $CURRENT_RETRY of $MAX_RETRIES"

          NEXT_RETRY=$((CURRENT_RETRY + 1))

          if [ "$NEXT_RETRY" -le "$MAX_RETRIES" ]; then
            echo "‚úÖ Will retry (attempt $NEXT_RETRY)"
            echo "should_retry=true" >> $GITHUB_OUTPUT
            echo "next_retry=$NEXT_RETRY" >> $GITHUB_OUTPUT

            # Add retry label based on error type (using consistent retry:* prefix)
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" --add-label "retry:spec:$CURRENT_RETRY" 2>/dev/null || true
            else
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" --add-label "retry:infra:$CURRENT_RETRY" 2>/dev/null || true
            fi

            # Build retry comment with error-specific instructions
            if [ "$ERROR_TYPE" = "lint_error" ]; then
              RETRY_COMMENT="üîß **Automatic Code Fix Retry**

          **Error Type**: \`$ERROR_TYPE\` (ESLint violation)
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

          **‚ö†Ô∏è CRITICAL FIX INSTRUCTIONS FOR CLAUDE:**
          1. Run \`bun run lint\` to see the exact ESLint errors
          2. **Common FP violations to fix:**
             - ‚ùå \`array.push()\` ‚Üí ‚úÖ Use \`[...array, item]\`
             - ‚ùå \`for/while\` loops ‚Üí ‚úÖ Use \`map/filter/reduce\`
             - ‚ùå Mutable \`const arr = []\` ‚Üí ‚úÖ Use immutable patterns
          3. Fix ALL lint errors before committing
          4. Run \`bun run quality\` to verify

          Retrying with fix instructions...

          ---
          *ü§ñ TDD Error Handler*"
            elif [ "$ERROR_TYPE" = "test_failure" ]; then
              RETRY_COMMENT="üîß **Automatic Test Fix Retry**

          **Error Type**: \`$ERROR_TYPE\`
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

          **‚ö†Ô∏è FIX INSTRUCTIONS FOR CLAUDE:**
          1. Run \`bun test:e2e -- <test-file>\` to see failing tests
          2. Analyze the error output and fix the implementation
          3. Ensure ALL tests in the file pass before committing
          4. Run \`bun run quality\` to verify

          Retrying with fix instructions...

          ---
          *ü§ñ TDD Error Handler*"
            elif [ "$ERROR_TYPE" = "code_error" ]; then
              RETRY_COMMENT="üîß **Automatic Code Fix Retry**

          **Error Type**: \`$ERROR_TYPE\` (Syntax/Type error)
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

          **‚ö†Ô∏è FIX INSTRUCTIONS FOR CLAUDE:**
          1. Run \`bun run typecheck\` to see TypeScript errors
          2. Fix all type errors before committing
          3. Run \`bun run quality\` to verify

          Retrying with fix instructions...

          ---
          *ü§ñ TDD Error Handler*"
            else
              RETRY_COMMENT="üîÑ **Automatic Infrastructure Retry**

          **Error Type**: \`$ERROR_TYPE\`
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES
          **Reason**: Infrastructure/environment error (not code-related)

          Retrying workflow automatically with exponential backoff...

          ---
          *ü§ñ Infrastructure Error Handler*"
            fi

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$RETRY_COMMENT"

            # Exponential backoff with jitter to avoid thundering herd
            # Delays: 60s (retry 1‚Üí2), 120s (retry 2‚Üí3), 240s (retry 3‚Üí4)
            BASE_DELAY=$((60 * (1 << (CURRENT_RETRY - 1))))

            # Add jitter (¬±25% randomness)
            JITTER_RANGE=$((BASE_DELAY / 4))
            JITTER=$((RANDOM % (JITTER_RANGE * 2 + 1) - JITTER_RANGE))
            ACTUAL_DELAY=$((BASE_DELAY + JITTER))

            # Ensure minimum 30s delay
            if [ "$ACTUAL_DELAY" -lt 30 ]; then
              ACTUAL_DELAY=30
            fi

            echo "‚è±Ô∏è  Waiting ${ACTUAL_DELAY}s before retry (base: ${BASE_DELAY}s, jitter: ${JITTER}s)"
            sleep "$ACTUAL_DELAY"
          else
            echo "‚ùå Max retries exhausted ($MAX_RETRIES)"
            echo "should_retry=false" >> $GITHUB_OUTPUT

            # Mark as failed with appropriate label (using failure:* prefix for consistency)
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:failed" \
                --add-label "failure:spec" 2>/dev/null || true
            else
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:failed" \
                --add-label "failure:infra" 2>/dev/null || true
            fi

            # Build failure message based on error type
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              FAILURE_COMMENT="‚ùå **Code Error - Max Retries Exhausted**

          **Error Type**: \`$ERROR_TYPE\`
          **Total Attempts**: $MAX_RETRIES
          **Status**: Marked as \`tdd-spec:failed\`

          Claude was unable to fix the code errors after $MAX_RETRIES attempts. Manual intervention required.

          **Possible Solutions**:
          1. Check the PR for specific error details
          2. Manually fix the code and push
          3. Review the agent instructions for missing patterns
          4. Skip automation and implement manually

          The queue processor will continue with the next spec.

          ---
          *ü§ñ TDD Error Handler*"
            else
              FAILURE_COMMENT="‚ùå **Infrastructure Error - Max Retries Exhausted**

          **Error Type**: \`$ERROR_TYPE\`
          **Total Attempts**: $MAX_RETRIES
          **Status**: Marked as \`tdd-spec:failed\`

          This spec failed due to infrastructure/environment errors, not code issues. Manual intervention required.

          **Possible Solutions**:
          1. Check GitHub Actions runner status
          2. Check if Claude Code API is experiencing issues
          3. Manually retry via workflow_dispatch
          4. Skip automation and implement manually

          The queue processor will continue with the next spec.

          ---
          *ü§ñ Infrastructure Error Handler*"
            fi

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$FAILURE_COMMENT"
          fi

      - name: Alert on high failure rate
        if: steps.retry.outputs.should_retry != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
        run: |
          echo "üìä Checking for high failure rate..."

          # Count failed specs in last 24 hours
          CUTOFF_DATE=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-24H +%Y-%m-%dT%H:%M:%SZ)

          FAILED_COUNT=$(gh issue list \
            --repo "$REPO" \
            --label "tdd-spec:failed" \
            --state all \
            --json number,createdAt,labels \
            --jq "[.[] | select(.createdAt > \"$CUTOFF_DATE\")] | length")

          echo "Failed specs in last 24h: $FAILED_COUNT"

          # Create incident if >= 5 failures
          if [ "$FAILED_COUNT" -ge 5 ]; then
            echo "üö® High failure rate detected - creating incident..."

            # Check if incident already exists
            EXISTING_INCIDENT=$(gh issue list \
              --repo "$REPO" \
              --label "incident,high-failure-rate" \
              --state open \
              --json number \
              --jq 'length')

            if [ "$EXISTING_INCIDENT" -eq 0 ]; then
              # Get list of failed spec IDs
              FAILED_SPECS=$(gh issue list \
                --repo "$REPO" \
                --label "tdd-spec:failed" \
                --state all \
                --limit 10 \
                --json number,createdAt,title \
                --jq "[.[] | select(.createdAt > \"$CUTOFF_DATE\")] | map(\"- #\(.number): \(.title)\") | join(\"\n\")")

              gh issue create \
                --repo "$REPO" \
                --title "üö® TDD Automation: High Failure Rate ($FAILED_COUNT specs failed in 24h)" \
                --label "incident,high-failure-rate,tdd-automation,priority:high" \
                --body "## üö® High TDD Spec Failure Rate"$'\n\n'"Failed Specs (24h): $FAILED_COUNT"$'\n'"Threshold: 5"$'\n\n'"### Recent Failures"$'\n'"$FAILED_SPECS"$'\n\n'"### Investigation Steps"$'\n'"1. Check for common error patterns: \`gh issue list --label tdd-spec:failed --limit 20\`"$'\n'"2. Review tdd-execute.yml runs: [Workflow History](https://github.com/$REPO/actions/workflows/tdd-execute.yml)"$'\n'"3. Check infrastructure health: \`gh run list --workflow tdd-monitor.yml\`"$'\n\n'"### Possible Causes"$'\n'"- Systemic test issues (flaky tests, environment problems)"$'\n'"- Infrastructure instability (runner timeouts, permission errors)"$'\n'"- Schema/API changes breaking multiple specs"$'\n'"- Claude Code regression (instruction following issues)"$'\n\n'"### Resolution"$'\n'"Once root cause identified and fixed:"$'\n'"1. Re-queue failed specs: \`gh issue edit ISSUE_NUMBER --remove-label tdd-spec:failed --add-label tdd-spec:queued\`"$'\n'"2. Close this incident"$'\n'"3. Document in TDD-TROUBLESHOOTING.md"$'\n\n'"---"$'\n'"ü§ñ Automated via [TDD Monitor](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"

              echo "‚úÖ Incident issue created"
            else
              echo "‚ÑπÔ∏è  Incident already exists, skipping creation"
            fi
          else
            echo "‚úÖ Failure rate acceptable ($FAILED_COUNT < 5)"
          fi

      - name: Trigger retry workflow
        if: steps.retry.outputs.should_retry == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          NEXT_RETRY: ${{ steps.retry.outputs.next_retry }}
        run: |
          echo "üöÄ Triggering retry workflow (attempt $NEXT_RETRY)..."

          # Trigger the workflow - capture exit status to allow fallback on failure
          # Bug fix: Previously, failure here would exit immediately due to set -e,
          # preventing the fallback @claude comment from being posted
          DISPATCH_FAILED=false
          if ! gh workflow run tdd-execute.yml --repo "$REPO" \
            --field issue_number="$ISSUE_NUMBER" \
            --field retry_attempt="$NEXT_RETRY" 2>&1; then
            echo "‚ö†Ô∏è Workflow dispatch failed (likely 403 permission error) - will use fallback"
            DISPATCH_FAILED=true
          fi

          # Skip verification if dispatch already failed - go straight to fallback
          RETRY_STARTED=false
          if [ "$DISPATCH_FAILED" != "true" ]; then
            # Wait for workflow to start
            echo "‚è≥ Verifying retry workflow started..."
            sleep 15

            # Check if workflow started in the last 20 seconds
            NOW=$(date +%s)

            # Get recent runs with error handling
            RECENT_RUNS=$(gh run list \
              --workflow tdd-execute.yml \
              --repo "$REPO" \
              --limit 5 \
              --json event,createdAt,status 2>&1) || true

            # Validate JSON before parsing
            if echo "$RECENT_RUNS" | jq empty 2>/dev/null; then
              # Check for a workflow_dispatch run created in the last 20 seconds
              # Bug fix: Use process substitution to avoid subshell variable scope issue
              while read -r run; do
                if [ -n "$run" ]; then
                  CREATED_AT=$(echo "$run" | jq -r '.createdAt' 2>/dev/null || echo "")
                  if [ -n "$CREATED_AT" ]; then
                    CREATED_EPOCH=$(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s 2>/dev/null || echo 0)
                    AGE=$((NOW - CREATED_EPOCH))

                    if [ "$AGE" -lt 20 ]; then
                      RETRY_STARTED=true
                      echo "‚úÖ Retry workflow started successfully"
                      break
                    fi
                  fi
                fi
              done < <(echo "$RECENT_RUNS" | jq -r '.[] | select(.event == "workflow_dispatch")' 2>/dev/null)
            else
              echo "‚ö†Ô∏è Failed to parse workflow runs (JSON error) - will use fallback method"
            fi
          fi

          # If workflow didn't start, use issue comment as fallback
          if [ "$RETRY_STARTED" != "true" ]; then
            echo "‚ö†Ô∏è Workflow dispatch may have failed, triggering via issue comment as fallback..."

            # Get spec details from issue for context
            SPEC_ID=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json title --jq '.title' | grep -oP '[A-Z]+-[A-Z]+-[0-9]+' || echo "unknown")
            TEST_FILE=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json body --jq '.body' | grep -oP 'Test File.*`\K[^`]+' || echo "unknown")

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "@claude retry implementation (automated retry $NEXT_RETRY of 3 - workflow dispatch fallback)

            ## üìã Context
            - **Spec ID**: \`$SPEC_ID\`
            - **Test File**: \`$TEST_FILE\`
            - **Issue**: #$ISSUE_NUMBER
            - **Retry Attempt**: $NEXT_RETRY of 3
            - **Trigger**: Workflow dispatch failed, using comment fallback
            - **Previous Failure**: Infrastructure error (not code issue)

            ## ü§ñ Automation Mode
            - ‚úÖ Make autonomous decisions - proceed with best judgment
            - ‚ùå DO NOT ask questions

            ## ‚úÖ Instructions

            1. **Check current state**: Run \`git status\` to see if previous work exists on branch
            2. **If branch has uncommitted changes**: Continue from where it left off
            3. **If clean state**: Start fresh using e2e-test-fixer agent (\`Task\` tool with \`subagent_type='e2e-test-fixer'\`)
            4. **Run codebase-refactor-auditor**: Use \`Task\` tool with \`subagent_type='codebase-refactor-auditor'\` (MANDATORY - never skip)
            5. **Verify quality**: Run \`bun run quality\` - ALL checks must pass
            6. **Commit changes**: Run \`bun run license\`, then \`git commit -m \"fix: implement $SPEC_ID\"\`
            7. **Push to branch**: \`git push\`
            8. **Create PR**: \`gh pr create --title \"fix: implement $SPEC_ID\" --body \"Closes #$ISSUE_NUMBER\" --label \"tdd-automation\"\`
            9. **Enable auto-merge**: \`gh pr merge \$PR_NUMBER --auto --squash\`
            10. **Verify auto-merge**: \`gh pr view \$PR_NUMBER --json autoMergeRequest\` - must NOT be null

            ## ‚ö†Ô∏è Error Handling
            - **If tests fail**: Fix the code until \`bun run quality\` passes
            - **If PR already exists**: Update existing PR instead of creating new one
            - **If auto-merge fails**: Comment the failure reason on the PR

            **Reference**: \`@docs/development/tdd-automation-pipeline.md\`

            ---
            *ü§ñ Infrastructure Retry Handler (Fallback)*"

            echo "‚úÖ Fallback retry triggered via issue comment with full context"
          fi

  # Success path: Verify PR was created and handle duplicates
  # IMPORTANT: Claude Code can run for up to 60 minutes. During that time:
  # - Another workflow might have already created and merged a PR for this issue
  # - The issue might have been closed by a merged PR
  # This job detects and handles these duplicate PR scenarios
  #
  # RELIABILITY FIX: Run this job when EITHER:
  # - claude_success == 'true' (normal case)
  # - has_branch == 'true' (fallback: Claude pushed a branch but success detection failed)
  # This prevents issues getting stuck when Claude successfully implements code but
  # the workflow skips PR creation due to output detection issues.
  verify-success:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [execute-claude]
    if: |
      always() &&
      (needs.execute-claude.outputs.claude_success == 'true' ||
       needs.execute-claude.outputs.has_branch == 'true')
    permissions:
      issues: write
      pull-requests: write  # Need write to close duplicate PRs
    steps:
      # DUPLICATE PREVENTION: Check if issue was already completed during Claude's execution
      # This prevents duplicate PRs when Claude runs for 60 minutes and another PR merges first
      - name: Check for duplicate/stale state
        id: duplicate_check
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
        run: |
          echo "üîç Checking if issue #$ISSUE_NUMBER is still open and needs a PR..."

          # Check 1: Is the issue still open?
          ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")

          if [ "$ISSUE_STATE" = "CLOSED" ]; then
            echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER is CLOSED - another PR likely merged during Claude's execution"
            echo "   Skipping PR creation/verification to prevent duplicate PR"
            echo "is_duplicate=true" >> $GITHUB_OUTPUT
            echo "reason=issue_closed" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check 2: Are there any merged PRs for this issue?
          MERGED_PR_COUNT=$(gh pr list \
            --repo "$REPO" \
            --search "Closes #$ISSUE_NUMBER in:body" \
            --state merged \
            --json number \
            --jq 'length' 2>/dev/null || echo "0")

          if [ "$MERGED_PR_COUNT" -gt 0 ]; then
            MERGED_PRS=$(gh pr list \
              --repo "$REPO" \
              --search "Closes #$ISSUE_NUMBER in:body" \
              --state merged \
              --json number,mergedAt \
              --jq '[.[] | "#\(.number) (merged \(.mergedAt))"] | join(", ")' 2>/dev/null || echo "")
            echo "‚ö†Ô∏è  Found $MERGED_PR_COUNT merged PR(s) for issue #$ISSUE_NUMBER: $MERGED_PRS"
            echo "   Skipping PR creation/verification to prevent duplicate PR"
            echo "is_duplicate=true" >> $GITHUB_OUTPUT
            echo "reason=pr_already_merged" >> $GITHUB_OUTPUT
            echo "merged_prs=$MERGED_PRS" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Issue #$ISSUE_NUMBER is open with no merged PRs - proceeding with PR verification"
          echo "is_duplicate=false" >> $GITHUB_OUTPUT

      - name: Handle duplicate scenario
        if: steps.duplicate_check.outputs.is_duplicate == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          REASON: ${{ steps.duplicate_check.outputs.reason }}
          MERGED_PRS: ${{ steps.duplicate_check.outputs.merged_prs }}
        run: |
          echo "üîÑ Handling duplicate scenario: $REASON"

          if [ "$REASON" = "issue_closed" ]; then
            # Issue was closed - likely by another merged PR
            # Any branch/PR created by this Claude run is now obsolete
            COMMENT_BODY="üîÑ **Duplicate Prevention**: Claude Code completed, but issue was already closed.

          This typically happens when:
          - Another workflow completed and merged a PR for this issue
          - The issue was manually closed
          - A concurrent Claude Code run finished first

          **No action needed** - the issue is already resolved.

          ---
          *ü§ñ Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            # Post comment only if issue is still accessible (it might be closed)
            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$COMMENT_BODY" 2>/dev/null || echo "Could not post comment (issue may be closed)"

          elif [ "$REASON" = "pr_already_merged" ]; then
            # A PR was already merged for this issue
            COMMENT_BODY="üîÑ **Duplicate Prevention**: Claude Code completed, but a PR was already merged for this issue.

          **Merged PR(s)**: $MERGED_PRS

          This typically happens when Claude Code runs for a long time (up to 60 minutes) and another PR is created and merged during that period.

          **No action needed** - the work is already complete.

          ---
          *ü§ñ Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$COMMENT_BODY" 2>/dev/null || echo "Could not post comment (issue may be closed)"

            # Close any open PRs that Claude might have created (they're now duplicates)
            echo "üîç Checking for any open PRs created by this run that need to be closed..."
            OPEN_PRS=$(gh pr list \
              --repo "$REPO" \
              --search "Closes #$ISSUE_NUMBER in:body" \
              --state open \
              --json number,headRefName \
              --jq '.[] | "\(.number):\(.headRefName)"' 2>/dev/null || echo "")

            for PR_INFO in $OPEN_PRS; do
              PR_NUM=$(echo "$PR_INFO" | cut -d: -f1)
              BRANCH=$(echo "$PR_INFO" | cut -d: -f2)
              echo "  Closing duplicate PR #$PR_NUM (branch: $BRANCH)..."
              gh pr close "$PR_NUM" --repo "$REPO" \
                --comment "üîÑ **Closing as duplicate**: PR(s) $MERGED_PRS already merged for issue #$ISSUE_NUMBER." \
                --delete-branch 2>/dev/null || echo "    Could not close PR #$PR_NUM"
            done
          fi

          echo "‚úÖ Duplicate handling complete - exiting successfully (no further action needed)"

      # =========================================================================
      # PHASE 2: Workflow-managed PR creation
      # =========================================================================
      # Claude is now instructed to commit and push, but NOT create PR.
      # The workflow creates the PR to ensure reliable "Closes #XXXX" format.
      # =========================================================================

      - name: Create PR from branch (workflow-managed)
        # Skip if duplicate was detected (issue already closed or PR already merged)
        if: steps.duplicate_check.outputs.is_duplicate != 'true'
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
        run: |
          echo "üîç Looking for branch to create PR for issue #$ISSUE_NUMBER..."

          # Check if PR already exists (Claude might have created one despite instructions)
          EXISTING_PR=$(gh pr list --repo "$REPO" \
            --json number,headRefName \
            --jq "[.[] | select(.headRefName | test(\"^claude/issue-.*$ISSUE_NUMBER.*\"))][0].number" 2>/dev/null || echo "")

          if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
            echo "‚úÖ PR #$EXISTING_PR already exists - skipping PR creation"

            # Check if auto-merge is enabled on existing PR
            AUTO_MERGE_STATUS=$(gh pr view "$EXISTING_PR" --repo "$REPO" --json autoMergeRequest --jq '.autoMergeRequest' 2>/dev/null || echo "null")

            if [ "$AUTO_MERGE_STATUS" = "null" ] || [ -z "$AUTO_MERGE_STATUS" ]; then
              echo "üîÑ Auto-merge not enabled on existing PR - enabling now..."
              if gh pr merge "$EXISTING_PR" --auto --squash --repo "$REPO"; then
                echo "‚úÖ Auto-merge enabled on PR #$EXISTING_PR"
              else
                echo "‚ö†Ô∏è  Failed to enable auto-merge on PR #$EXISTING_PR - may need manual merge"
              fi
            else
              echo "‚úÖ Auto-merge already enabled on PR #$EXISTING_PR"
            fi

            echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT
            echo "pr_created=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Find branch created by Claude
          BRANCH_PATTERN="claude/issue-${ISSUE_NUMBER}-"
          BRANCH_FULL_NAME=$(gh api "/repos/$REPO/branches" \
            --jq "[.[] | select(.name | startswith(\"$BRANCH_PATTERN\"))][0].name" 2>/dev/null || echo "")

          if [ -z "$BRANCH_FULL_NAME" ] || [ "$BRANCH_FULL_NAME" = "null" ]; then
            echo "‚ùå No branch found with pattern: $BRANCH_PATTERN"
            echo "   Claude may not have pushed changes."
            echo ""
            echo "Marking issue as failed..."

            gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
              --remove-label "tdd-spec:in-progress" \
              --add-label "tdd-spec:failed"

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "‚ùå **TDD Automation Failed: No Branch Found**

          Claude Code finished but no branch was pushed to the repository.

          **Expected branch pattern**: \`$BRANCH_PATTERN*\`

          **Next Steps**:
          1. Check if Claude encountered an error during implementation
          2. Re-run this spec if needed

          **Issue Status**: Marked as \`tdd-spec:failed\` - requires manual intervention.

          ---
          *ü§ñ Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            exit 1
          fi

          echo "‚úÖ Found branch: $BRANCH_FULL_NAME"

          # Get spec ID from issue body
          SPEC_ID=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json body --jq '.body' | grep -oE '[A-Z]+-[A-Z]+-[A-Z0-9-]+' | head -1 || echo "unknown-spec")

          echo "üìã Creating PR for $SPEC_ID..."

          # Create PR with guaranteed correct format
          # CRITICAL: Body is EXACTLY "Closes #XXXX" - nothing else
          # Retry up to 3 times for transient network errors
          #
          # RELIABILITY FIX: Don't use --json --jq flags - they fail when gh pr create
          # returns an error (tries to parse non-JSON error message as JSON).
          # Instead, extract PR number from the URL in the success output.
          PR_NUMBER=""
          PR_CREATE_ERROR=""

          # Disable exit-on-error for retry loop (default behavior can vary)
          set +e

          for attempt in 1 2 3; do
            echo "PR creation attempt $attempt/3..."

            # Capture output AND exit code separately
            PR_CREATE_OUTPUT=$(gh pr create \
              --repo "$REPO" \
              --head "$BRANCH_FULL_NAME" \
              --base main \
              --title "fix: implement $SPEC_ID" \
              --body "Closes #${ISSUE_NUMBER}" \
              --label "tdd-automation" 2>&1)
            PR_EXIT_CODE=$?

            echo "Exit code: $PR_EXIT_CODE"
            echo "Output: $PR_CREATE_OUTPUT"

            # Extract PR number from URL (format: https://github.com/owner/repo/pull/123)
            if [ $PR_EXIT_CODE -eq 0 ]; then
              PR_NUMBER=$(echo "$PR_CREATE_OUTPUT" | grep -oE '/pull/[0-9]+' | grep -oE '[0-9]+' | head -1)
              if [ -n "$PR_NUMBER" ]; then
                echo "‚úÖ PR creation succeeded on attempt $attempt"
                break
              fi
            fi

            # Check if it's a duplicate error (no retry needed)
            if echo "$PR_CREATE_OUTPUT" | grep -qi "already exists"; then
              echo "PR already exists - no retry needed"
              # Try to extract existing PR number
              PR_NUMBER=$(echo "$PR_CREATE_OUTPUT" | grep -oE '/pull/[0-9]+' | grep -oE '[0-9]+' | head -1)
              PR_CREATE_ERROR="$PR_CREATE_OUTPUT"
              break
            fi

            PR_CREATE_ERROR="$PR_CREATE_OUTPUT"
            if [ "$attempt" -lt 3 ]; then
              DELAY=$((attempt * 5))
              echo "‚ö†Ô∏è  Attempt $attempt failed (exit code $PR_EXIT_CODE): $PR_CREATE_OUTPUT"
              echo "Retrying in ${DELAY}s..."
              sleep $DELAY
            fi
          done

          # Re-enable exit-on-error
          set -e

          if [ -n "$PR_NUMBER" ] && [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "‚úÖ PR #$PR_NUMBER created successfully!"
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "pr_created=true" >> $GITHUB_OUTPUT

            # Enable auto-merge
            echo ""
            echo "üîÑ Enabling auto-merge..."
            if gh pr merge "$PR_NUMBER" --auto --squash --repo "$REPO"; then
              echo "‚úÖ Auto-merge enabled"
            else
              echo "‚ö†Ô∏è  Auto-merge failed - PR will need manual merge"
            fi

            # Post success comment
            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "‚úÖ **PR Created**: #$PR_NUMBER

          Workflow created PR from branch \`$BRANCH_FULL_NAME\` with auto-merge enabled.

          PR will merge automatically when CI passes.

          ---
          *ü§ñ Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"
          else
            echo "‚ùå PR creation failed after 3 attempts: $PR_CREATE_ERROR"

            gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
              --remove-label "tdd-spec:in-progress" \
              --add-label "tdd-spec:failed"

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "‚ùå **TDD Automation Failed: PR Creation Error**

          Branch \`$BRANCH_FULL_NAME\` exists but PR creation failed after 3 retry attempts.

          **Error**: \`$PR_CREATE_ERROR\`

          **Next Steps**:
          1. Manually create PR from branch \`$BRANCH_FULL_NAME\`
          2. Or investigate the error above

          **Issue Status**: Marked as \`tdd-spec:failed\` - requires manual intervention.

          ---
          *ü§ñ Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            exit 1
          fi

      # Safety net: Validate PR body in case Claude created PR despite instructions
      # (When workflow creates PR, body is guaranteed correct)
      - name: Validate PR body has auto-close keyword
        if: steps.duplicate_check.outputs.is_duplicate != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          CREATED_PR_NUMBER: ${{ steps.create_pr.outputs.pr_number }}
        run: |
          echo "üîç Validating PR body contains auto-close keyword..."

          # Use PR number from create_pr step if available, otherwise find it
          if [ -n "$CREATED_PR_NUMBER" ] && [ "$CREATED_PR_NUMBER" != "" ]; then
            PR_NUMBER="$CREATED_PR_NUMBER"
            echo "Using PR #$PR_NUMBER from create_pr step"
          else
            PR_NUMBER=$(gh pr list --repo "$REPO" \
              --json number,headRefName \
              --jq "[.[] | select(.headRefName | test(\"^claude/issue-.*$ISSUE_NUMBER.*\"))][0].number")
          fi

          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ]; then
            echo "‚ö†Ô∏è  No PR found to validate - skipping body check"
            exit 0
          fi

          echo "üìã Checking PR #$PR_NUMBER body..."

          # Get current PR body
          PR_BODY=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json body --jq '.body')

          # Check if body contains the required auto-close keyword
          if echo "$PR_BODY" | grep -qE "Closes #$ISSUE_NUMBER([^0-9]|$)"; then
            echo "‚úÖ PR body contains 'Closes #$ISSUE_NUMBER' - auto-close will work"
          else
            echo "‚ö†Ô∏è  PR #$PR_NUMBER is MISSING 'Closes #$ISSUE_NUMBER' in body"
            echo "   Auto-close will NOT work without this keyword"
            echo "   Attempting to fix by prepending the keyword..."

            # Prepend the auto-close keyword to the existing body
            # Use printf to avoid YAML parsing issues with multiline strings
            NEW_BODY=$(printf "Closes #%s\n\n%s" "$ISSUE_NUMBER" "$PR_BODY")

            # Update the PR body
            if gh pr edit "$PR_NUMBER" --repo "$REPO" --body "$NEW_BODY"; then
              echo "‚úÖ Successfully added 'Closes #$ISSUE_NUMBER' to PR body"
              echo "   Auto-close will now work when PR merges"

              # Post comment on issue explaining the fix
              gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
                --body "üîß **Auto-Close Keyword Fix Applied**: PR #$PR_NUMBER was missing \`Closes #$ISSUE_NUMBER\` in its body. Added the keyword - issue will now auto-close when PR merges. *ü§ñ Automated fix*" || true
            else
              echo "‚ùå Failed to update PR body - manual intervention may be needed"
              echo "   PR will merge but issue may not auto-close"
            fi
          fi
