name: TDD - Execute (Claude Code)

# This workflow handles all Claude Code execution with infrastructure-level retry logic
# It handles both automated queue processing and manual @claude mentions
# Infrastructure errors (EPERM, timeouts, crashes) are automatically retried up to 3 times

on:
  # Manual trigger: Process specific issue number with optional retry
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process'
        required: true
        type: number
      retry_attempt:
        description: 'Current retry attempt (1-3)'
        required: false
        type: number
        default: 1

  # Manual triggers: @claude mentions in issues/PRs (interactive use)
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

# Concurrency control: One run per issue/PR, QUEUE don't cancel
# Groups runs by issue/PR number to prevent duplicate execution
# cancel-in-progress: false preserves work-in-progress (Claude can run 60+ min)
# Duplicate PRs prevented via application-level checks (pre-PR validation in CLAUDE.md)
# Note: claude[bot] comments are filtered in validate-context job (lines 80-98)
concurrency:
  group: claude-issue-${{ github.event.issue.number || github.event.pull_request.number || github.event.inputs.issue_number || 'default' }}
  cancel-in-progress: false

env:
  MAX_INFRASTRUCTURE_RETRIES: 3
  CLAUDE_TIMEOUT_MINUTES: 60

jobs:
  # Pre-check job: Validate context exists before running Claude Code
  # Prevents wasted resources when there's no spec to process
  validate-context:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      issues: read
    outputs:
      has_context: ${{ steps.check.outputs.has_context }}
      issue_number: ${{ steps.check.outputs.issue_number }}
      issue_body: ${{ steps.check.outputs.issue_body }}
    steps:
      - name: Check for valid context
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
          # Security: Use env vars for untrusted user input to prevent code injection
          EVENT_COMMENT_BODY: ${{ github.event.comment.body }}
          EVENT_ISSUE_BODY: ${{ github.event.issue.body }}
          EVENT_ISSUE_TITLE: ${{ github.event.issue.title }}
          EVENT_REVIEW_BODY: ${{ github.event.review.body }}
          COMMENT_USER: ${{ github.event.comment.user.login }}
        run: |
          HAS_CONTEXT="false"
          ISSUE_NUMBER=""
          ISSUE_BODY=""

          # Skip if comment is from Claude bot (prevents race condition with error comments)
          # Also skip "Claude Code is working" status comments (prevents self-cancellation)
          if [ "${{ github.event_name }}" = "issue_comment" ]; then
            if [ "$COMMENT_USER" = "claude[bot]" ]; then
              echo "Comment from Claude bot - skipping to prevent cancellation race"
              echo "has_context=false" >> $GITHUB_OUTPUT
              echo "issue_number=" >> $GITHUB_OUTPUT
              echo "issue_body<<EOF" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 0
            elif [[ "$EVENT_COMMENT_BODY" == *"Claude Code is working"* ]]; then
              echo "Claude Code status comment - skipping to prevent self-cancellation"
              echo "has_context=false" >> $GITHUB_OUTPUT
              echo "issue_number=" >> $GITHUB_OUTPUT
              echo "issue_body<<EOF" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # workflow_dispatch: Must have valid issue number
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ISSUE_NUMBER="${{ github.event.inputs.issue_number }}"
            if [ -n "$ISSUE_NUMBER" ]; then
              echo "Validating issue #$ISSUE_NUMBER (workflow_dispatch trigger)..."
              if gh issue view "$ISSUE_NUMBER" &>/dev/null; then
                ISSUE_BODY=$(gh issue view "$ISSUE_NUMBER" --json body --jq '.body')
                HAS_CONTEXT="true"
                echo "✅ Valid issue found: #$ISSUE_NUMBER"
              else
                echo "❌ Issue #$ISSUE_NUMBER not found - skipping workflow"
              fi
            else
              echo "❌ No issue number provided - skipping workflow"
            fi

          # issue_comment/PR review: Must have @claude mention and valid issue/PR
          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            if [[ "$EVENT_COMMENT_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.issue.number }}"
              ISSUE_BODY="$EVENT_ISSUE_BODY"
              HAS_CONTEXT="true"
              echo "✅ Valid @claude mention in issue #$ISSUE_NUMBER"
            else
              echo "⚠️  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
            if [[ "$EVENT_COMMENT_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.pull_request.number }}"
              HAS_CONTEXT="true"
              echo "✅ Valid @claude mention in PR #$ISSUE_NUMBER"
            else
              echo "⚠️  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "pull_request_review" ]; then
            if [[ "$EVENT_REVIEW_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.pull_request.number }}"
              HAS_CONTEXT="true"
              echo "✅ Valid @claude mention in PR review #$ISSUE_NUMBER"
            else
              echo "⚠️  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "issues" ]; then
            if [[ "$EVENT_ISSUE_BODY" == *"@claude"* ]] || [[ "$EVENT_ISSUE_TITLE" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.issue.number }}"
              ISSUE_BODY="$EVENT_ISSUE_BODY"
              HAS_CONTEXT="true"
              echo "✅ Valid @claude mention in issue #$ISSUE_NUMBER"
            else
              echo "⚠️  No @claude mention found - skipping workflow"
            fi
          fi

          # Additional validation: Check if issue is closed or has existing PRs
          if [ "$HAS_CONTEXT" = "true" ] && [ -n "$ISSUE_NUMBER" ]; then
            echo ""
            echo "Checking issue state and existing PRs for #$ISSUE_NUMBER..."

            # Check if issue is closed
            ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")

            if [ "$ISSUE_STATE" = "CLOSED" ]; then
              echo "⚠️  Issue #$ISSUE_NUMBER is CLOSED - skipping to prevent duplicate PR"
              echo "   A PR has already been merged or the issue was closed manually"
              HAS_CONTEXT="false"
              ISSUE_NUMBER=""
              ISSUE_BODY=""
            else
              # Check for any existing PR (open or closed) for this issue
              EXISTING_PR_COUNT=$(gh pr list \
                --repo ${{ github.repository }} \
                --search "Closes #$ISSUE_NUMBER in:body" \
                --state all \
                --json number \
                --jq 'length' 2>/dev/null || echo "0")

              if [ "$EXISTING_PR_COUNT" -gt 0 ]; then
                EXISTING_PRS=$(gh pr list \
                  --repo ${{ github.repository }} \
                  --search "Closes #$ISSUE_NUMBER in:body" \
                  --state all \
                  --json number,state \
                  --jq '[.[] | "#\(.number) (\(.state))"] | join(", ")' 2>/dev/null || echo "")

                echo "⚠️  Found $EXISTING_PR_COUNT existing PR(s) for issue #$ISSUE_NUMBER: $EXISTING_PRS"
                echo "   Skipping to prevent duplicate PR creation"
                echo "   If you need to retry, close/delete the existing PR first"

                # Post comment on issue explaining why we're skipping
                COMMENT_BODY="**Duplicate PR Prevention**

                Skipping Claude Code execution because PR(s) already exist for this issue: $EXISTING_PRS

                **To retry this spec:**
                1. Close or delete the existing PR if it's invalid
                2. Re-open this issue if it was closed
                3. Post a new @claude comment to trigger the workflow

                ---
                *Automated via Claude TDD Workflow*"

                gh issue comment "$ISSUE_NUMBER" --body "$COMMENT_BODY" 2>/dev/null || true

                HAS_CONTEXT="false"
                ISSUE_NUMBER=""
                ISSUE_BODY=""
              else
                echo "✅ Issue is open with no existing PRs - safe to proceed"
              fi
            fi
          fi

          # Output results
          echo "has_context=$HAS_CONTEXT" >> $GITHUB_OUTPUT
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Log concurrency group status for debugging workflow trigger issues
      # This helps diagnose cases where @claude comments don't trigger Claude Code
      - name: Log concurrency group status
        if: steps.check.outputs.has_context == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
        run: |
          echo "═══════════════════════════════════════════════════════════════════"
          echo "CONCURRENCY GROUP DEBUG INFO"
          echo "═══════════════════════════════════════════════════════════════════"

          CONCURRENCY_GROUP="claude-issue-$ISSUE_NUMBER"
          echo "Concurrency Group: $CONCURRENCY_GROUP"
          echo "Triggered at: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Event: ${{ github.event_name }}"
          echo "Sender: ${{ github.event.sender.login }}"

          # Check for other running workflows in the same concurrency group
          echo ""
          echo "Checking for other running workflows for issue #$ISSUE_NUMBER..."

          RUNNING_WORKFLOWS=$(gh run list \
            --workflow="TDD - Execute (Claude Code)" \
            --status=in_progress \
            --json databaseId,displayTitle,createdAt,event \
            --jq "[.[] | select(.displayTitle | contains(\"#$ISSUE_NUMBER\"))]" 2>/dev/null || echo "[]")

          RUNNING_COUNT=$(echo "$RUNNING_WORKFLOWS" | jq 'length' 2>/dev/null || echo "0")

          if [ "$RUNNING_COUNT" -gt 1 ]; then
            echo "WARNING: $RUNNING_COUNT workflows running for this issue!"
            echo "   This run may be queued due to concurrency group"
            echo ""
            echo "   Running workflows:"
            echo "$RUNNING_WORKFLOWS" | jq -r '.[] | "   - Run \(.databaseId) started \(.createdAt) via \(.event)"'
          elif [ "$RUNNING_COUNT" -eq 1 ]; then
            echo "✅ This is the only running workflow for issue #$ISSUE_NUMBER"
          else
            echo "ℹ️  No in-progress workflows found (this workflow is still starting)"
          fi

          # Check for queued workflows
          QUEUED_WORKFLOWS=$(gh run list \
            --workflow="TDD - Execute (Claude Code)" \
            --status=queued \
            --json databaseId,displayTitle,createdAt \
            --jq "[.[] | select(.displayTitle | contains(\"#$ISSUE_NUMBER\"))] | length" 2>/dev/null || echo "0")

          if [ "$QUEUED_WORKFLOWS" -gt 0 ]; then
            echo ""
            echo "$QUEUED_WORKFLOWS workflow(s) queued for this issue"
            echo "   These will run after current workflow completes"
          fi

          echo ""
          echo "═══════════════════════════════════════════════════════════════════"

  # Error classification: Determine if error is retriable at infrastructure level
  classify-previous-error:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.retry_attempt > 1
    permissions:
      actions: read
    outputs:
      is_infrastructure_error: ${{ steps.classify.outputs.is_infrastructure_error }}
      error_type: ${{ steps.classify.outputs.error_type }}
      should_retry: ${{ steps.classify.outputs.should_retry }}
    steps:
      - name: Classify previous run error
        id: classify
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
        run: |
          echo "Analyzing previous workflow run for error classification..."

          # Get the most recent failed run for this issue
          RECENT_RUN=$(gh run list \
            --workflow="tdd-execute.yml" \
            --status failure \
            --limit 5 \
            --json databaseId,conclusion,displayTitle \
            --jq ".[] | select(.displayTitle | contains(\"#$ISSUE_NUMBER\")) | .databaseId" \
            | head -1)

          if [ -z "$RECENT_RUN" ]; then
            echo "No recent failed run found - assuming infrastructure error"
            echo "is_infrastructure_error=true" >> $GITHUB_OUTPUT
            echo "error_type=unknown" >> $GITHUB_OUTPUT
            echo "should_retry=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Analyzing run #$RECENT_RUN..."

          # Get failure logs
          LOGS=$(gh run view "$RECENT_RUN" --log-failed || echo "")

          # Classify error type
          IS_INFRA_ERROR=false
          ERROR_TYPE="unknown"

          # Infrastructure errors (retriable at workflow level)
          if echo "$LOGS" | grep -q "EPERM: Operation not permitted"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="permission_error"
            echo "Detected: Permission error (EPERM)"
          elif echo "$LOGS" | grep -q "ETIMEDOUT\|timeout\|timed out"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="timeout"
            echo "Detected: Timeout error"
          elif echo "$LOGS" | grep -q "ECONNRESET\|ENOTFOUND\|socket hang up"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="network_error"
            echo "Detected: Network error"
          elif echo "$LOGS" | grep -q "out of memory\|OOM\|killed"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="resource_exhaustion"
            echo "Detected: Resource exhaustion"
          elif echo "$LOGS" | grep -q "ENOSPC\|no space left"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="disk_full"
            echo "Detected: Disk space error"
          elif echo "$LOGS" | grep -q "cancelled\|canceled"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="workflow_cancelled"
            echo "Detected: Workflow cancellation"
          # Code/test errors - NOW RETRIABLE with error context for Claude to self-correct
          elif echo "$LOGS" | grep -q "lint.*error\|ESLint.*error\|functional/immutable-data\|no-restricted-syntax"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="lint_error"
            echo "Detected: Lint error - WILL RETRY with fix instructions"
          elif echo "$LOGS" | grep -q "Test.*failed\|FAIL\|AssertionError"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="test_failure"
            echo "Detected: Test failure - WILL RETRY with fix instructions"
          elif echo "$LOGS" | grep -q "SyntaxError\|TypeError\|ReferenceError"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="code_error"
            echo "Detected: Code error - WILL RETRY with fix instructions"
          fi

          # Determine if should retry
          SHOULD_RETRY=false
          if [ "$IS_INFRA_ERROR" = true ]; then
            SHOULD_RETRY=true
            echo "Error detected - WILL RETRY (Claude can self-correct)"
          else
            echo "Unknown error - will NOT retry"
          fi

          # Output results
          echo "is_infrastructure_error=$IS_INFRA_ERROR" >> $GITHUB_OUTPUT
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT
          echo "should_retry=$SHOULD_RETRY" >> $GITHUB_OUTPUT

  # Phase 1: E2E Test Fixer - Make RED tests GREEN
  # Only runs e2e-test-fixer agent. Finalization and refactoring handled by separate jobs.
  execute-e2e-fixer:
    runs-on: ubuntu-latest
    timeout-minutes: 65 # Reduced from 95 (60 min Claude + 5 min cleanup)
    needs: [validate-context, classify-previous-error]
    if: |
      always() &&
      needs.validate-context.outputs.has_context == 'true' &&
      (needs.classify-previous-error.result == 'skipped' ||
       needs.classify-previous-error.outputs.should_retry == 'true') &&
      github.event.sender.login != 'claude[bot]' &&
      (
        github.event_name == 'workflow_dispatch' ||
        (github.event_name != 'workflow_dispatch' && (
          github.event.comment.author_association == 'OWNER' ||
          github.event.comment.author_association == 'MEMBER' ||
          github.event.comment.author_association == 'COLLABORATOR' ||
          github.event.issue.author_association == 'OWNER' ||
          github.event.issue.author_association == 'MEMBER' ||
          github.event.issue.author_association == 'COLLABORATOR' ||
          github.event.review.author_association == 'OWNER' ||
          github.event.review.author_association == 'MEMBER' ||
          github.event.review.author_association == 'COLLABORATOR' ||
          github.event.sender.login == 'github-actions[bot]' ||
          github.event.sender.login == 'github-actions' ||
          github.event.sender.login == 'app/github-actions' ||
          github.event.issue.user.login == 'github-actions[bot]' ||
          github.event.issue.user.login == 'github-actions' ||
          github.event.issue.user.login == 'app/github-actions' ||
          github.event.comment.user.login == 'github-actions[bot]' ||
          github.event.comment.user.login == 'github-actions' ||
          github.event.comment.user.login == 'app/github-actions'
        ))
      )
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read
    outputs:
      claude_success: ${{ steps.set_success.outputs.claude_success }}
      claude_exit_code: ${{ steps.claude.outcome }}
      error_type: ${{ steps.detect_error.outputs.error_type }}
      is_infrastructure_error: ${{ steps.detect_error.outputs.is_infrastructure_error }}
      has_branch: ${{ steps.set_success.outputs.has_branch }}
      branch_name: ${{ steps.set_success.outputs.branch_name }}
      spec_id: ${{ steps.issue.outputs.spec_id }}
      issue_number: ${{ steps.issue.outputs.issue_number }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set issue context
        id: issue
        env:
          # Security: Use env var to prevent code injection from untrusted issue body
          ISSUE_BODY_INPUT: ${{ needs.validate-context.outputs.issue_body }}
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ needs.validate-context.outputs.issue_number }}
        run: |
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY_INPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Extract spec ID from issue title or body
          ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title --jq '.title' 2>/dev/null || echo "")
          SPEC_ID=$(echo "$ISSUE_TITLE" | grep -oE '[A-Z]+-[A-Z]+-[A-Z0-9-]+' | head -1 || echo "")
          if [ -z "$SPEC_ID" ]; then
            SPEC_ID=$(echo "$ISSUE_BODY_INPUT" | grep -oE '[A-Z]+-[A-Z]+-[A-Z0-9-]+' | head -1 || echo "unknown-spec")
          fi
          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT
          echo "Extracted spec_id: $SPEC_ID"

      # =========================================================================
      # Usage tracking is BLOCKING with fail-closed behavior
      # See: docs/development/claude-code-usage-tracking.md
      # =========================================================================
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Check usage limits (fail-closed)
        id: usage
        run: |
          echo "Checking usage limits before Claude Code execution..."
          # Run usage check and capture exit code
          set +e
          bun run scripts/tdd-automation/check-claude-code-usage.ts --check
          EXIT_CODE=$?
          set -e

          # Mark that script completed (even if limits exceeded)
          echo "script_completed=true" >> $GITHUB_OUTPUT

          # Exit with the script's exit code
          exit $EXIT_CODE
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TDD_DAILY_COST_LIMIT: '15.00'
          TDD_WEEKLY_COST_LIMIT: '90.00'
        continue-on-error: true

      - name: Fail if usage check crashed (fail-closed safety)
        if: steps.usage.outcome == 'failure' && steps.usage.outputs.script_completed != 'true'
        run: |
          echo "CRITICAL: Usage check script crashed before completion!"
          echo ""
          echo "This is a fail-closed safety mechanism. The workflow cannot proceed"
          echo "because we cannot verify that usage is within limits."
          echo ""
          echo "Possible causes:"
          echo "  - Network timeout fetching workflow logs"
          echo "  - GitHub API authentication failure"
          echo "  - Script parsing error"
          echo ""
          echo "Action required: Investigate the usage check step logs above."
          exit 1

      - name: Skip if usage limits exceeded
        if: steps.usage.outcome == 'failure' && steps.usage.outputs.script_completed == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
        run: |
          echo "Usage limits exceeded - graceful skip"
          echo "   Reason: ${{ steps.usage.outputs.reason || 'limits_exceeded' }}"
          echo "   Daily cost: ${{ steps.usage.outputs.daily_cost || 'unknown' }}"
          echo "   Weekly cost: ${{ steps.usage.outputs.weekly_cost || 'unknown' }}"
          echo ""
          echo "Skipping Claude Code execution until usage is reduced."

          # Post comment on issue explaining the skip
          gh issue comment "$ISSUE_NUMBER" --body "**Usage Limit Reached**: Claude Code execution paused due to usage limits. Will retry when usage is reduced.

          - Daily cost: \${{ steps.usage.outputs.daily_cost || 'unknown' }}
          - Weekly cost: \${{ steps.usage.outputs.weekly_cost || 'unknown' }}

          ---
          *TDD Automation - Usage Tracking*" 2>/dev/null || true

          exit 0

      - name: Run Claude Code (e2e-test-fixer only)
        id: claude
        uses: anthropics/claude-code-action@v1
        timeout-minutes: 60
        continue-on-error: true # Capture exit code instead of failing immediately
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          # Use PAT with 'workflows' scope for git push operations
          # GitHub requires 'workflows' scope to push to repos containing .github/workflows/ files
          # Comments will appear from your personal account (not claude[bot])
          github_token: ${{ secrets.GH_PAT_WORKFLOW }}
          additional_permissions: |
            actions: read
          # NO prompt field - Claude Code will read the @claude comment naturally
          # This allows the queue processor's detailed instructions to be used
          # Agents are auto-discovered from .claude/agents/ directory (no --agents flag needed)
          #
          # Claude Code Best Practices (per https://code.claude.com/docs/github-actions):
          # - --model: Explicit model for cost predictability (Sonnet 4 is cost-effective for TDD)
          # - --max-budget-usd: Reduced to $5 (e2e-test-fixer only, refactor-auditor runs separately)
          # - --allowedTools: Principle of least privilege - only tools needed for TDD workflow
          # - --disallowedTools: Block tools not needed for autonomous code implementation
          #   - AskUserQuestion: No human present in automation (would hang or skip)
          #   - WebFetch/WebSearch: External content not needed
          #   - NotebookEdit: No Jupyter notebooks in project
          #   - SlashCommand: Prevents unintended command execution
          claude_args: >-
            --model claude-sonnet-4-5-20250929
            --max-budget-usd 5.00
            --allowedTools Edit,Read,Write,Bash,Glob,Grep,Task,TodoWrite,Skill,LSP
            --disallowedTools WebFetch,WebSearch,AskUserQuestion,NotebookEdit,SlashCommand

      - name: Detect error type
        id: detect_error
        if: always()
        run: |
          echo "Analyzing Claude Code execution..."

          # Check Claude Code exit behavior
          CLAUDE_OUTCOME="${{ steps.claude.outcome }}"

          IS_INFRA_ERROR=false
          ERROR_TYPE="unknown"

          # Calculate step duration to detect timeout (GitHub marks some timeouts as "success")
          START_TIME="${{ steps.claude.outputs.startedAt || '' }}"
          END_TIME="${{ steps.claude.outputs.completedAt || '' }}"

          # If timestamps are available, calculate duration
          if [ -n "$START_TIME" ] && [ -n "$END_TIME" ]; then
            START_EPOCH=$(date -d "$START_TIME" +%s 2>/dev/null || echo "0")
            END_EPOCH=$(date -d "$END_TIME" +%s 2>/dev/null || echo "0")

            if [ "$START_EPOCH" -ne 0 ] && [ "$END_EPOCH" -ne 0 ]; then
              DURATION=$((END_EPOCH - START_EPOCH))
              echo "Step duration: ${DURATION}s"

              # Timeout detection: anything > 74 minutes (4440 seconds) is likely a timeout
              if [ "$DURATION" -ge 4440 ]; then
                IS_INFRA_ERROR=true
                ERROR_TYPE="timeout_confirmed"
                echo "TIMEOUT DETECTED: Step ran for ${DURATION}s (>= 4440s threshold)"
              fi
            fi
          fi

          # If not already classified as timeout, check outcome
          if [ "$ERROR_TYPE" = "unknown" ]; then
            if [ "$CLAUDE_OUTCOME" = "cancelled" ]; then
              # Cancelled usually means timeout or manual cancellation
              IS_INFRA_ERROR=true
              ERROR_TYPE="cancelled_timeout"
              echo "Step was cancelled - treating as timeout"
            elif [ "$CLAUDE_OUTCOME" = "failure" ]; then
              # For failures, check if it's infrastructure or code issue
              # Look for common infrastructure error patterns in logs if available
              ERROR_TYPE="claude_failure"
              echo "Claude Code failed - checking for infrastructure issues..."

              # Default to infrastructure error for retries (conservative approach)
              IS_INFRA_ERROR=true
            elif [ "$CLAUDE_OUTCOME" = "success" ]; then
              # Even success might be a timeout if duration is suspicious
              if [ "$ERROR_TYPE" != "timeout_confirmed" ]; then
                ERROR_TYPE="success"
                echo "Claude Code completed successfully"
              fi
            else
              ERROR_TYPE="unknown_outcome"
              echo "Unknown outcome: $CLAUDE_OUTCOME"
              IS_INFRA_ERROR=true
            fi
          fi

          echo "is_infrastructure_error=$IS_INFRA_ERROR" >> $GITHUB_OUTPUT
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT

      # CRITICAL: Explicitly set success output to fix detection issue
      # GitHub Actions has issues with expression-based outputs when steps use continue-on-error
      # This step explicitly captures both success state and branch existence for fallback
      - name: Set success output
        id: set_success
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
          CLAUDE_OUTCOME: ${{ steps.claude.outcome }}
        run: |
          echo "Setting success output..."
          echo "   Claude outcome: $CLAUDE_OUTCOME"

          # Explicitly set claude_success based on outcome
          if [ "$CLAUDE_OUTCOME" = "success" ]; then
            echo "claude_success=true" >> $GITHUB_OUTPUT
            echo "✅ Claude completed successfully"
          else
            echo "claude_success=false" >> $GITHUB_OUTPUT
            echo "❌ Claude did not complete successfully (outcome: $CLAUDE_OUTCOME)"
          fi

          # Also check if a branch was created (fallback indicator)
          # This allows verify-success to run even if claude_success detection fails
          BRANCH_PATTERN="claude/issue-${ISSUE_NUMBER}-"
          BRANCH_NAME=$(gh api "/repos/$REPO/branches" \
            --jq "[.[] | select(.name | startswith(\"$BRANCH_PATTERN\"))][0].name" 2>/dev/null || echo "")

          if [ -n "$BRANCH_NAME" ] && [ "$BRANCH_NAME" != "null" ]; then
            echo "has_branch=true" >> $GITHUB_OUTPUT
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "✅ Branch exists: $BRANCH_NAME"
          else
            echo "has_branch=false" >> $GITHUB_OUTPUT
            echo "branch_name=" >> $GITHUB_OUTPUT
            echo "⚠️  No branch found with pattern: $BRANCH_PATTERN"
          fi

      - name: Update issue on failure
        # Only post failure comment if Claude failed AND no branch was pushed
        # Branch existence = work completed successfully (false negative on step outcome)
        if: steps.claude.outcome != 'success' && steps.set_success.outputs.has_branch != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
          RETRY_ATTEMPT: ${{ github.event.inputs.retry_attempt || 1 }}
          ERROR_TYPE: ${{ steps.detect_error.outputs.error_type }}
        run: |
          echo "Updating issue #$ISSUE_NUMBER with failure information..."

          gh issue comment "$ISSUE_NUMBER" --body "**Claude Code Execution Failed (Attempt $RETRY_ATTEMPT)**

          **Error Type**: \`$ERROR_TYPE\`
          **Workflow Run**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          The automation system will analyze this error and retry if appropriate.

          ---
          *Infrastructure Error Handler*"

  # =========================================================================
  # PHASE 2: Finalize e2e-test-fixer changes
  # =========================================================================
  # Workflow-managed finalization ensures reliability:
  # - bun run license (Claude can forget)
  # - Commit amend if changes
  # - Detect src/ modifications for conditional refactor-auditor
  # - Push to remote
  # =========================================================================
  finalize-fixer:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [execute-e2e-fixer]
    if: |
      always() &&
      needs.execute-e2e-fixer.outputs.has_branch == 'true'
    permissions:
      contents: write
      issues: write
    outputs:
      src_modified: ${{ steps.detect_changes.outputs.src_modified }}
      push_success: ${{ steps.push.outputs.success }}
    steps:
      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.execute-e2e-fixer.outputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Configure git
        run: |
          USER_NAME=$(gh api user --jq '.login')
          USER_EMAIL=$(gh api user --jq '.email')
          git config user.name "$USER_NAME"
          git config user.email "$USER_EMAIL"
          echo "Git configured as $USER_NAME <$USER_EMAIL>"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Run license script
        run: |
          echo "Running bun run license..."
          bun run license

      - name: Amend commit if license added files
        run: |
          if ! git diff --quiet; then
            echo "License script made changes - amending commit..."
            git add -A
            git commit --amend --no-edit
            echo "Commit amended with license headers"
          else
            echo "No license changes needed"
          fi

      - name: Detect src/ modifications
        id: detect_changes
        run: |
          echo "Detecting if src/ files were modified..."

          # Compare branch to main
          git fetch origin main
          SRC_CHANGES=$(git diff --name-only origin/main...HEAD | grep '^src/' | wc -l | tr -d ' ')

          echo "Files in src/ changed: $SRC_CHANGES"

          if [ "$SRC_CHANGES" -gt 0 ]; then
            echo "src_modified=true" >> $GITHUB_OUTPUT
            echo "src/ modifications detected - refactor-auditor will run"
            git diff --name-only origin/main...HEAD | grep '^src/' | head -10
          else
            echo "src_modified=false" >> $GITHUB_OUTPUT
            echo "No src/ modifications - refactor-auditor will be skipped"
          fi

      - name: Push changes
        id: push
        run: |
          echo "Pushing finalized changes..."
          if git push --force-with-lease origin ${{ needs.execute-e2e-fixer.outputs.branch_name }}; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "Push successful"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "Push failed"
            exit 1
          fi

  # =========================================================================
  # PHASE 3: Codebase Refactor Auditor (CONDITIONAL)
  # =========================================================================
  # Only runs if src/ files were modified by e2e-test-fixer.
  # Skipped for test-only changes (saves $5 and 30 min).
  # =========================================================================
  execute-refactor-auditor:
    runs-on: ubuntu-latest
    timeout-minutes: 35
    needs: [execute-e2e-fixer, finalize-fixer]
    if: |
      always() &&
      needs.finalize-fixer.outputs.src_modified == 'true' &&
      needs.finalize-fixer.outputs.push_success == 'true'
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read
    outputs:
      claude_success: ${{ steps.set_success.outputs.claude_success }}
      has_changes: ${{ steps.set_success.outputs.has_changes }}
    steps:
      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.execute-e2e-fixer.outputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Post refactor-auditor comment
        id: post_comment
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          ISSUE_NUMBER: ${{ needs.execute-e2e-fixer.outputs.issue_number }}
          SPEC_ID: ${{ needs.execute-e2e-fixer.outputs.spec_id }}
        run: |
          echo "Posting @claude comment for refactor-auditor phase..."

          gh issue comment "$ISSUE_NUMBER" --body "@claude run codebase-refactor-auditor for $SPEC_ID

          ## Phase 2: Refactoring Audit

          The e2e-test-fixer phase is complete. Now run codebase-refactor-auditor to ensure code quality.

          **Your Task**:
          Use \`Task\` tool with \`subagent_type='codebase-refactor-auditor'\` to:
          1. Audit layer architecture compliance
          2. Eliminate code duplication
          3. Run \`bun run quality\` to verify all checks pass
          4. Commit any improvements as \`refactor: audit $SPEC_ID\`
          5. Push to branch

          **What You Should NOT Do**:
          - DO NOT run \`bun run license\` (finalization job handles this)
          - DO NOT create PR (workflow handles this)

          ---
          *Automated via TDD Workflow (Phase 2: Refactor Audit)*"

          echo "Comment posted"

      - name: Run Claude Code (codebase-refactor-auditor)
        id: claude
        uses: anthropics/claude-code-action@v1
        timeout-minutes: 30
        continue-on-error: true
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GH_PAT_WORKFLOW }}
          additional_permissions: |
            actions: read
          # Budget reduced to $5 for refactor-auditor phase
          claude_args: >-
            --model claude-sonnet-4-5-20250929
            --max-budget-usd 5.00
            --allowedTools Edit,Read,Write,Bash,Glob,Grep,Task,TodoWrite,Skill,LSP
            --disallowedTools WebFetch,WebSearch,AskUserQuestion,NotebookEdit,SlashCommand

      - name: Set success output
        id: set_success
        if: always()
        run: |
          CLAUDE_OUTCOME="${{ steps.claude.outcome }}"

          if [ "$CLAUDE_OUTCOME" = "success" ]; then
            echo "claude_success=true" >> $GITHUB_OUTPUT
            echo "Refactor-auditor completed successfully"
          else
            echo "claude_success=false" >> $GITHUB_OUTPUT
            echo "Refactor-auditor did not complete successfully (outcome: $CLAUDE_OUTCOME)"
          fi

          # Check if any changes were made
          if ! git diff --quiet HEAD~1..HEAD 2>/dev/null; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

  # =========================================================================
  # PHASE 4: Finalize refactor-auditor changes
  # =========================================================================
  finalize-auditor:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [execute-e2e-fixer, execute-refactor-auditor]
    # Run when refactor-auditor succeeds OR when it made changes (even if Claude failed after)
    # This ensures changes are pushed even if Claude encounters API errors post-commit
    if: |
      always() &&
      (needs.execute-refactor-auditor.result == 'success' ||
       needs.execute-refactor-auditor.outputs.has_changes == 'true')
    permissions:
      contents: write
    steps:
      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.execute-e2e-fixer.outputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Configure git
        run: |
          USER_NAME=$(gh api user --jq '.login')
          USER_EMAIL=$(gh api user --jq '.email')
          git config user.name "$USER_NAME"
          git config user.email "$USER_EMAIL"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Run license script
        run: bun run license

      - name: Amend commit if license added files
        run: |
          if ! git diff --quiet; then
            echo "License script made changes - amending commit..."
            git add -A
            git commit --amend --no-edit
            echo "Commit amended"
          fi

      - name: Push changes
        run: |
          git push --force-with-lease origin ${{ needs.execute-e2e-fixer.outputs.branch_name }}
          echo "Final push complete"

  # Retry logic: Automatically retry infrastructure errors
  handle-retry:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [execute-e2e-fixer]
    # Only retry if:
    # 1. Claude didn't report success AND
    # 2. No branch was created (branch existence = work completed, just false negative on outcome) AND
    # 3. The failure was infrastructure-related (not a code/logic error)
    if: |
      always() &&
      needs.execute-e2e-fixer.outputs.claude_success != 'true' &&
      needs.execute-e2e-fixer.outputs.has_branch != 'true' &&
      needs.execute-e2e-fixer.outputs.is_infrastructure_error == 'true'
    permissions:
      actions: write
      issues: write
    steps:
      - name: Determine retry action
        id: retry
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          CURRENT_RETRY: ${{ github.event.inputs.retry_attempt || 1 }}
          MAX_RETRIES: ${{ env.MAX_INFRASTRUCTURE_RETRIES }}
          ERROR_TYPE: ${{ needs.execute-e2e-fixer.outputs.error_type }}
        run: |
          echo "Error detected: $ERROR_TYPE"
          echo "Current retry attempt: $CURRENT_RETRY of $MAX_RETRIES"

          NEXT_RETRY=$((CURRENT_RETRY + 1))

          if [ "$NEXT_RETRY" -le "$MAX_RETRIES" ]; then
            echo "✅ Will retry (attempt $NEXT_RETRY)"
            echo "should_retry=true" >> $GITHUB_OUTPUT
            echo "next_retry=$NEXT_RETRY" >> $GITHUB_OUTPUT

            # Add retry label based on error type (using consistent retry:* prefix)
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" --add-label "retry:spec:$CURRENT_RETRY" 2>/dev/null || true
            else
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" --add-label "retry:infra:$CURRENT_RETRY" 2>/dev/null || true
            fi

            # Build retry comment with error-specific instructions
            if [ "$ERROR_TYPE" = "lint_error" ]; then
              RETRY_COMMENT="**Automatic Code Fix Retry**

          **Error Type**: \`$ERROR_TYPE\` (ESLint violation)
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

          **CRITICAL FIX INSTRUCTIONS FOR CLAUDE:**
          1. Run \`bun run lint\` to see the exact ESLint errors
          2. **Common FP violations to fix:**
             - ❌ \`array.push()\` → ✅ Use \`[...array, item]\`
             - ❌ \`for/while\` loops → ✅ Use \`map/filter/reduce\`
             - ❌ Mutable \`const arr = []\` → ✅ Use immutable patterns
          3. Fix ALL lint errors before committing
          4. Run \`bun run quality\` to verify

          Retrying with fix instructions...

          ---
          *TDD Error Handler*"
            elif [ "$ERROR_TYPE" = "test_failure" ]; then
              RETRY_COMMENT="**Automatic Test Fix Retry**

          **Error Type**: \`$ERROR_TYPE\`
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

          **FIX INSTRUCTIONS FOR CLAUDE:**
          1. Run \`bun test:e2e -- <test-file>\` to see failing tests
          2. Analyze the error output and fix the implementation
          3. Ensure ALL tests in the file pass before committing
          4. Run \`bun run quality\` to verify

          Retrying with fix instructions...

          ---
          *TDD Error Handler*"
            elif [ "$ERROR_TYPE" = "code_error" ]; then
              RETRY_COMMENT="**Automatic Code Fix Retry**

          **Error Type**: \`$ERROR_TYPE\` (Syntax/Type error)
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

          **FIX INSTRUCTIONS FOR CLAUDE:**
          1. Run \`bun run typecheck\` to see TypeScript errors
          2. Fix all type errors before committing
          3. Run \`bun run quality\` to verify

          Retrying with fix instructions...

          ---
          *TDD Error Handler*"
            else
              RETRY_COMMENT="**Automatic Infrastructure Retry**

          **Error Type**: \`$ERROR_TYPE\`
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES
          **Reason**: Infrastructure/environment error (not code-related)

          Retrying workflow automatically with exponential backoff...

          ---
          *Infrastructure Error Handler*"
            fi

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$RETRY_COMMENT"

            # Exponential backoff with jitter to avoid thundering herd
            # Delays: 60s (retry 1→2), 120s (retry 2→3), 240s (retry 3→4)
            BASE_DELAY=$((60 * (1 << (CURRENT_RETRY - 1))))

            # Add jitter (±25% randomness)
            JITTER_RANGE=$((BASE_DELAY / 4))
            JITTER=$((RANDOM % (JITTER_RANGE * 2 + 1) - JITTER_RANGE))
            ACTUAL_DELAY=$((BASE_DELAY + JITTER))

            # Ensure minimum 30s delay
            if [ "$ACTUAL_DELAY" -lt 30 ]; then
              ACTUAL_DELAY=30
            fi

            echo "Waiting ${ACTUAL_DELAY}s before retry (base: ${BASE_DELAY}s, jitter: ${JITTER}s)"
            sleep "$ACTUAL_DELAY"
          else
            echo "❌ Max retries exhausted ($MAX_RETRIES)"
            echo "should_retry=false" >> $GITHUB_OUTPUT

            # Mark as failed with appropriate label (using failure:* prefix for consistency)
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:failed" \
                --add-label "failure:spec" 2>/dev/null || true
            else
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:failed" \
                --add-label "failure:infra" 2>/dev/null || true
            fi

            # Build failure message based on error type
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              FAILURE_COMMENT="**Code Error - Max Retries Exhausted**

          **Error Type**: \`$ERROR_TYPE\`
          **Total Attempts**: $MAX_RETRIES
          **Status**: Marked as \`tdd-spec:failed\`

          Claude was unable to fix the code errors after $MAX_RETRIES attempts. Manual intervention required.

          **Possible Solutions**:
          1. Check the PR for specific error details
          2. Manually fix the code and push
          3. Review the agent instructions for missing patterns
          4. Skip automation and implement manually

          The queue processor will continue with the next spec.

          ---
          *TDD Error Handler*"
            else
              FAILURE_COMMENT="**Infrastructure Error - Max Retries Exhausted**

          **Error Type**: \`$ERROR_TYPE\`
          **Total Attempts**: $MAX_RETRIES
          **Status**: Marked as \`tdd-spec:failed\`

          This spec failed due to infrastructure/environment errors, not code issues. Manual intervention required.

          **Possible Solutions**:
          1. Check GitHub Actions runner status
          2. Check if Claude Code API is experiencing issues
          3. Manually retry via workflow_dispatch
          4. Skip automation and implement manually

          The queue processor will continue with the next spec.

          ---
          *Infrastructure Error Handler*"
            fi

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$FAILURE_COMMENT"
          fi

      - name: Alert on high failure rate
        if: steps.retry.outputs.should_retry != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
        run: |
          echo "Checking for high failure rate..."

          # Count failed specs in last 24 hours
          CUTOFF_DATE=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-24H +%Y-%m-%dT%H:%M:%SZ)

          FAILED_COUNT=$(gh issue list \
            --repo "$REPO" \
            --label "tdd-spec:failed" \
            --state all \
            --json number,createdAt,labels \
            --jq "[.[] | select(.createdAt > \"$CUTOFF_DATE\")] | length")

          echo "Failed specs in last 24h: $FAILED_COUNT"

          # Create incident if >= 5 failures
          if [ "$FAILED_COUNT" -ge 5 ]; then
            echo "High failure rate detected - creating incident..."

            # Check if incident already exists
            EXISTING_INCIDENT=$(gh issue list \
              --repo "$REPO" \
              --label "incident,high-failure-rate" \
              --state open \
              --json number \
              --jq 'length')

            if [ "$EXISTING_INCIDENT" -eq 0 ]; then
              # Get list of failed spec IDs
              FAILED_SPECS=$(gh issue list \
                --repo "$REPO" \
                --label "tdd-spec:failed" \
                --state all \
                --limit 10 \
                --json number,createdAt,title \
                --jq "[.[] | select(.createdAt > \"$CUTOFF_DATE\")] | map(\"- #\(.number): \(.title)\") | join(\"\n\")")

              gh issue create \
                --repo "$REPO" \
                --title "TDD Automation: High Failure Rate ($FAILED_COUNT specs failed in 24h)" \
                --label "incident,high-failure-rate,tdd-automation,priority:high" \
                --body "## High TDD Spec Failure Rate"$'\n\n'"Failed Specs (24h): $FAILED_COUNT"$'\n'"Threshold: 5"$'\n\n'"### Recent Failures"$'\n'"$FAILED_SPECS"$'\n\n'"### Investigation Steps"$'\n'"1. Check for common error patterns: \`gh issue list --label tdd-spec:failed --limit 20\`"$'\n'"2. Review tdd-execute.yml runs: [Workflow History](https://github.com/$REPO/actions/workflows/tdd-execute.yml)"$'\n'"3. Check infrastructure health: \`gh run list --workflow tdd-monitor.yml\`"$'\n\n'"### Possible Causes"$'\n'"- Systemic test issues (flaky tests, environment problems)"$'\n'"- Infrastructure instability (runner timeouts, permission errors)"$'\n'"- Schema/API changes breaking multiple specs"$'\n'"- Claude Code regression (instruction following issues)"$'\n\n'"### Resolution"$'\n'"Once root cause identified and fixed:"$'\n'"1. Re-queue failed specs: \`gh issue edit ISSUE_NUMBER --remove-label tdd-spec:failed --add-label tdd-spec:queued\`"$'\n'"2. Close this incident"$'\n'"3. Document in TDD-TROUBLESHOOTING.md"$'\n\n'"---"$'\n'"Automated via [TDD Monitor](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"

              echo "✅ Incident issue created"
            else
              echo "Incident already exists, skipping creation"
            fi
          else
            echo "Failure rate acceptable ($FAILED_COUNT < 5)"
          fi

      - name: Trigger retry workflow
        if: steps.retry.outputs.should_retry == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          NEXT_RETRY: ${{ steps.retry.outputs.next_retry }}
        run: |
          echo "Triggering retry workflow (attempt $NEXT_RETRY)..."

          # Trigger the workflow - capture exit status to allow fallback on failure
          # Bug fix: Previously, failure here would exit immediately due to set -e,
          # preventing the fallback @claude comment from being posted
          DISPATCH_FAILED=false
          if ! gh workflow run tdd-execute.yml --repo "$REPO" \
            --field issue_number="$ISSUE_NUMBER" \
            --field retry_attempt="$NEXT_RETRY" 2>&1; then
            echo "Workflow dispatch failed (likely 403 permission error) - will use fallback"
            DISPATCH_FAILED=true
          fi

          # Skip verification if dispatch already failed - go straight to fallback
          RETRY_STARTED=false
          if [ "$DISPATCH_FAILED" != "true" ]; then
            # Wait for workflow to start
            echo "Verifying retry workflow started..."
            sleep 15

            # Check if workflow started in the last 20 seconds
            NOW=$(date +%s)

            # Get recent runs with error handling
            RECENT_RUNS=$(gh run list \
              --workflow tdd-execute.yml \
              --repo "$REPO" \
              --limit 5 \
              --json event,createdAt,status 2>&1) || true

            # Validate JSON before parsing
            if echo "$RECENT_RUNS" | jq empty 2>/dev/null; then
              # Check for a workflow_dispatch run created in the last 20 seconds
              # Bug fix: Use process substitution to avoid subshell variable scope issue
              while read -r run; do
                if [ -n "$run" ]; then
                  CREATED_AT=$(echo "$run" | jq -r '.createdAt' 2>/dev/null || echo "")
                  if [ -n "$CREATED_AT" ]; then
                    CREATED_EPOCH=$(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s 2>/dev/null || echo 0)
                    AGE=$((NOW - CREATED_EPOCH))

                    if [ "$AGE" -lt 20 ]; then
                      RETRY_STARTED=true
                      echo "✅ Retry workflow started successfully"
                      break
                    fi
                  fi
                fi
              done < <(echo "$RECENT_RUNS" | jq -r '.[] | select(.event == "workflow_dispatch")' 2>/dev/null)
            else
              echo "Failed to parse workflow runs (JSON error) - will use fallback method"
            fi
          fi

          # If workflow didn't start, use issue comment as fallback
          if [ "$RETRY_STARTED" != "true" ]; then
            echo "Workflow dispatch may have failed, triggering via issue comment as fallback..."

            # Get spec details from issue for context
            SPEC_ID=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json title --jq '.title' | grep -oP '[A-Z]+-[A-Z]+-([0-9]+|REGRESSION)' || echo "unknown")
            TEST_FILE=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json body --jq '.body' | grep -oP 'Test File.*`\K[^`]+' || echo "unknown")

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "@claude retry implementation (automated retry $NEXT_RETRY of 3 - workflow dispatch fallback)

            ## Spec Details

            - **Test File**: \`$TEST_FILE\`
            - **Spec ID**: \`$SPEC_ID\`
            - **Issue**: #$ISSUE_NUMBER
            - **Retry Attempt**: $NEXT_RETRY of 3
            - **Trigger**: Workflow dispatch failed, using comment fallback

            ## Retry Context

            Check for previous work before starting:
            1. Run \`git status\` to see if uncommitted changes exist
            2. Run \`git log --oneline -5\` to see recent commits
            3. If work exists, continue from where it left off
            4. If clean state, start fresh with step 1 below

            ## Automation Mode

            **You are in pipeline/automation mode**:
            - ✅ Make autonomous decisions following Sovrium patterns
            - ✅ Implement minimal code to pass the test
            - ❌ DO NOT ask questions - proceed with best judgment
            - ❌ DO NOT skip any steps - all are MANDATORY

            ## Critical Steps (ALL REQUIRED)

            1. **Run e2e-test-fixer agent** - Use \`Task\` tool with \`subagent_type='e2e-test-fixer'\` to remove \`.fixme()\` from \`$SPEC_ID\` and implement minimal code to pass the test
            2. **Run codebase-refactor-auditor agent** - Use \`Task\` tool with \`subagent_type='codebase-refactor-auditor'\`:
               - **If src/ files changed**: Full audit (layer architecture, code quality, refactoring) + \`bun run quality\`
               - **If NO src/ files changed** (test-only): Quick Exit - runs \`bun run quality\` only, skips full audit
               - Agent auto-detects and handles appropriately - ensures quality passes before proceeding
            3. **Commit and push** - Run \`bun run license\`, then commit as \`fix: implement $SPEC_ID\`, push to branch

            ⚠️ **IMPORTANT: DO NOT CREATE PR** - The workflow will create the PR automatically after you push.

            ## Error Handling

            - **If \`bun run quality\` fails**:
              1. Read the FULL error output carefully
              2. Fix ALL failing checks (ESLint, TypeScript, Effect diagnostics, unit tests, E2E)
              3. Re-run \`bun run quality\` until it passes completely
              4. Only THEN proceed to commit and push
            - **If layer architecture violations**: Fix cross-layer imports before proceeding - domain must be pure

            ## MOST COMMON FAILURES (Learn from history)

            - Skipping codebase-refactor-auditor → technical debt accumulates
            - **Creating commits with failing regression tests** (PR #4846) → CI fails, PR blocked - ALWAYS run \`bun run quality\` and fix ALL failures before commit
            - Not pushing to branch → workflow can't create PR

            **Complete workflow documentation**: \`@docs/development/tdd-automation-pipeline.md\`

            ---
            *Infrastructure Retry Handler (Fallback)*"

            echo "✅ Fallback retry triggered via issue comment with full context"
          fi

  # =========================================================================
  # PHASE 5: Verify success and create PR
  # =========================================================================
  # IMPORTANT: Claude Code can run for up to 60 minutes. During that time:
  # - Another workflow might have already created and merged a PR for this issue
  # - The issue might have been closed by a merged PR
  # This job detects and handles these duplicate PR scenarios
  #
  # RELIABILITY FIX: Run this job when EITHER:
  # - finalize-fixer succeeded (branch was pushed after e2e-test-fixer)
  # - finalize-auditor succeeded (branch was pushed after refactor-auditor)
  # - has_branch == 'true' (fallback: Claude pushed a branch but success detection failed)
  #
  # Note: finalize-auditor may be skipped if no src/ changes were made.
  # =========================================================================
  verify-success:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [execute-e2e-fixer, finalize-fixer, finalize-auditor]
    # Run when:
    # - finalize-fixer pushed successfully (test-only changes or src changes before auditor)
    # - finalize-auditor succeeded (full workflow with src changes)
    # - has_branch fallback (Claude pushed but success detection failed)
    if: |
      always() &&
      (needs.finalize-fixer.outputs.push_success == 'true' ||
       needs.finalize-auditor.result == 'success' ||
       needs.execute-e2e-fixer.outputs.has_branch == 'true')
    permissions:
      issues: write
      pull-requests: write  # Need write to close duplicate PRs
    steps:
      # DUPLICATE PREVENTION: Check if issue was already completed during Claude's execution
      # This prevents duplicate PRs when Claude runs for 60 minutes and another PR merges first
      - name: Check for duplicate/stale state
        id: duplicate_check
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
        run: |
          echo "Checking if issue #$ISSUE_NUMBER is still open and needs a PR..."

          # Check 1: Is the issue still open?
          ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")

          if [ "$ISSUE_STATE" = "CLOSED" ]; then
            echo "⚠️  Issue #$ISSUE_NUMBER is CLOSED - another PR likely merged during Claude's execution"
            echo "   Skipping PR creation/verification to prevent duplicate PR"
            echo "is_duplicate=true" >> $GITHUB_OUTPUT
            echo "reason=issue_closed" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check 2: Are there any merged PRs for this issue?
          MERGED_PR_COUNT=$(gh pr list \
            --repo "$REPO" \
            --search "Closes #$ISSUE_NUMBER in:body" \
            --state merged \
            --json number \
            --jq 'length' 2>/dev/null || echo "0")

          if [ "$MERGED_PR_COUNT" -gt 0 ]; then
            MERGED_PRS=$(gh pr list \
              --repo "$REPO" \
              --search "Closes #$ISSUE_NUMBER in:body" \
              --state merged \
              --json number,mergedAt \
              --jq '[.[] | "#\(.number) (merged \(.mergedAt))"] | join(", ")' 2>/dev/null || echo "")
            echo "⚠️  Found $MERGED_PR_COUNT merged PR(s) for issue #$ISSUE_NUMBER: $MERGED_PRS"
            echo "   Skipping PR creation/verification to prevent duplicate PR"
            echo "is_duplicate=true" >> $GITHUB_OUTPUT
            echo "reason=pr_already_merged" >> $GITHUB_OUTPUT
            echo "merged_prs=$MERGED_PRS" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "✅ Issue #$ISSUE_NUMBER is open with no merged PRs - proceeding with PR verification"
          echo "is_duplicate=false" >> $GITHUB_OUTPUT

      - name: Handle duplicate scenario
        if: steps.duplicate_check.outputs.is_duplicate == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          REASON: ${{ steps.duplicate_check.outputs.reason }}
          MERGED_PRS: ${{ steps.duplicate_check.outputs.merged_prs }}
        run: |
          echo "Handling duplicate scenario: $REASON"

          if [ "$REASON" = "issue_closed" ]; then
            # Issue was closed - likely by another merged PR
            # Any branch/PR created by this Claude run is now obsolete
            COMMENT_BODY="**Duplicate Prevention**: Claude Code completed, but issue was already closed.

          This typically happens when:
          - Another workflow completed and merged a PR for this issue
          - The issue was manually closed
          - A concurrent Claude Code run finished first

          **No action needed** - the issue is already resolved.

          ---
          *Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            # Post comment only if issue is still accessible (it might be closed)
            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$COMMENT_BODY" 2>/dev/null || echo "Could not post comment (issue may be closed)"

          elif [ "$REASON" = "pr_already_merged" ]; then
            # A PR was already merged for this issue
            COMMENT_BODY="**Duplicate Prevention**: Claude Code completed, but a PR was already merged for this issue.

          **Merged PR(s)**: $MERGED_PRS

          This typically happens when Claude Code runs for a long time (up to 60 minutes) and another PR is created and merged during that period.

          **No action needed** - the work is already complete.

          ---
          *Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$COMMENT_BODY" 2>/dev/null || echo "Could not post comment (issue may be closed)"

            # Close any open PRs that Claude might have created (they're now duplicates)
            echo "Checking for any open PRs created by this run that need to be closed..."
            OPEN_PRS=$(gh pr list \
              --repo "$REPO" \
              --search "Closes #$ISSUE_NUMBER in:body" \
              --state open \
              --json number,headRefName \
              --jq '.[] | "\(.number):\(.headRefName)"' 2>/dev/null || echo "")

            for PR_INFO in $OPEN_PRS; do
              PR_NUM=$(echo "$PR_INFO" | cut -d: -f1)
              BRANCH=$(echo "$PR_INFO" | cut -d: -f2)
              echo "  Closing duplicate PR #$PR_NUM (branch: $BRANCH)..."
              gh pr close "$PR_NUM" --repo "$REPO" \
                --comment "**Closing as duplicate**: PR(s) $MERGED_PRS already merged for issue #$ISSUE_NUMBER." \
                --delete-branch 2>/dev/null || echo "    Could not close PR #$PR_NUM"
            done
          fi

          echo "✅ Duplicate handling complete - exiting successfully (no further action needed)"

      # =========================================================================
      # PHASE 2: Workflow-managed PR creation
      # =========================================================================
      # Claude is now instructed to commit and push, but NOT create PR.
      # The workflow creates the PR to ensure reliable "Closes #XXXX" format.
      # =========================================================================

      - name: Create PR from branch (workflow-managed)
        # Skip if duplicate was detected (issue already closed or PR already merged)
        if: steps.duplicate_check.outputs.is_duplicate != 'true'
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
        run: |
          # =========================================================================
          # PR CONTEXT DETECTION: Handle case where trigger is a PR, not an issue
          # =========================================================================
          # When triggered on PR #6590 that "Closes #4598", ISSUE_NUMBER becomes 6590,
          # but the branch was created as claude/issue-4598-*. We need to detect this
          # and extract the actual linked issue number from the PR body.
          #
          # Detection method: Check if ISSUE_NUMBER corresponds to a PR (not just an issue)
          # If it's a PR with a "Closes #XXXX" in the body, use that issue number instead.

          ORIGINAL_NUMBER="$ISSUE_NUMBER"

          # Check if ISSUE_NUMBER is actually a PR
          PR_CHECK=$(gh pr view "$ISSUE_NUMBER" --repo "$REPO" --json number,body 2>/dev/null || echo "")

          if [ -n "$PR_CHECK" ] && [ "$PR_CHECK" != "null" ]; then
            # This is a PR context - extract linked issue from PR body
            PR_BODY=$(echo "$PR_CHECK" | jq -r '.body // ""')
            LINKED_ISSUE=$(echo "$PR_BODY" | grep -oE 'Closes #[0-9]+' | grep -oE '[0-9]+' | head -1 || echo "")

            if [ -n "$LINKED_ISSUE" ] && [ "$LINKED_ISSUE" != "$ISSUE_NUMBER" ]; then
              echo "Detected PR context: PR #$ISSUE_NUMBER closes issue #$LINKED_ISSUE"
              echo "   Switching to linked issue number for branch search..."
              ISSUE_NUMBER="$LINKED_ISSUE"
            fi
          fi

          echo "Looking for branch to create PR for issue #$ISSUE_NUMBER..."

          # Check if PR already exists (Claude might have created one despite instructions)
          EXISTING_PR=$(gh pr list --repo "$REPO" \
            --json number,headRefName \
            --jq "[.[] | select(.headRefName | test(\"^claude/issue-.*$ISSUE_NUMBER.*\"))][0].number" 2>/dev/null || echo "")

          if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
            echo "✅ PR #$EXISTING_PR already exists - skipping PR creation"

            # Check if auto-merge is enabled on existing PR
            AUTO_MERGE_STATUS=$(gh pr view "$EXISTING_PR" --repo "$REPO" --json autoMergeRequest --jq '.autoMergeRequest' 2>/dev/null || echo "null")

            if [ "$AUTO_MERGE_STATUS" = "null" ] || [ -z "$AUTO_MERGE_STATUS" ]; then
              echo "Auto-merge not enabled on existing PR - enabling now..."
              if gh pr merge "$EXISTING_PR" --auto --squash --repo "$REPO"; then
                echo "✅ Auto-merge enabled on PR #$EXISTING_PR"
              else
                echo "⚠️  Failed to enable auto-merge on PR #$EXISTING_PR - may need manual merge"
              fi
            else
              echo "✅ Auto-merge already enabled on PR #$EXISTING_PR"
            fi

            echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT
            echo "pr_created=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Find branch created by Claude
          BRANCH_PATTERN="claude/issue-${ISSUE_NUMBER}-"
          BRANCH_FULL_NAME=$(gh api "/repos/$REPO/branches" \
            --jq "[.[] | select(.name | startswith(\"$BRANCH_PATTERN\"))][0].name" 2>/dev/null || echo "")

          if [ -z "$BRANCH_FULL_NAME" ] || [ "$BRANCH_FULL_NAME" = "null" ]; then
            echo "❌ No branch found with pattern: $BRANCH_PATTERN"
            echo "   Claude may not have pushed changes."
            echo ""
            echo "Marking issue as failed..."

            gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
              --remove-label "tdd-spec:in-progress" \
              --add-label "tdd-spec:failed"

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "❌ **TDD Automation Failed: No Branch Found**

          Claude Code finished but no branch was pushed to the repository.

          **Expected branch pattern**: \`$BRANCH_PATTERN*\`

          **Next Steps**:
          1. Check if Claude encountered an error during implementation
          2. Re-run this spec if needed

          **Issue Status**: Marked as \`tdd-spec:failed\` - requires manual intervention.

          ---
          *🤖 Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            exit 1
          fi

          echo "✅ Found branch: $BRANCH_FULL_NAME"

          # Get spec ID from issue body
          SPEC_ID=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json body --jq '.body' | grep -oE '[A-Z]+-[A-Z]+-[A-Z0-9-]+' | head -1 || echo "unknown-spec")

          echo "Creating PR for $SPEC_ID..."

          # Create PR with guaranteed correct format
          # CRITICAL: Body is EXACTLY "Closes #XXXX" - nothing else
          # Retry up to 3 times for transient network errors
          #
          # RELIABILITY FIX: Don't use --json --jq flags - they fail when gh pr create
          # returns an error (tries to parse non-JSON error message as JSON).
          # Instead, extract PR number from the URL in the success output.
          PR_NUMBER=""
          PR_CREATE_ERROR=""

          # Disable exit-on-error for retry loop (default behavior can vary)
          set +e

          for attempt in 1 2 3; do
            echo "PR creation attempt $attempt/3..."

            # Capture output AND exit code separately
            PR_CREATE_OUTPUT=$(gh pr create \
              --repo "$REPO" \
              --head "$BRANCH_FULL_NAME" \
              --base main \
              --title "fix: implement $SPEC_ID" \
              --body "Closes #${ISSUE_NUMBER}" \
              --label "tdd-automation" 2>&1)
            PR_EXIT_CODE=$?

            echo "Exit code: $PR_EXIT_CODE"
            echo "Output: $PR_CREATE_OUTPUT"

            # Extract PR number from URL (format: https://github.com/owner/repo/pull/123)
            if [ $PR_EXIT_CODE -eq 0 ]; then
              PR_NUMBER=$(echo "$PR_CREATE_OUTPUT" | grep -oE '/pull/[0-9]+' | grep -oE '[0-9]+' | head -1)
              if [ -n "$PR_NUMBER" ]; then
                echo "✅ PR creation succeeded on attempt $attempt"
                break
              fi
            fi

            # Check if it's a duplicate error (no retry needed)
            if echo "$PR_CREATE_OUTPUT" | grep -qi "already exists"; then
              echo "PR already exists - no retry needed"
              # Try to extract existing PR number
              PR_NUMBER=$(echo "$PR_CREATE_OUTPUT" | grep -oE '/pull/[0-9]+' | grep -oE '[0-9]+' | head -1)
              PR_CREATE_ERROR="$PR_CREATE_OUTPUT"
              break
            fi

            PR_CREATE_ERROR="$PR_CREATE_OUTPUT"
            if [ "$attempt" -lt 3 ]; then
              DELAY=$((attempt * 5))
              echo "⚠️  Attempt $attempt failed (exit code $PR_EXIT_CODE): $PR_CREATE_OUTPUT"
              echo "Retrying in ${DELAY}s..."
              sleep $DELAY
            fi
          done

          # Re-enable exit-on-error
          set -e

          if [ -n "$PR_NUMBER" ] && [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "✅ PR #$PR_NUMBER created successfully!"
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "pr_created=true" >> $GITHUB_OUTPUT

            # Enable auto-merge
            echo ""
            echo "Enabling auto-merge..."
            if gh pr merge "$PR_NUMBER" --auto --squash --repo "$REPO"; then
              echo "✅ Auto-merge enabled"
            else
              echo "⚠️  Auto-merge failed - PR will need manual merge"
            fi

            # Post success comment
            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "✅ **PR Created**: #$PR_NUMBER

          Workflow created PR from branch \`$BRANCH_FULL_NAME\` with auto-merge enabled.

          PR will merge automatically when CI passes.

          ---
          *Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"
          else
            echo "❌ PR creation failed after 3 attempts: $PR_CREATE_ERROR"

            gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
              --remove-label "tdd-spec:in-progress" \
              --add-label "tdd-spec:failed"

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "❌ **TDD Automation Failed: PR Creation Error**

          Branch \`$BRANCH_FULL_NAME\` exists but PR creation failed after 3 retry attempts.

          **Error**: \`$PR_CREATE_ERROR\`

          **Next Steps**:
          1. Manually create PR from branch \`$BRANCH_FULL_NAME\`
          2. Or investigate the error above

          **Issue Status**: Marked as \`tdd-spec:failed\` - requires manual intervention.

          ---
          *Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            exit 1
          fi

      # Safety net: Validate PR body in case Claude created PR despite instructions
      # (When workflow creates PR, body is guaranteed correct)
      - name: Validate PR body has auto-close keyword
        if: steps.duplicate_check.outputs.is_duplicate != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          CREATED_PR_NUMBER: ${{ steps.create_pr.outputs.pr_number }}
        run: |
          echo "Validating PR body contains auto-close keyword..."

          # Use PR number from create_pr step if available, otherwise find it
          if [ -n "$CREATED_PR_NUMBER" ] && [ "$CREATED_PR_NUMBER" != "" ]; then
            PR_NUMBER="$CREATED_PR_NUMBER"
            echo "Using PR #$PR_NUMBER from create_pr step"
          else
            PR_NUMBER=$(gh pr list --repo "$REPO" \
              --json number,headRefName \
              --jq "[.[] | select(.headRefName | test(\"^claude/issue-.*$ISSUE_NUMBER.*\"))][0].number")
          fi

          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ]; then
            echo "⚠️  No PR found to validate - skipping body check"
            exit 0
          fi

          echo "Checking PR #$PR_NUMBER body..."

          # Get current PR body
          PR_BODY=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json body --jq '.body')

          # Check if body contains the required auto-close keyword
          if echo "$PR_BODY" | grep -qE "Closes #$ISSUE_NUMBER([^0-9]|$)"; then
            echo "✅ PR body contains 'Closes #$ISSUE_NUMBER' - auto-close will work"
          else
            echo "⚠️  PR #$PR_NUMBER is MISSING 'Closes #$ISSUE_NUMBER' in body"
            echo "   Auto-close will NOT work without this keyword"
            echo "   Attempting to fix by prepending the keyword..."

            # Prepend the auto-close keyword to the existing body
            # Use printf to avoid YAML parsing issues with multiline strings
            NEW_BODY=$(printf "Closes #%s\n\n%s" "$ISSUE_NUMBER" "$PR_BODY")

            # Update the PR body
            if gh pr edit "$PR_NUMBER" --repo "$REPO" --body "$NEW_BODY"; then
              echo "✅ Successfully added 'Closes #$ISSUE_NUMBER' to PR body"
              echo "   Auto-close will now work when PR merges"

              # Post comment on issue explaining the fix
              gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
                --body "**Auto-Close Keyword Fix Applied**: PR #$PR_NUMBER was missing \`Closes #$ISSUE_NUMBER\` in its body. Added the keyword - issue will now auto-close when PR merges. *Automated fix*" || true
            else
              echo "❌ Failed to update PR body - manual intervention may be needed"
              echo "   PR will merge but issue may not auto-close"
            fi
          fi
