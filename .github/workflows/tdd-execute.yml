name: TDD - Execute (Claude Code)

# This workflow handles all Claude Code execution with infrastructure-level retry logic
# It handles both automated queue processing and manual @claude mentions
# Infrastructure errors (EPERM, timeouts, crashes) are automatically retried up to 3 times

on:
  # Manual trigger: Process specific issue number with optional retry
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process'
        required: true
        type: number
      retry_attempt:
        description: 'Current retry attempt (1-3)'
        required: false
        type: number
        default: 1

  # Manual triggers: @claude mentions in issues/PRs (interactive use)
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

# Concurrency control: One run per issue/PR, QUEUE don't cancel
# Groups runs by issue/PR number to prevent duplicate execution
# cancel-in-progress: false preserves work-in-progress (Claude can run 60+ min)
# Duplicate PRs prevented via application-level checks (pre-PR validation in CLAUDE.md)
# Note: claude[bot] comments are filtered in validate-context job (lines 80-98)
concurrency:
  group: claude-issue-${{ github.event.issue.number || github.event.pull_request.number || github.event.inputs.issue_number || 'default' }}
  cancel-in-progress: false

env:
  MAX_INFRASTRUCTURE_RETRIES: 3
  CLAUDE_TIMEOUT_MINUTES: 60

jobs:
  # Pre-check job: Validate context exists before running Claude Code
  # Prevents wasted resources when there's no spec to process
  validate-context:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      issues: read
    outputs:
      has_context: ${{ steps.check.outputs.has_context }}
      issue_number: ${{ steps.check.outputs.issue_number }}
      issue_body: ${{ steps.check.outputs.issue_body }}
    steps:
      - name: Check for valid context
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
          # Security: Use env vars for untrusted user input to prevent code injection
          EVENT_COMMENT_BODY: ${{ github.event.comment.body }}
          EVENT_ISSUE_BODY: ${{ github.event.issue.body }}
          EVENT_ISSUE_TITLE: ${{ github.event.issue.title }}
          EVENT_REVIEW_BODY: ${{ github.event.review.body }}
          COMMENT_USER: ${{ github.event.comment.user.login }}
        run: |
          HAS_CONTEXT="false"
          ISSUE_NUMBER=""
          ISSUE_BODY=""

          # Skip if comment is from Claude bot (prevents race condition with error comments)
          # Also skip "Claude Code is working" status comments (prevents self-cancellation)
          if [ "${{ github.event_name }}" = "issue_comment" ]; then
            if [ "$COMMENT_USER" = "claude[bot]" ]; then
              echo "Comment from Claude bot - skipping to prevent cancellation race"
              echo "has_context=false" >> $GITHUB_OUTPUT
              echo "issue_number=" >> $GITHUB_OUTPUT
              echo "issue_body<<EOF" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 0
            elif [[ "$EVENT_COMMENT_BODY" == *"Claude Code is working"* ]]; then
              echo "Claude Code status comment - skipping to prevent self-cancellation"
              echo "has_context=false" >> $GITHUB_OUTPUT
              echo "issue_number=" >> $GITHUB_OUTPUT
              echo "issue_body<<EOF" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # workflow_dispatch: Must have valid issue number
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ISSUE_NUMBER="${{ github.event.inputs.issue_number }}"
            if [ -n "$ISSUE_NUMBER" ]; then
              echo "Validating issue #$ISSUE_NUMBER (workflow_dispatch trigger)..."
              if gh issue view "$ISSUE_NUMBER" &>/dev/null; then
                ISSUE_BODY=$(gh issue view "$ISSUE_NUMBER" --json body --jq '.body')
                HAS_CONTEXT="true"
                echo "âœ… Valid issue found: #$ISSUE_NUMBER"
              else
                echo "âŒ Issue #$ISSUE_NUMBER not found - skipping workflow"
              fi
            else
              echo "âŒ No issue number provided - skipping workflow"
            fi

          # issue_comment/PR review: Must have @claude mention and valid issue/PR
          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            if [[ "$EVENT_COMMENT_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.issue.number }}"
              ISSUE_BODY="$EVENT_ISSUE_BODY"
              HAS_CONTEXT="true"
              echo "âœ… Valid @claude mention in issue #$ISSUE_NUMBER"
            else
              echo "âš ï¸  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
            if [[ "$EVENT_COMMENT_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.pull_request.number }}"
              HAS_CONTEXT="true"
              echo "âœ… Valid @claude mention in PR #$ISSUE_NUMBER"
            else
              echo "âš ï¸  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "pull_request_review" ]; then
            if [[ "$EVENT_REVIEW_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.pull_request.number }}"
              HAS_CONTEXT="true"
              echo "âœ… Valid @claude mention in PR review #$ISSUE_NUMBER"
            else
              echo "âš ï¸  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "issues" ]; then
            if [[ "$EVENT_ISSUE_BODY" == *"@claude"* ]] || [[ "$EVENT_ISSUE_TITLE" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.issue.number }}"
              ISSUE_BODY="$EVENT_ISSUE_BODY"
              HAS_CONTEXT="true"
              echo "âœ… Valid @claude mention in issue #$ISSUE_NUMBER"
            else
              echo "âš ï¸  No @claude mention found - skipping workflow"
            fi
          fi

          # Additional validation: Check if issue is closed or has existing PRs
          if [ "$HAS_CONTEXT" = "true" ] && [ -n "$ISSUE_NUMBER" ]; then
            echo ""
            echo "Checking issue state and existing PRs for #$ISSUE_NUMBER..."

            # Check if issue is closed
            ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")

            if [ "$ISSUE_STATE" = "CLOSED" ]; then
              echo "âš ï¸  Issue #$ISSUE_NUMBER is CLOSED - skipping to prevent duplicate PR"
              echo "   A PR has already been merged or the issue was closed manually"
              HAS_CONTEXT="false"
              ISSUE_NUMBER=""
              ISSUE_BODY=""
            else
              # Check for any existing PR (open or closed) for this issue
              EXISTING_PR_COUNT=$(gh pr list \
                --repo ${{ github.repository }} \
                --search "Closes #$ISSUE_NUMBER in:body" \
                --state all \
                --json number \
                --jq 'length' 2>/dev/null || echo "0")

              if [ "$EXISTING_PR_COUNT" -gt 0 ]; then
                EXISTING_PRS=$(gh pr list \
                  --repo ${{ github.repository }} \
                  --search "Closes #$ISSUE_NUMBER in:body" \
                  --state all \
                  --json number,state \
                  --jq '[.[] | "#\(.number) (\(.state))"] | join(", ")' 2>/dev/null || echo "")

                echo "âš ï¸  Found $EXISTING_PR_COUNT existing PR(s) for issue #$ISSUE_NUMBER: $EXISTING_PRS"
                echo "   Skipping to prevent duplicate PR creation"
                echo "   If you need to retry, close/delete the existing PR first"

                # Post comment on issue explaining why we're skipping
                COMMENT_BODY="**Duplicate PR Prevention**

                Skipping Claude Code execution because PR(s) already exist for this issue: $EXISTING_PRS

                **To retry this spec:**
                1. Close or delete the existing PR if it's invalid
                2. Re-open this issue if it was closed
                3. Post a new @claude comment to trigger the workflow

                ---
                *Automated via Claude TDD Workflow*"

                gh issue comment "$ISSUE_NUMBER" --body "$COMMENT_BODY" 2>/dev/null || true

                HAS_CONTEXT="false"
                ISSUE_NUMBER=""
                ISSUE_BODY=""
              else
                echo "âœ… Issue is open with no existing PRs - safe to proceed"
              fi
            fi
          fi

          # Output results
          echo "has_context=$HAS_CONTEXT" >> $GITHUB_OUTPUT
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Log concurrency group status for debugging workflow trigger issues
      # This helps diagnose cases where @claude comments don't trigger Claude Code
      - name: Log concurrency group status
        if: steps.check.outputs.has_context == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.check.outputs.issue_number }}
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "CONCURRENCY GROUP DEBUG INFO"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          CONCURRENCY_GROUP="claude-issue-$ISSUE_NUMBER"
          echo "Concurrency Group: $CONCURRENCY_GROUP"
          echo "Triggered at: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Event: ${{ github.event_name }}"
          echo "Sender: ${{ github.event.sender.login }}"

          # Check for other running workflows in the same concurrency group
          echo ""
          echo "Checking for other running workflows for issue #$ISSUE_NUMBER..."

          RUNNING_WORKFLOWS=$(gh run list \
            --workflow="TDD - Execute (Claude Code)" \
            --status=in_progress \
            --json databaseId,displayTitle,createdAt,event \
            --jq "[.[] | select(.displayTitle | contains(\"#$ISSUE_NUMBER\"))]" 2>/dev/null || echo "[]")

          RUNNING_COUNT=$(echo "$RUNNING_WORKFLOWS" | jq 'length' 2>/dev/null || echo "0")

          if [ "$RUNNING_COUNT" -gt 1 ]; then
            echo "WARNING: $RUNNING_COUNT workflows running for this issue!"
            echo "   This run may be queued due to concurrency group"
            echo ""
            echo "   Running workflows:"
            echo "$RUNNING_WORKFLOWS" | jq -r '.[] | "   - Run \(.databaseId) started \(.createdAt) via \(.event)"'
          elif [ "$RUNNING_COUNT" -eq 1 ]; then
            echo "âœ… This is the only running workflow for issue #$ISSUE_NUMBER"
          else
            echo "â„¹ï¸  No in-progress workflows found (this workflow is still starting)"
          fi

          # Check for queued workflows
          QUEUED_WORKFLOWS=$(gh run list \
            --workflow="TDD - Execute (Claude Code)" \
            --status=queued \
            --json databaseId,displayTitle,createdAt \
            --jq "[.[] | select(.displayTitle | contains(\"#$ISSUE_NUMBER\"))] | length" 2>/dev/null || echo "0")

          if [ "$QUEUED_WORKFLOWS" -gt 0 ]; then
            echo ""
            echo "$QUEUED_WORKFLOWS workflow(s) queued for this issue"
            echo "   These will run after current workflow completes"
          fi

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  # Error classification: Determine if error is retriable at infrastructure level
  classify-previous-error:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.retry_attempt > 1
    permissions:
      actions: read
    outputs:
      is_infrastructure_error: ${{ steps.classify.outputs.is_infrastructure_error }}
      error_type: ${{ steps.classify.outputs.error_type }}
      should_retry: ${{ steps.classify.outputs.should_retry }}
    steps:
      - name: Classify previous run error
        id: classify
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
        run: |
          echo "Analyzing previous workflow run for error classification..."

          # Get the most recent failed run for this issue
          RECENT_RUN=$(gh run list \
            --workflow="tdd-execute.yml" \
            --status failure \
            --limit 5 \
            --json databaseId,conclusion,displayTitle \
            --jq ".[] | select(.displayTitle | contains(\"#$ISSUE_NUMBER\")) | .databaseId" \
            | head -1)

          if [ -z "$RECENT_RUN" ]; then
            echo "No recent failed run found - assuming infrastructure error"
            echo "is_infrastructure_error=true" >> $GITHUB_OUTPUT
            echo "error_type=unknown" >> $GITHUB_OUTPUT
            echo "should_retry=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Analyzing run #$RECENT_RUN..."

          # Get failure logs
          LOGS=$(gh run view "$RECENT_RUN" --log-failed || echo "")

          # Classify error type
          IS_INFRA_ERROR=false
          ERROR_TYPE="unknown"

          # Infrastructure errors (retriable at workflow level)
          if echo "$LOGS" | grep -q "EPERM: Operation not permitted"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="permission_error"
            echo "Detected: Permission error (EPERM)"
          elif echo "$LOGS" | grep -q "ETIMEDOUT\|timeout\|timed out"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="timeout"
            echo "Detected: Timeout error"
          elif echo "$LOGS" | grep -q "ECONNRESET\|ENOTFOUND\|socket hang up"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="network_error"
            echo "Detected: Network error"
          elif echo "$LOGS" | grep -q "out of memory\|OOM\|killed"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="resource_exhaustion"
            echo "Detected: Resource exhaustion"
          elif echo "$LOGS" | grep -q "ENOSPC\|no space left"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="disk_full"
            echo "Detected: Disk space error"
          elif echo "$LOGS" | grep -q "cancelled\|canceled"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="workflow_cancelled"
            echo "Detected: Workflow cancellation"
          # =========================================================================
          # Credit/rate limit exhaustion (NOT retriable - requires waiting)
          # These errors indicate Claude Code API limits have been reached.
          # The queue should PAUSE (not retry) until credits are restored.
          #
          # Based on Anthropic API documentation:
          # - 429: rate_limit_error - "Your account has hit a rate limit"
          # - 529: overloaded_error - "The API is temporarily overloaded"
          # - Claude Code specific: "Claude usage limit reached"
          # =========================================================================
          # Pattern 1: Anthropic API rate_limit_error (429)
          elif echo "$LOGS" | grep -qiE "rate_limit_error|hit a rate limit|would exceed your.*(rate|account).?limit|Error: 429|\"type\".*429"; then
            IS_INFRA_ERROR=false  # NOT a simple retry - requires pause
            ERROR_TYPE="rate_limit_exceeded"
            echo "âš ï¸  DETECTED: Anthropic API rate limit (429) - TDD queue should PAUSE"
            echo "   Raw pattern match found - logging for analysis:"
            echo "$LOGS" | grep -iE "rate_limit|429|hit a rate limit|exceed.*limit" | head -5
          # Pattern 2: Anthropic API overloaded_error (529)
          elif echo "$LOGS" | grep -qiE "overloaded_error|529|temporarily overloaded|API is.*overloaded"; then
            IS_INFRA_ERROR=false  # NOT a simple retry - requires pause
            ERROR_TYPE="api_overloaded"
            echo "âš ï¸  DETECTED: Anthropic API overloaded (529) - TDD queue should PAUSE"
            echo "   Raw pattern match found - logging for analysis:"
            echo "$LOGS" | grep -iE "overloaded|529" | head -5
          # Pattern 3: Claude Code CLI usage limit (Max plan)
          elif echo "$LOGS" | grep -qiE "Claude.*(usage|AI).?limit.?reached|usage.?limit|limit.?will.?reset|5.?hour.?limit"; then
            IS_INFRA_ERROR=false  # NOT a simple retry - requires pause
            ERROR_TYPE="credit_exhausted"
            echo "âš ï¸  DETECTED: Claude Code usage limit reached (Max plan) - TDD queue should PAUSE"
            echo "   Raw pattern match found - logging for analysis:"
            echo "$LOGS" | grep -iE "usage.?limit|limit.?reached|limit.?will.?reset" | head -5
          # Pattern 4: Generic credit/quota exhaustion
          elif echo "$LOGS" | grep -qiE "insufficient.?credit|credit.?limit|quota.?exceeded|billing.?error|account.?suspended"; then
            IS_INFRA_ERROR=false  # NOT a simple retry - requires pause
            ERROR_TYPE="credit_exhausted"
            echo "âš ï¸  DETECTED: Credit/quota exhausted - TDD queue should PAUSE"
            echo "   Raw pattern match found - logging for analysis:"
            echo "$LOGS" | grep -iE "insufficient|credit|quota|billing|suspended" | head -5
          # Pattern 5: GitHub API rate limits (infrastructure - retriable)
          # These are different from Anthropic rate limits - GitHub limits reset quickly
          elif echo "$LOGS" | grep -qiE "API rate limit exceeded for installation|secondary rate limit|abuse detection"; then
            IS_INFRA_ERROR=true  # GitHub rate limits are retriable after short wait
            ERROR_TYPE="github_rate_limit"
            echo "âš ï¸  DETECTED: GitHub API rate limit - WILL RETRY (infrastructure)"
            echo "   Raw pattern match found - logging for analysis:"
            echo "$LOGS" | grep -iE "rate limit|secondary rate|abuse detection" | head -5
          # Pattern 6: Authentication errors (401/403) - but NOT GitHub rate limits
          elif echo "$LOGS" | grep -qiE "authentication_error|permission_error|issue with your API key|does not have permission|unauthorized|token.?expired|oauth.?error"; then
            IS_INFRA_ERROR=false  # NOT a simple retry - requires manual fix
            ERROR_TYPE="auth_error"
            echo "âš ï¸  DETECTED: Authentication/permission error - check CLAUDE_CODE_OAUTH_TOKEN"
            echo "   Raw pattern match found - logging for analysis:"
            echo "$LOGS" | grep -iE "authentication|permission|unauthorized|API key|token|oauth" | head -5
          # Code/test errors - NOW RETRIABLE with error context for Claude to self-correct
          elif echo "$LOGS" | grep -q "lint.*error\|ESLint.*error\|functional/immutable-data\|no-restricted-syntax"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="lint_error"
            echo "Detected: Lint error - WILL RETRY with fix instructions"
          elif echo "$LOGS" | grep -q "Test.*failed\|FAIL\|AssertionError"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="test_failure"
            echo "Detected: Test failure - WILL RETRY with fix instructions"
          elif echo "$LOGS" | grep -q "SyntaxError\|TypeError\|ReferenceError"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="code_error"
            echo "Detected: Code error - WILL RETRY with fix instructions"
          fi

          # Determine if should retry
          SHOULD_RETRY=false
          if [ "$IS_INFRA_ERROR" = true ]; then
            SHOULD_RETRY=true
            echo "Error detected - WILL RETRY (Claude can self-correct)"
          else
            echo "Unknown error - will NOT retry"
          fi

          # Output results
          echo "is_infrastructure_error=$IS_INFRA_ERROR" >> $GITHUB_OUTPUT
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT
          echo "should_retry=$SHOULD_RETRY" >> $GITHUB_OUTPUT

  # Phase 1: E2E Test Fixer - Make RED tests GREEN
  # Only runs e2e-test-fixer agent. Finalization and refactoring handled by separate jobs.
  execute-e2e-fixer:
    runs-on: ubuntu-latest
    timeout-minutes: 65 # Reduced from 95 (60 min Claude + 5 min cleanup)
    needs: [validate-context, classify-previous-error]
    if: |
      always() &&
      needs.validate-context.outputs.has_context == 'true' &&
      (needs.classify-previous-error.result == 'skipped' ||
       needs.classify-previous-error.outputs.should_retry == 'true') &&
      github.event.sender.login != 'claude[bot]' &&
      (
        github.event_name == 'workflow_dispatch' ||
        (github.event_name != 'workflow_dispatch' && (
          github.event.comment.author_association == 'OWNER' ||
          github.event.comment.author_association == 'MEMBER' ||
          github.event.comment.author_association == 'COLLABORATOR' ||
          github.event.issue.author_association == 'OWNER' ||
          github.event.issue.author_association == 'MEMBER' ||
          github.event.issue.author_association == 'COLLABORATOR' ||
          github.event.review.author_association == 'OWNER' ||
          github.event.review.author_association == 'MEMBER' ||
          github.event.review.author_association == 'COLLABORATOR' ||
          github.event.sender.login == 'github-actions[bot]' ||
          github.event.sender.login == 'github-actions' ||
          github.event.sender.login == 'app/github-actions' ||
          github.event.issue.user.login == 'github-actions[bot]' ||
          github.event.issue.user.login == 'github-actions' ||
          github.event.issue.user.login == 'app/github-actions' ||
          github.event.comment.user.login == 'github-actions[bot]' ||
          github.event.comment.user.login == 'github-actions' ||
          github.event.comment.user.login == 'app/github-actions'
        ))
      )
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read
    outputs:
      claude_success: ${{ steps.set_success.outputs.claude_success }}
      claude_exit_code: ${{ steps.claude.outcome }}
      error_type: ${{ steps.detect_error.outputs.error_type }}
      is_infrastructure_error: ${{ steps.detect_error.outputs.is_infrastructure_error }}
      has_branch: ${{ steps.set_success.outputs.has_branch }}
      branch_name: ${{ steps.set_success.outputs.branch_name }}
      spec_id: ${{ steps.issue.outputs.spec_id }}
      issue_number: ${{ steps.issue.outputs.issue_number }}
      sdk_crash_after_success: ${{ steps.set_success.outputs.sdk_crash_after_success }}
      no_branch_after_success: ${{ steps.set_success.outputs.no_branch_after_success }}
      claude_work_succeeded: ${{ steps.detect_error.outputs.claude_work_succeeded }}
    steps:
      - name: Checkout repository with retry
        id: checkout
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Retry logic for GitHub API rate limits during checkout
          MAX_ATTEMPTS=3
          RETRY_DELAY=30

          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo "Checkout attempt $attempt of $MAX_ATTEMPTS..."

            if git clone "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git" . 2>&1; then
              echo "âœ… Checkout successful on attempt $attempt"
              exit 0
            else
              EXIT_CODE=$?
              echo "âŒ Checkout failed with exit code $EXIT_CODE"

              if [ $attempt -lt $MAX_ATTEMPTS ]; then
                echo "â³ Waiting ${RETRY_DELAY}s before retry (GitHub API rate limit may be in effect)..."
                sleep $RETRY_DELAY
                # Increase delay for next attempt (exponential backoff)
                RETRY_DELAY=$((RETRY_DELAY * 2))
              else
                echo "ğŸ’¥ All checkout attempts failed"
                exit 1
              fi
            fi
          done

      - name: Set issue context
        id: issue
        env:
          # Security: Use env var to prevent code injection from untrusted issue body
          ISSUE_BODY_INPUT: ${{ needs.validate-context.outputs.issue_body }}
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ needs.validate-context.outputs.issue_number }}
        run: |
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY_INPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Extract spec ID from issue title or body
          ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title --jq '.title' 2>/dev/null || echo "")
          SPEC_ID=$(echo "$ISSUE_TITLE" | grep -oE '[A-Z]+-[A-Z]+-[A-Z0-9-]+' | head -1 || echo "")
          if [ -z "$SPEC_ID" ]; then
            SPEC_ID=$(echo "$ISSUE_BODY_INPUT" | grep -oE '[A-Z]+-[A-Z]+-[A-Z0-9-]+' | head -1 || echo "unknown-spec")
          fi
          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT
          echo "Extracted spec_id: $SPEC_ID"

      # =========================================================================
      # Usage tracking is BLOCKING with fail-closed behavior
      # See: docs/development/claude-code-usage-tracking.md
      # =========================================================================
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Check usage limits (fail-closed)
        id: usage
        run: |
          echo "Checking usage limits before Claude Code execution..."
          # Run usage check and capture exit code
          set +e
          bun run scripts/tdd-automation/check-claude-code-usage.ts --check
          EXIT_CODE=$?
          set -e

          # Mark that script completed (even if limits exceeded)
          echo "script_completed=true" >> $GITHUB_OUTPUT

          # Exit with the script's exit code
          exit $EXIT_CODE
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TDD_DAILY_COST_LIMIT: '200.00'
          TDD_WEEKLY_COST_LIMIT: '1000.00'
        continue-on-error: true

      - name: Fail if usage check crashed (fail-closed safety)
        if: steps.usage.outcome == 'failure' && steps.usage.outputs.script_completed != 'true'
        run: |
          echo "CRITICAL: Usage check script crashed before completion!"
          echo ""
          echo "This is a fail-closed safety mechanism. The workflow cannot proceed"
          echo "because we cannot verify that usage is within limits."
          echo ""
          echo "Possible causes:"
          echo "  - Network timeout fetching workflow logs"
          echo "  - GitHub API authentication failure"
          echo "  - Script parsing error"
          echo ""
          echo "Action required: Investigate the usage check step logs above."
          exit 1

      - name: Skip if usage limits exceeded
        if: steps.usage.outcome == 'failure' && steps.usage.outputs.script_completed == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
        run: |
          echo "Usage limits exceeded - graceful skip"
          echo "   Reason: ${{ steps.usage.outputs.reason || 'limits_exceeded' }}"
          echo "   Daily cost: ${{ steps.usage.outputs.daily_cost || 'unknown' }}"
          echo "   Weekly cost: ${{ steps.usage.outputs.weekly_cost || 'unknown' }}"
          echo ""
          echo "Skipping Claude Code execution until usage is reduced."

          # Post comment on issue explaining the skip
          gh issue comment "$ISSUE_NUMBER" --body "**Usage Limit Reached**: Claude Code execution paused due to usage limits. Will retry when usage is reduced.

          - Daily cost: \${{ steps.usage.outputs.daily_cost || 'unknown' }}
          - Weekly cost: \${{ steps.usage.outputs.weekly_cost || 'unknown' }}

          ---
          *TDD Automation - Usage Tracking*" 2>/dev/null || true

          exit 0

      # =========================================================================
      # NOTE: claude-code-action post-processing 404 error workaround
      # =========================================================================
      # The action may fail with "HttpError: Not Found" during post-processing
      # when comparing commits (GitHub issue #804, #589). This is a known bug
      # in the action's internal compareCommitsWithBasehead call.
      #
      # Workaround: Use continue-on-error and verify success via branch existence
      # instead of relying on the action's exit code. The set_success step below
      # handles this by checking if Claude pushed a branch (has_branch=true).
      #
      # When the upstream fix is released, this can be simplified.
      # Track: https://github.com/anthropics/claude-code-action/issues/804
      # =========================================================================
      - name: Run Claude Code (e2e-test-fixer only)
        id: claude
        uses: anthropics/claude-code-action@v1
        timeout-minutes: 60
        continue-on-error: true # Required: Action may fail in post-processing even when work completed
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          # Use PAT with 'workflows' scope for git push operations
          # GitHub requires 'workflows' scope to push to repos containing .github/workflows/ files
          # Comments will appear from your personal account (not claude[bot])
          github_token: ${{ secrets.GH_PAT_WORKFLOW }}
          additional_permissions: |
            actions: read
          # NO prompt field - Claude Code will read the @claude comment naturally
          # This allows the queue processor's detailed instructions to be used
          # Agents are auto-discovered from .claude/agents/ directory (no --agents flag needed)
          #
          # Claude Code Best Practices (per https://code.claude.com/docs/github-actions):
          # - --model: Explicit model for cost predictability (Sonnet 4 is cost-effective for TDD)
          # - --max-budget-usd: Increased to $50 (e2e-test-fixer only, refactor-auditor runs separately)
          #   Budget increased from $10 to handle specs with complex context or confusing issue history
          # - --allowedTools: Principle of least privilege - only tools needed for TDD workflow
          # - --disallowedTools: Block tools not needed for autonomous code implementation
          #   - AskUserQuestion: No human present in automation (would hang or skip)
          #   - WebFetch/WebSearch: External content not needed
          #   - NotebookEdit: No Jupyter notebooks in project
          #   - SlashCommand: Prevents unintended command execution
          claude_args: >-
            --model claude-sonnet-4-5-20250929
            --max-budget-usd 50.00
            --allowedTools Edit,Read,Write,Bash,Glob,Grep,Task,TodoWrite,Skill,LSP
            --disallowedTools WebFetch,WebSearch,AskUserQuestion,NotebookEdit,SlashCommand

      - name: Detect error type
        id: detect_error
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
        run: |
          echo "Analyzing Claude Code execution..."

          # Check Claude Code exit behavior
          CLAUDE_OUTCOME="${{ steps.claude.outcome }}"

          IS_INFRA_ERROR=false
          ERROR_TYPE="unknown"
          CLAUDE_WORK_SUCCEEDED=false

          # =========================================================================
          # SDK CRASH DETECTION: Check workflow logs for Claude's success output
          # =========================================================================
          # The SDK outputs JSON lines during execution. If we see "subtype": "success"
          # in the current workflow run logs, Claude completed its work successfully.
          # A subsequent SDK crash (before push) is a separate infrastructure issue.
          #
          # This catches the case where:
          # - Claude logs: {"type": "result", "subtype": "success", ...}
          # - SDK then crashes before git push
          # - Action reports failure, but Claude's work is done
          # =========================================================================
          echo "Checking workflow logs for Claude success output..."

          # Get the current job's logs to check for Claude's success output
          # We look for the JSON result output that indicates Claude completed successfully
          WORKFLOW_LOG=""

          # Try to get logs from the current run
          # Note: gh run view --log can be slow, so we use a timeout
          if timeout 30 gh run view ${{ github.run_id }} --log 2>/dev/null > /tmp/workflow_log.txt; then
            WORKFLOW_LOG=$(cat /tmp/workflow_log.txt)
          fi

          # Check for Claude's success output in logs
          # The SDK outputs: {"type": "result", "subtype": "success", ...}
          if [ -n "$WORKFLOW_LOG" ]; then
            # Look for the success result JSON (may be on one line or formatted)
            if echo "$WORKFLOW_LOG" | grep -q '"subtype"[[:space:]]*:[[:space:]]*"success"'; then
              echo "FOUND Claude success output in logs"
              CLAUDE_WORK_SUCCEEDED=true
            elif echo "$WORKFLOW_LOG" | grep -q '"subtype": "success"'; then
              echo "FOUND Claude success output in logs (compact format)"
              CLAUDE_WORK_SUCCEEDED=true
            fi
          else
            echo "Could not retrieve workflow logs for SDK success detection"
          fi

          # Calculate step duration to detect timeout (GitHub marks some timeouts as "success")
          START_TIME="${{ steps.claude.outputs.startedAt || '' }}"
          END_TIME="${{ steps.claude.outputs.completedAt || '' }}"

          # If timestamps are available, calculate duration
          if [ -n "$START_TIME" ] && [ -n "$END_TIME" ]; then
            START_EPOCH=$(date -d "$START_TIME" +%s 2>/dev/null || echo "0")
            END_EPOCH=$(date -d "$END_TIME" +%s 2>/dev/null || echo "0")

            if [ "$START_EPOCH" -ne 0 ] && [ "$END_EPOCH" -ne 0 ]; then
              DURATION=$((END_EPOCH - START_EPOCH))
              echo "Step duration: ${DURATION}s"

              # Timeout detection: anything > 74 minutes (4440 seconds) is likely a timeout
              if [ "$DURATION" -ge 4440 ]; then
                IS_INFRA_ERROR=true
                ERROR_TYPE="timeout_confirmed"
                echo "TIMEOUT DETECTED: Step ran for ${DURATION}s (>= 4440s threshold)"
              fi
            fi
          fi

          # If not already classified as timeout, check outcome
          if [ "$ERROR_TYPE" = "unknown" ]; then
            if [ "$CLAUDE_OUTCOME" = "cancelled" ]; then
              # Cancelled usually means timeout or manual cancellation
              IS_INFRA_ERROR=true
              ERROR_TYPE="cancelled_timeout"
              echo "Step was cancelled - treating as timeout"
            elif [ "$CLAUDE_OUTCOME" = "failure" ]; then
              # =========================================================================
              # WORKAROUND 1: Check if this is SDK crash AFTER Claude success
              # =========================================================================
              # If we detected Claude's success output in logs but action failed,
              # the SDK crashed after Claude completed its work (before git push).
              # This is NOT retriable - Claude's work is done, we need to recover it.
              # =========================================================================
              if [ "$CLAUDE_WORK_SUCCEEDED" = "true" ]; then
                echo "SDK CRASH DETECTED: Claude succeeded but SDK crashed before push"
                echo "   Claude's work completed (found success in logs)"
                echo "   SDK crashed during post-processing"
                echo "   This should NOT trigger a retry - work is done but needs recovery"
                ERROR_TYPE="sdk_crash_after_success"
                IS_INFRA_ERROR=false  # Not a retry candidate
              else
                # =========================================================================
                # WORKAROUND 2: Check if this is the known post-processing 404 error
                # =========================================================================
                # The claude-code-action has a known bug where it fails with:
                # "HttpError: Not Found - compare-two-commits" during post-processing
                # even when Claude completed successfully and pushed a branch.
                #
                # Detection: If outcome=failure but branch exists, treat as success
                # This is a false negative from the action's internal error handling
                # Track: https://github.com/anthropics/claude-code-action/issues/804
                # =========================================================================
                echo "Claude Code reported failure - checking if branch was created..."

                BRANCH_PATTERN="claude/issue-${ISSUE_NUMBER}-"
                BRANCH_EXISTS=$(gh api "/repos/$REPO/branches" \
                  --jq "[.[] | select(.name | startswith(\"$BRANCH_PATTERN\"))][0].name" 2>/dev/null || echo "")

                if [ -n "$BRANCH_EXISTS" ] && [ "$BRANCH_EXISTS" != "null" ]; then
                  echo "WORKAROUND: Branch '$BRANCH_EXISTS' exists despite failure outcome"
                  echo "   This is likely the known post-processing 404 error (issue #804)"
                  echo "   Treating as SUCCESS since Claude completed its work"
                  ERROR_TYPE="post_processing_404_false_negative"
                  IS_INFRA_ERROR=false
                else
                  # For failures, check if it's infrastructure or code issue
                  # Look for common infrastructure error patterns in logs if available
                  echo "Claude Code failed - checking error type in workflow logs..."

                  # =========================================================================
                  # Check for credit/rate limit exhaustion (NOT retriable - requires pause)
                  # These errors indicate Claude Code API limits have been reached.
                  #
                  # Based on Anthropic API documentation:
                  # - 429: rate_limit_error - "Your account has hit a rate limit"
                  # - 529: overloaded_error - "The API is temporarily overloaded"
                  # - Claude Code specific: "Claude usage limit reached"
                  # =========================================================================
                  if [ -n "$WORKFLOW_LOG" ]; then
                    # Pattern 1: Anthropic API rate_limit_error (429)
                    if echo "$WORKFLOW_LOG" | grep -qiE "rate_limit_error|hit a rate limit|would exceed your.*(rate|account).?limit|Error: 429|\"type\".*429"; then
                      IS_INFRA_ERROR=false  # NOT a simple retry - requires queue pause
                      ERROR_TYPE="rate_limit_exceeded"
                      echo "âš ï¸  DETECTED: Anthropic API rate limit (429) in current run"
                      echo "   Queue should PAUSE until credits are restored"
                      echo "   Raw match:"
                      echo "$WORKFLOW_LOG" | grep -iE "rate_limit|429|hit a rate limit|exceed.*limit" | head -5
                    # Pattern 2: Anthropic API overloaded_error (529)
                    elif echo "$WORKFLOW_LOG" | grep -qiE "overloaded_error|529|temporarily overloaded|API is.*overloaded"; then
                      IS_INFRA_ERROR=false  # NOT a simple retry - requires queue pause
                      ERROR_TYPE="api_overloaded"
                      echo "âš ï¸  DETECTED: Anthropic API overloaded (529) in current run"
                      echo "   Queue should PAUSE until load decreases"
                      echo "   Raw match:"
                      echo "$WORKFLOW_LOG" | grep -iE "overloaded|529" | head -5
                    # Pattern 3: Claude Code CLI usage limit (Max plan)
                    elif echo "$WORKFLOW_LOG" | grep -qiE "Claude.*(usage|AI).?limit.?reached|usage.?limit|limit.?will.?reset|5.?hour.?limit"; then
                      IS_INFRA_ERROR=false  # NOT a simple retry - requires queue pause
                      ERROR_TYPE="credit_exhausted"
                      echo "âš ï¸  DETECTED: Claude Code usage limit reached (Max plan) in current run"
                      echo "   Queue should PAUSE until credits are restored"
                      echo "   Raw match:"
                      echo "$WORKFLOW_LOG" | grep -iE "usage.?limit|limit.?reached|limit.?will.?reset" | head -5
                    # Pattern 4: Generic credit/quota exhaustion
                    elif echo "$WORKFLOW_LOG" | grep -qiE "insufficient.?credit|credit.?limit|quota.?exceeded|billing.?error|account.?suspended"; then
                      IS_INFRA_ERROR=false  # NOT a simple retry - requires queue pause
                      ERROR_TYPE="credit_exhausted"
                      echo "âš ï¸  DETECTED: Credit/quota exhausted in current run"
                      echo "   Queue should PAUSE until credits are restored"
                      echo "   Raw match:"
                      echo "$WORKFLOW_LOG" | grep -iE "insufficient|credit|quota|billing|suspended" | head -5
                    # Pattern 5: GitHub API rate limits (infrastructure - retriable)
                    # These are different from Anthropic rate limits - GitHub limits reset quickly
                    elif echo "$WORKFLOW_LOG" | grep -qiE "API rate limit exceeded for installation|secondary rate limit|abuse detection"; then
                      IS_INFRA_ERROR=true  # GitHub rate limits are retriable after short wait
                      ERROR_TYPE="github_rate_limit"
                      echo "âš ï¸  DETECTED: GitHub API rate limit - WILL RETRY (infrastructure)"
                      echo "   Raw match:"
                      echo "$WORKFLOW_LOG" | grep -iE "rate limit|secondary rate|abuse detection" | head -5
                    # Pattern 6: Authentication errors (401/403) - but NOT GitHub rate limits
                    elif echo "$WORKFLOW_LOG" | grep -qiE "authentication_error|permission_error|issue with your API key|does not have permission|unauthorized|token.?expired|oauth.?error"; then
                      IS_INFRA_ERROR=false  # NOT a simple retry - requires manual fix
                      ERROR_TYPE="auth_error"
                      echo "âš ï¸  DETECTED: Authentication/permission error - check CLAUDE_CODE_OAUTH_TOKEN"
                      echo "   Raw match:"
                      echo "$WORKFLOW_LOG" | grep -iE "authentication|permission|unauthorized|API key|token|oauth" | head -5
                    else
                      # Default to infrastructure error for retries (conservative approach)
                      ERROR_TYPE="claude_failure"
                      IS_INFRA_ERROR=true
                    fi
                  else
                    # No logs available - default to retriable infrastructure error
                    ERROR_TYPE="claude_failure"
                    IS_INFRA_ERROR=true
                  fi
                fi
              fi
            elif [ "$CLAUDE_OUTCOME" = "success" ]; then
              # Even success might be a timeout if duration is suspicious
              if [ "$ERROR_TYPE" != "timeout_confirmed" ]; then
                ERROR_TYPE="success"
                echo "Claude Code completed successfully"
              fi
            else
              ERROR_TYPE="unknown_outcome"
              echo "Unknown outcome: $CLAUDE_OUTCOME"
              IS_INFRA_ERROR=true
            fi
          fi

          echo "is_infrastructure_error=$IS_INFRA_ERROR" >> $GITHUB_OUTPUT
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT
          echo "claude_work_succeeded=$CLAUDE_WORK_SUCCEEDED" >> $GITHUB_OUTPUT

      # CRITICAL: Explicitly set success output to fix detection issue
      # GitHub Actions has issues with expression-based outputs when steps use continue-on-error
      # This step explicitly captures both success state and branch existence for fallback
      #
      # WORKAROUND for claude-code-action post-processing 404 error:
      # The action may report failure even when Claude completed successfully, due to a bug
      # in compareCommitsWithBasehead that fails when the branch doesn't exist yet or has
      # URL encoding issues. We use branch existence as the ground truth for success.
      # Track: https://github.com/anthropics/claude-code-action/issues/804
      #
      # SDK CRASH HANDLING:
      # When Claude succeeds but SDK crashes before git push, we detect this via log analysis.
      # In this case, Claude's work is done but not pushed - manual recovery needed.
      - name: Set success output
        id: set_success
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
          CLAUDE_OUTCOME: ${{ steps.claude.outcome }}
          ERROR_TYPE: ${{ steps.detect_error.outputs.error_type }}
          CLAUDE_WORK_SUCCEEDED: ${{ steps.detect_error.outputs.claude_work_succeeded }}
        run: |
          echo "Setting success output..."
          echo "   Claude outcome: $CLAUDE_OUTCOME"
          echo "   Error type: $ERROR_TYPE"
          echo "   Claude work succeeded (from logs): $CLAUDE_WORK_SUCCEEDED"

          # Check if a branch was created (ground truth for success)
          # This is the AUTHORITATIVE check - branch existence means Claude did its job
          BRANCH_PATTERN="claude/issue-${ISSUE_NUMBER}-"
          BRANCH_NAME=$(gh api "/repos/$REPO/branches" \
            --jq "[.[] | select(.name | startswith(\"$BRANCH_PATTERN\"))][0].name" 2>/dev/null || echo "")

          if [ -n "$BRANCH_NAME" ] && [ "$BRANCH_NAME" != "null" ]; then
            echo "has_branch=true" >> $GITHUB_OUTPUT
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "âœ… Branch exists: $BRANCH_NAME"

            # WORKAROUND: If branch exists, Claude succeeded regardless of action outcome
            # This handles the post-processing 404 false negative (issue #804)
            if [ "$CLAUDE_OUTCOME" = "failure" ]; then
              echo ""
              echo "âš ï¸  WORKAROUND APPLIED: Action reported failure but branch exists"
              echo "   This is the known post-processing 404 error (issue #804)"
              echo "   Treating as SUCCESS since Claude completed its work"
            fi
            echo "claude_success=true" >> $GITHUB_OUTPUT
            echo "sdk_crash_after_success=false" >> $GITHUB_OUTPUT
            echo "no_branch_after_success=false" >> $GITHUB_OUTPUT
          else
            echo "has_branch=false" >> $GITHUB_OUTPUT
            echo "branch_name=" >> $GITHUB_OUTPUT
            echo "âš ï¸  No branch found with pattern: $BRANCH_PATTERN"

            # =========================================================================
            # SDK CRASH AFTER SUCCESS HANDLING
            # =========================================================================
            # If Claude's work succeeded (detected via log analysis) but no branch exists,
            # the SDK crashed before git push. This is a special case:
            # - Claude's work is DONE (no retry needed - would waste budget)
            # - Work exists locally in the runner but was not pushed
            # - Manual intervention needed to recover
            # =========================================================================
            if [ "$ERROR_TYPE" = "sdk_crash_after_success" ] || [ "$CLAUDE_WORK_SUCCEEDED" = "true" ]; then
              echo ""
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  SDK CRASH AFTER CLAUDE SUCCESS - WORK NOT PUSHED                    â•‘"
              echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
              echo "â•‘  Claude completed its work successfully (verified via log analysis)  â•‘"
              echo "â•‘  BUT the SDK crashed before git push could execute.                  â•‘"
              echo "â•‘                                                                       â•‘"
              echo "â•‘  ACTION REQUIRED:                                                     â•‘"
              echo "â•‘  - DO NOT retry (wastes budget, Claude already did the work)         â•‘"
              echo "â•‘  - Manual retry may help if SDK issue was transient                  â•‘"
              echo "â•‘  - Check GitHub Actions runner for any recoverable state             â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""
              echo "claude_success=false" >> $GITHUB_OUTPUT
              echo "sdk_crash_after_success=true" >> $GITHUB_OUTPUT
              echo "no_branch_after_success=false" >> $GITHUB_OUTPUT
            # No branch = genuine failure
            elif [ "$CLAUDE_OUTCOME" = "success" ]; then
              # ANOMALY: Claude reported success but no branch was pushed
              # In TDD automation, there are ALWAYS changes (at minimum .fixme() removal)
              # This indicates Claude forgot to push or push failed silently
              echo ""
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  âš ï¸  ANOMALY: Claude reported SUCCESS but NO BRANCH was pushed        â•‘"
              echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
              echo "â•‘  In TDD automation, there are ALWAYS changes to commit:              â•‘"
              echo "â•‘  - At minimum: .fixme() removal from test files                      â•‘"
              echo "â•‘  - Usually: Implementation code in src/                              â•‘"
              echo "â•‘                                                                      â•‘"
              echo "â•‘  This indicates ONE of:                                              â•‘"
              echo "â•‘  1. Claude forgot to run: git add -A && git commit && git push      â•‘"
              echo "â•‘  2. Git push failed silently (network issue, permissions)            â•‘"
              echo "â•‘  3. Claude committed but forgot to push                              â•‘"
              echo "â•‘                                                                      â•‘"
              echo "â•‘  RECOVERY: Will trigger retry with explicit push instructions        â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""
              echo "claude_success=false" >> $GITHUB_OUTPUT
              echo "sdk_crash_after_success=false" >> $GITHUB_OUTPUT
              echo "no_branch_after_success=true" >> $GITHUB_OUTPUT
            else
              echo "claude_success=false" >> $GITHUB_OUTPUT
              echo "sdk_crash_after_success=false" >> $GITHUB_OUTPUT
              echo "no_branch_after_success=false" >> $GITHUB_OUTPUT
              echo "âŒ Claude did not complete successfully (outcome: $CLAUDE_OUTCOME)"
            fi
          fi

      - name: Update issue on failure
        # Only post failure comment if Claude failed AND no branch was pushed
        # Branch existence = work completed successfully (false negative on step outcome)
        if: steps.claude.outcome != 'success' && steps.set_success.outputs.has_branch != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
          RETRY_ATTEMPT: ${{ github.event.inputs.retry_attempt || 1 }}
          ERROR_TYPE: ${{ steps.detect_error.outputs.error_type }}
          SDK_CRASH_AFTER_SUCCESS: ${{ steps.set_success.outputs.sdk_crash_after_success }}
        run: |
          echo "Updating issue #$ISSUE_NUMBER with failure information..."

          # Special handling for SDK crash after Claude success
          if [ "$SDK_CRASH_AFTER_SUCCESS" = "true" ]; then
            echo "SDK crash after Claude success detected - posting special guidance..."

            gh issue comment "$ISSUE_NUMBER" --body "**SDK Crash After Claude Success - Work Not Pushed**

          **Error Type**: \`$ERROR_TYPE\`
          **Workflow Run**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ## What Happened

          Claude completed its work **successfully** (verified via log analysis showing \`\"subtype\": \"success\"\`), but the SDK crashed before the git push operation could execute. Claude's work is done, but it was never pushed to the repository.

          ## Why This Won't Be Retried

          **Retrying would waste budget** - Claude already did the work. The SDK crash is a separate infrastructure issue that occurred after Claude finished.

          ## Recovery Options

          1. **Manual Retry (Recommended)**: Re-run this workflow - Claude will detect the previous work context and may complete more quickly
          2. **Check for Transient Issues**: The SDK crash may have been a temporary network/API issue
          3. **Report to Anthropic**: If this happens frequently, report to [claude-code-action issues](https://github.com/anthropics/claude-code-action/issues)

          ## Technical Details

          - Claude's JSON output showed: \`{\"type\": \"result\", \"subtype\": \"success\"}\`
          - SDK then crashed with error before git push
          - No branch was created on the remote repository

          ---
          *SDK Crash Handler - Not Retrying to Save Budget*"
          else
            # Standard failure comment
            gh issue comment "$ISSUE_NUMBER" --body "**Claude Code Execution Failed (Attempt $RETRY_ATTEMPT)**

          **Error Type**: \`$ERROR_TYPE\`
          **Workflow Run**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          The automation system will analyze this error and retry if appropriate.

          ---
          *Infrastructure Error Handler*"
          fi

      # =========================================================================
      # CREDIT EXHAUSTION: Pause queue and preserve spec state
      # When credits are exhausted, we don't want to:
      # - Retry immediately (wastes the retry budget)
      # - Mark the spec as failed (it's not a spec problem)
      # Instead, we pause the queue and return the spec to queued state.
      # =========================================================================
      - name: Pause queue on credit exhaustion
        if: |
          always() &&
          (steps.detect_error.outputs.error_type == 'credit_exhausted' ||
           steps.detect_error.outputs.error_type == 'rate_limit_exceeded' ||
           steps.detect_error.outputs.error_type == 'api_overloaded')
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
          ERROR_TYPE: ${{ steps.detect_error.outputs.error_type }}
          REPO: ${{ github.repository }}
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  â¸ï¸  PAUSING TDD QUEUE - CREDIT/RATE LIMIT EXHAUSTED                   â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  Error Type: $ERROR_TYPE"
          echo "â•‘  Issue: #$ISSUE_NUMBER"
          echo "â•‘                                                                      â•‘"
          echo "â•‘  The queue will PAUSE until credits are restored.                   â•‘"
          echo "â•‘  This spec will NOT count against retry limits.                     â•‘"
          echo "â•‘                                                                      â•‘"
          echo "â•‘  Auto-resume: ~2 hours (via tdd-monitor.yml)                        â•‘"
          echo "â•‘  Manual resume: gh issue edit <status-issue> --remove-label         â•‘"
          echo "â•‘                 'tdd-queue:paused'                                   â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""

          # Check if queue status issue exists
          QUEUE_STATUS_ISSUE=$(gh issue list \
            --repo "$REPO" \
            --label "tdd-queue-status" \
            --state open \
            --json number \
            --jq '.[0].number' 2>/dev/null || echo "")

          if [ -z "$QUEUE_STATUS_ISSUE" ] || [ "$QUEUE_STATUS_ISSUE" = "null" ]; then
            # Create queue status issue
            echo "Creating queue status issue..."
            ISSUE_BODY=$(cat <<'ISSUE_EOF'
          ## TDD Queue Paused

          | Field | Value |
          |-------|-------|
          ISSUE_EOF
          )
            ISSUE_BODY="$ISSUE_BODY
          | Reason | \`$ERROR_TYPE\` |
          | Paused At | $(date -u +%Y-%m-%dT%H:%M:%SZ) |
          | Triggered By | Issue #$ISSUE_NUMBER |

          ## What This Means

          The TDD automation queue has been paused because Claude Code ran out of credits or hit rate limits. No specs will be processed until the queue is resumed.

          ## Auto-Resume

          The \`tdd-monitor.yml\` workflow will automatically resume the queue after approximately 2 hours (typical credit reset window).

          ## Manual Resume

          To resume immediately (if you know credits are available):

          \`\`\`bash
          gh issue edit <this-issue> --remove-label 'tdd-queue:paused'
          \`\`\`

          ## Queue History

          | Time | Event |
          |------|-------|
          | $(date -u +%Y-%m-%dT%H:%M:%SZ) | Paused: \$ERROR_TYPE |

          ---
          _TDD Automation - Credit Management_"
            QUEUE_STATUS_ISSUE=$(gh issue create \
              --repo "$REPO" \
              --title "â¸ï¸ TDD Queue Status: PAUSED (Credit Exhaustion)" \
              --body "$ISSUE_BODY" \
              --label "tdd-queue-status,tdd-queue:paused" \
              --json number --jq '.number')
            echo "Created queue status issue: #$QUEUE_STATUS_ISSUE"
          else
            # Update existing status issue
            echo "Updating existing queue status issue #$QUEUE_STATUS_ISSUE..."
            gh issue edit "$QUEUE_STATUS_ISSUE" \
              --repo "$REPO" \
              --title "â¸ï¸ TDD Queue Status: PAUSED (Credit Exhaustion)" \
              --add-label "tdd-queue:paused"

            COMMENT_BODY="## Queue Paused Again

            | Field | Value |
            |-------|-------|
            | Reason | \`$ERROR_TYPE\` |
            | Time | $(date -u +%Y-%m-%dT%H:%M:%SZ) |
            | Triggered By | Issue #$ISSUE_NUMBER |

            ---
            _TDD Automation - Credit Management_"
            gh issue comment "$QUEUE_STATUS_ISSUE" \
              --repo "$REPO" \
              --body "$COMMENT_BODY"
          fi

          # Return the spec to queued state (not failed, not in-progress)
          echo "Returning issue #$ISSUE_NUMBER to queued state..."
          gh issue edit "$ISSUE_NUMBER" \
            --repo "$REPO" \
            --remove-label "tdd-spec:in-progress" \
            --add-label "tdd-spec:queued,paused:credit-exhaustion" || true

          # Post comment on the spec issue
          SPEC_COMMENT="## â¸ï¸ TDD Queue Paused - Credit/Rate Limit Exhaustion

          | Field | Value |
          |-------|-------|
          | Error Type | \`$ERROR_TYPE\` |

          This spec execution was halted because Claude Code ran out of credits or hit rate limits. This is NOT a spec failure - the queue will automatically retry when credits are restored.

          ### What Happens Next
          1. Queue is now paused (no new specs will be processed)
          2. This spec returns to \`tdd-spec:queued\` state
          3. Auto-resume in ~2 hours (or manual resume)
          4. Retry count is NOT incremented

          ---
          _TDD Automation - Credit Management_"
          gh issue comment "$ISSUE_NUMBER" \
            --repo "$REPO" \
            --body "$SPEC_COMMENT"

          echo "âœ… Queue paused, spec preserved for later retry"

  # =========================================================================
  # PHASE 2: Finalize e2e-test-fixer changes
  # =========================================================================
  # Workflow-managed finalization ensures reliability:
  # - bun run license (Claude can forget)
  # - Commit amend if changes
  # - Detect src/ modifications for conditional refactor-auditor
  # - Push to remote
  # =========================================================================
  finalize-fixer:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [execute-e2e-fixer]
    if: |
      always() &&
      needs.execute-e2e-fixer.outputs.has_branch == 'true'
    permissions:
      contents: write
      issues: write
    outputs:
      src_modified: ${{ steps.detect_changes.outputs.src_modified }}
      push_success: ${{ steps.push.outputs.success }}
    steps:
      - name: Checkout branch with retry
        id: checkout
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          BRANCH_NAME: ${{ needs.execute-e2e-fixer.outputs.branch_name }}
        run: |
          # Retry logic for GitHub API rate limits during checkout
          MAX_ATTEMPTS=3
          RETRY_DELAY=30

          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo "Checkout attempt $attempt of $MAX_ATTEMPTS for branch: $BRANCH_NAME"

            if git clone --branch "$BRANCH_NAME" "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git" . 2>&1; then
              echo "âœ… Checkout successful on attempt $attempt"
              exit 0
            else
              EXIT_CODE=$?
              echo "âŒ Checkout failed with exit code $EXIT_CODE"

              if [ $attempt -lt $MAX_ATTEMPTS ]; then
                echo "â³ Waiting ${RETRY_DELAY}s before retry (GitHub API rate limit may be in effect)..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              else
                echo "ğŸ’¥ All checkout attempts failed"
                exit 1
              fi
            fi
          done

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Configure git
        run: |
          USER_NAME=$(gh api user --jq '.login')
          USER_EMAIL=$(gh api user --jq '.email')
          git config user.name "$USER_NAME"
          git config user.email "$USER_EMAIL"
          echo "Git configured as $USER_NAME <$USER_EMAIL>"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Run license script
        run: |
          echo "Running bun run license..."
          bun run license

      - name: Amend commit if license added files
        run: |
          if ! git diff --quiet; then
            echo "License script made changes - amending commit..."
            git add -A
            git commit --amend --no-edit
            echo "Commit amended with license headers"
          else
            echo "No license changes needed"
          fi

      - name: Detect src/ modifications
        id: detect_changes
        run: |
          echo "Detecting if src/ files were modified..."

          # Compare branch to main
          git fetch origin main
          SRC_CHANGES=$(git diff --name-only origin/main...HEAD | grep '^src/' | wc -l | tr -d ' ')

          echo "Files in src/ changed: $SRC_CHANGES"

          if [ "$SRC_CHANGES" -gt 0 ]; then
            echo "src_modified=true" >> $GITHUB_OUTPUT
            echo "src/ modifications detected - refactor-auditor will run"
            git diff --name-only origin/main...HEAD | grep '^src/' | head -10
          else
            echo "src_modified=false" >> $GITHUB_OUTPUT
            echo "No src/ modifications - refactor-auditor will be skipped"
          fi

      - name: Push changes
        id: push
        run: |
          echo "Pushing finalized changes..."
          if git push --force-with-lease origin ${{ needs.execute-e2e-fixer.outputs.branch_name }}; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "Push successful"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "Push failed"
            exit 1
          fi

  # =========================================================================
  # PHASE 3: Codebase Refactor Auditor (CONDITIONAL)
  # =========================================================================
  # Only runs if src/ files were modified by e2e-test-fixer.
  # Skipped for test-only changes (saves $5 and 30 min).
  # =========================================================================
  execute-refactor-auditor:
    runs-on: ubuntu-latest
    timeout-minutes: 35
    needs: [execute-e2e-fixer, finalize-fixer]
    if: |
      always() &&
      needs.finalize-fixer.outputs.src_modified == 'true' &&
      needs.finalize-fixer.outputs.push_success == 'true'
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read
    outputs:
      claude_success: ${{ steps.set_success.outputs.claude_success }}
      has_changes: ${{ steps.set_success.outputs.has_changes }}
    steps:
      - name: Checkout branch with retry
        id: checkout
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          BRANCH_NAME: ${{ needs.execute-e2e-fixer.outputs.branch_name }}
        run: |
          # Retry logic for GitHub API rate limits during checkout
          MAX_ATTEMPTS=3
          RETRY_DELAY=30

          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo "Checkout attempt $attempt of $MAX_ATTEMPTS for branch: $BRANCH_NAME"

            if git clone --branch "$BRANCH_NAME" "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git" . 2>&1; then
              echo "âœ… Checkout successful on attempt $attempt"
              exit 0
            else
              EXIT_CODE=$?
              echo "âŒ Checkout failed with exit code $EXIT_CODE"

              if [ $attempt -lt $MAX_ATTEMPTS ]; then
                echo "â³ Waiting ${RETRY_DELAY}s before retry (GitHub API rate limit may be in effect)..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              else
                echo "ğŸ’¥ All checkout attempts failed"
                exit 1
              fi
            fi
          done

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Post refactor-auditor comment
        id: post_comment
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          ISSUE_NUMBER: ${{ needs.execute-e2e-fixer.outputs.issue_number }}
          SPEC_ID: ${{ needs.execute-e2e-fixer.outputs.spec_id }}
        run: |
          echo "Posting @claude comment for refactor-auditor phase..."

          gh issue comment "$ISSUE_NUMBER" --body "@claude run codebase-refactor-auditor for $SPEC_ID

          ## âš ï¸ IMPORTANT: THIS IS PHASE 2 - IGNORE ALL PREVIOUS INSTRUCTIONS

          **DO NOT follow any instructions from earlier comments in this issue.**
          The e2e-test-fixer phase has ALREADY COMPLETED. You are now in Phase 2.

          ## Phase 2: Refactoring Audit

          **Your ONLY Task** (use \`Task\` tool with \`subagent_type='codebase-refactor-auditor'\`):
          1. Audit layer architecture compliance
          2. Eliminate code duplication
          3. Run \`bun run quality\` to verify all checks pass
          4. Commit any improvements as \`refactor: audit $SPEC_ID\`
          5. Push to branch

          ## ğŸš« DO NOT (Critical)

          - âŒ **DO NOT run e2e-test-fixer** - Phase 1 is COMPLETE, spec is already implemented
          - âŒ **DO NOT follow earlier @claude comments** - They were for Phase 1
          - âŒ **DO NOT implement the spec** - Already done in Phase 1
          - âŒ DO NOT run \`bun run license\` (finalization job handles this)
          - âŒ DO NOT create PR (workflow handles this)

          ---
          *Automated via TDD Workflow (Phase 2: Refactor Audit)*"

          echo "Comment posted"

      # NOTE: Same post-processing 404 workaround as execute-e2e-fixer
      # Track: https://github.com/anthropics/claude-code-action/issues/804
      - name: Run Claude Code (codebase-refactor-auditor)
        id: claude
        uses: anthropics/claude-code-action@v1
        timeout-minutes: 30
        continue-on-error: true # Required: Action may fail in post-processing even when work completed
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GH_PAT_WORKFLOW }}
          additional_permissions: |
            actions: read
          # Budget set to $25 for refactor-auditor phase
          claude_args: >-
            --model claude-sonnet-4-5-20250929
            --max-budget-usd 25.00
            --allowedTools Edit,Read,Write,Bash,Glob,Grep,Task,TodoWrite,Skill,LSP
            --disallowedTools WebFetch,WebSearch,AskUserQuestion,NotebookEdit,SlashCommand

      - name: Set success output
        id: set_success
        if: always()
        run: |
          CLAUDE_OUTCOME="${{ steps.claude.outcome }}"

          # Check if any changes were made (ground truth for refactor success)
          HAS_CHANGES=false
          if ! git diff --quiet HEAD~1..HEAD 2>/dev/null; then
            HAS_CHANGES=true
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

          # WORKAROUND: If changes exist, Claude succeeded regardless of action outcome
          # This handles the post-processing 404 false negative (issue #804)
          if [ "$HAS_CHANGES" = "true" ]; then
            if [ "$CLAUDE_OUTCOME" = "failure" ]; then
              echo "âš ï¸  WORKAROUND APPLIED: Action reported failure but changes exist"
              echo "   This is likely the known post-processing 404 error (issue #804)"
              echo "   Treating as SUCCESS since Claude completed its work"
            fi
            echo "claude_success=true" >> $GITHUB_OUTPUT
            echo "Refactor-auditor completed successfully"
          elif [ "$CLAUDE_OUTCOME" = "success" ]; then
            echo "claude_success=true" >> $GITHUB_OUTPUT
            echo "Refactor-auditor completed successfully (no changes needed)"
          else
            echo "claude_success=false" >> $GITHUB_OUTPUT
            echo "Refactor-auditor did not complete successfully (outcome: $CLAUDE_OUTCOME)"
          fi

  # =========================================================================
  # PHASE 4: Finalize refactor-auditor changes
  # =========================================================================
  finalize-auditor:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [execute-e2e-fixer, execute-refactor-auditor]
    # Run when refactor-auditor succeeds OR when it made changes (even if Claude failed after)
    # This ensures changes are pushed even if Claude encounters API errors post-commit
    if: |
      always() &&
      (needs.execute-refactor-auditor.result == 'success' ||
       needs.execute-refactor-auditor.outputs.has_changes == 'true')
    permissions:
      contents: write
    steps:
      - name: Checkout branch with retry
        id: checkout
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          BRANCH_NAME: ${{ needs.execute-e2e-fixer.outputs.branch_name }}
        run: |
          # Retry logic for GitHub API rate limits during checkout
          MAX_ATTEMPTS=3
          RETRY_DELAY=30

          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo "Checkout attempt $attempt of $MAX_ATTEMPTS for branch: $BRANCH_NAME"

            if git clone --branch "$BRANCH_NAME" "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git" . 2>&1; then
              echo "âœ… Checkout successful on attempt $attempt"
              exit 0
            else
              EXIT_CODE=$?
              echo "âŒ Checkout failed with exit code $EXIT_CODE"

              if [ $attempt -lt $MAX_ATTEMPTS ]; then
                echo "â³ Waiting ${RETRY_DELAY}s before retry (GitHub API rate limit may be in effect)..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              else
                echo "ğŸ’¥ All checkout attempts failed"
                exit 1
              fi
            fi
          done

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Configure git
        run: |
          USER_NAME=$(gh api user --jq '.login')
          USER_EMAIL=$(gh api user --jq '.email')
          git config user.name "$USER_NAME"
          git config user.email "$USER_EMAIL"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Run license script
        run: bun run license

      - name: Amend commit if license added files
        run: |
          if ! git diff --quiet; then
            echo "License script made changes - amending commit..."
            git add -A
            git commit --amend --no-edit
            echo "Commit amended"
          fi

      - name: Push changes
        run: |
          git push --force-with-lease origin ${{ needs.execute-e2e-fixer.outputs.branch_name }}
          echo "Final push complete"

  # Retry logic: Automatically retry infrastructure errors and anomalies
  handle-retry:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [execute-e2e-fixer]
    # Retry if ANY of these conditions are met:
    # A) Standard infrastructure error retry:
    #    - Claude didn't report success AND
    #    - No branch was created AND
    #    - Infrastructure-related error AND
    #    - NOT an SDK crash after success (would waste budget)
    # B) Success-without-branch anomaly:
    #    - Claude reported success but no branch pushed
    #    - In TDD automation, there are ALWAYS changes (.fixme() removal at minimum)
    #    - This is an agent/infrastructure issue that retry can fix
    if: |
      always() &&
      needs.execute-e2e-fixer.outputs.has_branch != 'true' &&
      needs.execute-e2e-fixer.outputs.sdk_crash_after_success != 'true' &&
      (
        (needs.execute-e2e-fixer.outputs.claude_success != 'true' && needs.execute-e2e-fixer.outputs.is_infrastructure_error == 'true') ||
        needs.execute-e2e-fixer.outputs.no_branch_after_success == 'true'
      )
    permissions:
      actions: write
      issues: write
    steps:
      # FIX 1: Check for recent retry comments (cooldown) - prevents infinite loops
      # This catches loops where @claude comments trigger this workflow repeatedly
      - name: Check for recent retry comments (cooldown)
        id: cooldown
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
        run: |
          echo "ğŸ• Checking for recent retry activity (30 min cooldown)..."

          # 30 minute cooldown for retries
          CUTOFF_TIME=$(date -u -d '30 minutes ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || \
                        date -u -v-30M +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || \
                        echo "1970-01-01T00:00:00Z")

          # Check for ANY retry-related comments in cooldown period
          RECENT_RETRIES=$(gh api "/repos/${{ github.repository }}/issues/$ISSUE_NUMBER/comments" \
            --jq "[.[] | select(.created_at > \"$CUTOFF_TIME\") | select(.body | test(\"Automatic Retry|@claude retry|Success Without Branch\"; \"i\"))] | length" \
            2>/dev/null || echo "0")

          echo "  Recent retry comments in last 30 min: $RECENT_RETRIES"

          if [ "$RECENT_RETRIES" -gt 0 ]; then
            echo "â­ï¸  Cooldown active - skipping retry to prevent loop"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "âœ… No recent retries, proceeding"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      # FIX 2: Get retry count from labels (not github.event.inputs which resets on comment triggers)
      # This is the actual bug fix - comment-triggered workflows had retry count reset to 1
      - name: Get retry count from labels
        id: label_retry
        if: steps.cooldown.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
        run: |
          echo "ğŸ“Š Getting retry count from issue labels..."

          LABELS=$(gh issue view "$ISSUE_NUMBER" --repo ${{ github.repository }} --json labels --jq '.labels[].name' 2>/dev/null | tr '\n' ' ' || echo "")
          echo "  Labels: $LABELS"

          # FIX 3: Check for max retries or manual resolution BEFORE attempting retry
          if echo "$LABELS" | grep -qE "retry:(spec|infra):3|tdd-spec:failed|needs-manual-resolution"; then
            echo "â­ï¸  Max retries reached or manual resolution needed - skipping"
            echo "max_reached=true" >> $GITHUB_OUTPUT
            echo "current_retry=3" >> $GITHUB_OUTPUT
          else
            echo "max_reached=false" >> $GITHUB_OUTPUT

            # Extract highest retry count from labels (fixes the reset bug)
            RETRY_COUNT=0
            for i in 3 2 1; do
              if echo "$LABELS" | grep -qE "retry:(infra|spec):$i"; then
                RETRY_COUNT=$i
                break
              fi
            done

            echo "  Current retry count from labels: $RETRY_COUNT"
            echo "current_retry=$RETRY_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: Determine retry action
        id: retry
        if: steps.cooldown.outputs.skip != 'true' && steps.label_retry.outputs.max_reached != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          # FIX: Use label-based retry count, fallback to input only if labels show 0
          CURRENT_RETRY: ${{ steps.label_retry.outputs.current_retry || github.event.inputs.retry_attempt || 0 }}
          MAX_RETRIES: ${{ env.MAX_INFRASTRUCTURE_RETRIES }}
          ERROR_TYPE: ${{ needs.execute-e2e-fixer.outputs.error_type }}
          NO_BRANCH_AFTER_SUCCESS: ${{ needs.execute-e2e-fixer.outputs.no_branch_after_success }}
        run: |
          echo "Error detected: $ERROR_TYPE"
          echo "No branch after success: $NO_BRANCH_AFTER_SUCCESS"
          echo "Current retry attempt: $CURRENT_RETRY of $MAX_RETRIES (from labels)"

          NEXT_RETRY=$((CURRENT_RETRY + 1))

          if [ "$NEXT_RETRY" -le "$MAX_RETRIES" ]; then
            echo "âœ… Will retry (attempt $NEXT_RETRY)"
            echo "should_retry=true" >> $GITHUB_OUTPUT
            echo "next_retry=$NEXT_RETRY" >> $GITHUB_OUTPUT

            # Add retry label based on error type (using consistent retry:* prefix)
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" --add-label "retry:spec:$CURRENT_RETRY" 2>/dev/null || true
            else
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" --add-label "retry:infra:$CURRENT_RETRY" 2>/dev/null || true
            fi

            # Build retry comment with error-specific instructions
            # Check for success-without-branch anomaly first (special case)
            if [ "$NO_BRANCH_AFTER_SUCCESS" = "true" ]; then
              RETRY_COMMENT="**Automatic Retry: Success Without Branch Anomaly**

          **Issue**: Claude reported success but NO branch was pushed
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES
          **Reason**: In TDD automation, there are ALWAYS changes (.fixme() removal at minimum)

          **CRITICAL INSTRUCTIONS FOR CLAUDE:**
          This is a known issue where Claude completes work but forgets to push. You MUST:

          1. **Complete ALL your work** (remove .fixme(), implement code)
          2. **Run quality checks**: \`bun run quality\`
          3. **MANDATORY GIT SEQUENCE** (do NOT skip any step):
             \`\`\`bash
             git add -A
             git commit -m \"fix: implement SPEC-ID\"
             git push origin HEAD
             \`\`\`
          4. **VERIFY push succeeded** - check output shows branch pushed to origin

          **Why this happened**:
          - You likely completed the work but forgot \`git push\`
          - Or \`git push\` failed silently (network issue)
          - The workflow detected your success report but no branch on GitHub

          Retrying with explicit push instructions...

          ---
          *TDD Error Handler - Success Without Branch Recovery*"
              # Mark as infrastructure retry (agent behavior issue)
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" --add-label "retry:infra:$CURRENT_RETRY" 2>/dev/null || true
            elif [ "$ERROR_TYPE" = "lint_error" ]; then
              RETRY_COMMENT="**Automatic Code Fix Retry**

          **Error Type**: \`$ERROR_TYPE\` (ESLint violation)
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

          **CRITICAL FIX INSTRUCTIONS FOR CLAUDE:**
          1. Run \`bun run lint\` to see the exact ESLint errors
          2. **Common FP violations to fix:**
             - âŒ \`array.push()\` â†’ âœ… Use \`[...array, item]\`
             - âŒ \`for/while\` loops â†’ âœ… Use \`map/filter/reduce\`
             - âŒ Mutable \`const arr = []\` â†’ âœ… Use immutable patterns
          3. Fix ALL lint errors before committing
          4. Run \`bun run quality\` to verify

          Retrying with fix instructions...

          ---
          *TDD Error Handler*"
            elif [ "$ERROR_TYPE" = "test_failure" ]; then
              RETRY_COMMENT="**Automatic Test Fix Retry**

          **Error Type**: \`$ERROR_TYPE\`
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

          **FIX INSTRUCTIONS FOR CLAUDE:**
          1. Run \`bun test:e2e -- <test-file>\` to see failing tests
          2. Analyze the error output and fix the implementation
          3. Ensure ALL tests in the file pass before committing
          4. Run \`bun run quality\` to verify

          Retrying with fix instructions...

          ---
          *TDD Error Handler*"
            elif [ "$ERROR_TYPE" = "code_error" ]; then
              RETRY_COMMENT="**Automatic Code Fix Retry**

          **Error Type**: \`$ERROR_TYPE\` (Syntax/Type error)
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

          **FIX INSTRUCTIONS FOR CLAUDE:**
          1. Run \`bun run typecheck\` to see TypeScript errors
          2. Fix all type errors before committing
          3. Run \`bun run quality\` to verify

          Retrying with fix instructions...

          ---
          *TDD Error Handler*"
            else
              RETRY_COMMENT="**Automatic Infrastructure Retry**

          **Error Type**: \`$ERROR_TYPE\`
          **Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES
          **Reason**: Infrastructure/environment error (not code-related)

          Retrying workflow automatically with exponential backoff...

          ---
          *Infrastructure Error Handler*"
            fi

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$RETRY_COMMENT"

            # Exponential backoff with jitter to avoid thundering herd
            # Delays: 60s (retry 1â†’2), 120s (retry 2â†’3), 240s (retry 3â†’4)
            BASE_DELAY=$((60 * (1 << (CURRENT_RETRY - 1))))

            # Add jitter (Â±25% randomness)
            JITTER_RANGE=$((BASE_DELAY / 4))
            JITTER=$((RANDOM % (JITTER_RANGE * 2 + 1) - JITTER_RANGE))
            ACTUAL_DELAY=$((BASE_DELAY + JITTER))

            # Ensure minimum 30s delay
            if [ "$ACTUAL_DELAY" -lt 30 ]; then
              ACTUAL_DELAY=30
            fi

            echo "Waiting ${ACTUAL_DELAY}s before retry (base: ${BASE_DELAY}s, jitter: ${JITTER}s)"
            sleep "$ACTUAL_DELAY"
          else
            echo "âŒ Max retries exhausted ($MAX_RETRIES)"
            echo "should_retry=false" >> $GITHUB_OUTPUT

            # Mark as failed with appropriate label (using failure:* prefix for consistency)
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:failed" \
                --add-label "failure:spec" 2>/dev/null || true
            else
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:failed" \
                --add-label "failure:infra" 2>/dev/null || true
            fi

            # Build failure message based on error type
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              FAILURE_COMMENT="**Code Error - Max Retries Exhausted**

          **Error Type**: \`$ERROR_TYPE\`
          **Total Attempts**: $MAX_RETRIES
          **Status**: Marked as \`tdd-spec:failed\`

          Claude was unable to fix the code errors after $MAX_RETRIES attempts. Manual intervention required.

          **Possible Solutions**:
          1. Check the PR for specific error details
          2. Manually fix the code and push
          3. Review the agent instructions for missing patterns
          4. Skip automation and implement manually

          The queue processor will continue with the next spec.

          ---
          *TDD Error Handler*"
            else
              FAILURE_COMMENT="**Infrastructure Error - Max Retries Exhausted**

          **Error Type**: \`$ERROR_TYPE\`
          **Total Attempts**: $MAX_RETRIES
          **Status**: Marked as \`tdd-spec:failed\`

          This spec failed due to infrastructure/environment errors, not code issues. Manual intervention required.

          **Possible Solutions**:
          1. Check GitHub Actions runner status
          2. Check if Claude Code API is experiencing issues
          3. Manually retry via workflow_dispatch
          4. Skip automation and implement manually

          The queue processor will continue with the next spec.

          ---
          *Infrastructure Error Handler*"
            fi

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$FAILURE_COMMENT"
          fi

      - name: Alert on high failure rate
        if: steps.retry.outputs.should_retry != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
        run: |
          echo "Checking for high failure rate..."

          # Count failed specs in last 24 hours
          CUTOFF_DATE=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-24H +%Y-%m-%dT%H:%M:%SZ)

          FAILED_COUNT=$(gh issue list \
            --repo "$REPO" \
            --label "tdd-spec:failed" \
            --state all \
            --json number,createdAt,labels \
            --jq "[.[] | select(.createdAt > \"$CUTOFF_DATE\")] | length")

          echo "Failed specs in last 24h: $FAILED_COUNT"

          # Create incident if >= 5 failures
          if [ "$FAILED_COUNT" -ge 5 ]; then
            echo "High failure rate detected - creating incident..."

            # Check if incident already exists
            EXISTING_INCIDENT=$(gh issue list \
              --repo "$REPO" \
              --label "incident,high-failure-rate" \
              --state open \
              --json number \
              --jq 'length')

            if [ "$EXISTING_INCIDENT" -eq 0 ]; then
              # Get list of failed spec IDs
              FAILED_SPECS=$(gh issue list \
                --repo "$REPO" \
                --label "tdd-spec:failed" \
                --state all \
                --limit 10 \
                --json number,createdAt,title \
                --jq "[.[] | select(.createdAt > \"$CUTOFF_DATE\")] | map(\"- #\(.number): \(.title)\") | join(\"\n\")")

              gh issue create \
                --repo "$REPO" \
                --title "TDD Automation: High Failure Rate ($FAILED_COUNT specs failed in 24h)" \
                --label "incident,high-failure-rate,tdd-automation,priority:high" \
                --body "## High TDD Spec Failure Rate"$'\n\n'"Failed Specs (24h): $FAILED_COUNT"$'\n'"Threshold: 5"$'\n\n'"### Recent Failures"$'\n'"$FAILED_SPECS"$'\n\n'"### Investigation Steps"$'\n'"1. Check for common error patterns: \`gh issue list --label tdd-spec:failed --limit 20\`"$'\n'"2. Review tdd-execute.yml runs: [Workflow History](https://github.com/$REPO/actions/workflows/tdd-execute.yml)"$'\n'"3. Check infrastructure health: \`gh run list --workflow tdd-monitor.yml\`"$'\n\n'"### Possible Causes"$'\n'"- Systemic test issues (flaky tests, environment problems)"$'\n'"- Infrastructure instability (runner timeouts, permission errors)"$'\n'"- Schema/API changes breaking multiple specs"$'\n'"- Claude Code regression (instruction following issues)"$'\n\n'"### Resolution"$'\n'"Once root cause identified and fixed:"$'\n'"1. Re-queue failed specs: \`gh issue edit ISSUE_NUMBER --remove-label tdd-spec:failed --add-label tdd-spec:queued\`"$'\n'"2. Close this incident"$'\n'"3. Document in TDD-TROUBLESHOOTING.md"$'\n\n'"---"$'\n'"Automated via [TDD Monitor](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"

              echo "âœ… Incident issue created"
            else
              echo "Incident already exists, skipping creation"
            fi
          else
            echo "Failure rate acceptable ($FAILED_COUNT < 5)"
          fi

      - name: Trigger retry workflow
        if: steps.retry.outputs.should_retry == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          NEXT_RETRY: ${{ steps.retry.outputs.next_retry }}
        run: |
          echo "Triggering retry workflow (attempt $NEXT_RETRY)..."

          # Trigger the workflow - capture exit status to allow fallback on failure
          # Bug fix: Previously, failure here would exit immediately due to set -e,
          # preventing the fallback @claude comment from being posted
          DISPATCH_FAILED=false
          if ! gh workflow run tdd-execute.yml --repo "$REPO" \
            --field issue_number="$ISSUE_NUMBER" \
            --field retry_attempt="$NEXT_RETRY" 2>&1; then
            echo "Workflow dispatch failed (likely 403 permission error) - will use fallback"
            DISPATCH_FAILED=true
          fi

          # Skip verification if dispatch already failed - go straight to fallback
          RETRY_STARTED=false
          if [ "$DISPATCH_FAILED" != "true" ]; then
            # Wait for workflow to start
            echo "Verifying retry workflow started..."
            sleep 15

            # Check if workflow started in the last 20 seconds
            NOW=$(date +%s)

            # Get recent runs with error handling
            RECENT_RUNS=$(gh run list \
              --workflow tdd-execute.yml \
              --repo "$REPO" \
              --limit 5 \
              --json event,createdAt,status 2>&1) || true

            # Validate JSON before parsing
            if echo "$RECENT_RUNS" | jq empty 2>/dev/null; then
              # Check for a workflow_dispatch run created in the last 20 seconds
              # Bug fix: Use process substitution to avoid subshell variable scope issue
              while read -r run; do
                if [ -n "$run" ]; then
                  CREATED_AT=$(echo "$run" | jq -r '.createdAt' 2>/dev/null || echo "")
                  if [ -n "$CREATED_AT" ]; then
                    CREATED_EPOCH=$(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s 2>/dev/null || echo 0)
                    AGE=$((NOW - CREATED_EPOCH))

                    if [ "$AGE" -lt 20 ]; then
                      RETRY_STARTED=true
                      echo "âœ… Retry workflow started successfully"
                      break
                    fi
                  fi
                fi
              done < <(echo "$RECENT_RUNS" | jq -r '.[] | select(.event == "workflow_dispatch")' 2>/dev/null)
            else
              echo "Failed to parse workflow runs (JSON error) - will use fallback method"
            fi
          fi

          # If workflow didn't start, use issue comment as fallback
          if [ "$RETRY_STARTED" != "true" ]; then
            echo "Workflow dispatch may have failed, triggering via issue comment as fallback..."

            # Get spec details from issue for context
            SPEC_ID=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json title --jq '.title' | grep -oP '[A-Z]+-[A-Z]+-([0-9]+|REGRESSION)' || echo "unknown")
            TEST_FILE=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json body --jq '.body' | grep -oP 'Test File.*`\K[^`]+' || echo "unknown")

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "@claude retry implementation (automated retry $NEXT_RETRY of 3 - workflow dispatch fallback)

            ## Spec Details

            - **Test File**: \`$TEST_FILE\`
            - **Spec ID**: \`$SPEC_ID\`
            - **Issue**: #$ISSUE_NUMBER
            - **Retry Attempt**: $NEXT_RETRY of 3
            - **Trigger**: Workflow dispatch failed, using comment fallback

            ## Retry Context

            Check for previous work before starting:
            1. Run \`git status\` to see if uncommitted changes exist
            2. Run \`git log --oneline -5\` to see recent commits
            3. If work exists, continue from where it left off
            4. If clean state, start fresh with step 1 below

            ## Automation Mode

            **You are in pipeline/automation mode**:
            - âœ… Make autonomous decisions following Sovrium patterns
            - âœ… Implement minimal code to pass the test
            - âŒ DO NOT ask questions - proceed with best judgment
            - âŒ DO NOT skip any steps - all are MANDATORY

            ## âœ… Your Task (e2e-test-fixer agent ONLY)

            Run the e2e-test-fixer agent using \`Task\` tool with \`subagent_type='e2e-test-fixer'\`:
            1. Remove \`.fixme()\` from \`$SPEC_ID\`
            2. Implement minimal code to pass the test
            3. Commit changes as \`fix: implement $SPEC_ID\`
            4. Push to branch

            ## ğŸš« DO NOT (workflow handles automatically)

            - âŒ DO NOT run codebase-refactor-auditor (separate conditional workflow job)
            - âŒ DO NOT run \`bun run license\` (finalize job handles this)
            - âŒ DO NOT create PR (verify-success job handles this)

            **Complete workflow documentation**: \`@docs/development/tdd-automation-pipeline.md\`

            ---
            *Infrastructure Retry Handler (Fallback)*"

            echo "âœ… Fallback retry triggered via issue comment with full context"
          fi

  # =========================================================================
  # PHASE 5: Verify success and create PR
  # =========================================================================
  # IMPORTANT: Claude Code can run for up to 60 minutes. During that time:
  # - Another workflow might have already created and merged a PR for this issue
  # - The issue might have been closed by a merged PR
  # This job detects and handles these duplicate PR scenarios
  #
  # RELIABILITY FIX: Run this job when EITHER:
  # - finalize-fixer succeeded (branch was pushed after e2e-test-fixer)
  # - finalize-auditor succeeded (branch was pushed after refactor-auditor)
  # - has_branch == 'true' (fallback: Claude pushed a branch but success detection failed)
  #
  # Note: finalize-auditor may be skipped if no src/ changes were made.
  # =========================================================================
  verify-success:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [execute-e2e-fixer, finalize-fixer, finalize-auditor]
    # Run when:
    # - finalize-fixer pushed successfully (test-only changes or src changes before auditor)
    # - finalize-auditor succeeded (full workflow with src changes)
    # - has_branch fallback (Claude pushed but success detection failed)
    if: |
      always() &&
      (needs.finalize-fixer.outputs.push_success == 'true' ||
       needs.finalize-auditor.result == 'success' ||
       needs.execute-e2e-fixer.outputs.has_branch == 'true')
    permissions:
      issues: write
      pull-requests: write  # Need write to close duplicate PRs
    steps:
      # DUPLICATE PREVENTION: Check if issue was already completed during Claude's execution
      # This prevents duplicate PRs when Claude runs for 60 minutes and another PR merges first
      - name: Check for duplicate/stale state
        id: duplicate_check
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
        run: |
          echo "Checking if issue #$ISSUE_NUMBER is still open and needs a PR..."

          # Check 1: Is the issue still open?
          ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")

          if [ "$ISSUE_STATE" = "CLOSED" ]; then
            echo "âš ï¸  Issue #$ISSUE_NUMBER is CLOSED - another PR likely merged during Claude's execution"
            echo "   Skipping PR creation/verification to prevent duplicate PR"
            echo "is_duplicate=true" >> $GITHUB_OUTPUT
            echo "reason=issue_closed" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check 2: Are there any merged PRs for this issue?
          MERGED_PR_COUNT=$(gh pr list \
            --repo "$REPO" \
            --search "Closes #$ISSUE_NUMBER in:body" \
            --state merged \
            --json number \
            --jq 'length' 2>/dev/null || echo "0")

          if [ "$MERGED_PR_COUNT" -gt 0 ]; then
            MERGED_PRS=$(gh pr list \
              --repo "$REPO" \
              --search "Closes #$ISSUE_NUMBER in:body" \
              --state merged \
              --json number,mergedAt \
              --jq '[.[] | "#\(.number) (merged \(.mergedAt))"] | join(", ")' 2>/dev/null || echo "")
            echo "âš ï¸  Found $MERGED_PR_COUNT merged PR(s) for issue #$ISSUE_NUMBER: $MERGED_PRS"
            echo "   Skipping PR creation/verification to prevent duplicate PR"
            echo "is_duplicate=true" >> $GITHUB_OUTPUT
            echo "reason=pr_already_merged" >> $GITHUB_OUTPUT
            echo "merged_prs=$MERGED_PRS" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "âœ… Issue #$ISSUE_NUMBER is open with no merged PRs - proceeding with PR verification"
          echo "is_duplicate=false" >> $GITHUB_OUTPUT

      - name: Handle duplicate scenario
        if: steps.duplicate_check.outputs.is_duplicate == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          REASON: ${{ steps.duplicate_check.outputs.reason }}
          MERGED_PRS: ${{ steps.duplicate_check.outputs.merged_prs }}
        run: |
          echo "Handling duplicate scenario: $REASON"

          if [ "$REASON" = "issue_closed" ]; then
            # Issue was closed - likely by another merged PR
            # Any branch/PR created by this Claude run is now obsolete
            COMMENT_BODY="**Duplicate Prevention**: Claude Code completed, but issue was already closed.

          This typically happens when:
          - Another workflow completed and merged a PR for this issue
          - The issue was manually closed
          - A concurrent Claude Code run finished first

          **No action needed** - the issue is already resolved.

          ---
          *Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            # Post comment only if issue is still accessible (it might be closed)
            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$COMMENT_BODY" 2>/dev/null || echo "Could not post comment (issue may be closed)"

          elif [ "$REASON" = "pr_already_merged" ]; then
            # A PR was already merged for this issue
            COMMENT_BODY="**Duplicate Prevention**: Claude Code completed, but a PR was already merged for this issue.

          **Merged PR(s)**: $MERGED_PRS

          This typically happens when Claude Code runs for a long time (up to 60 minutes) and another PR is created and merged during that period.

          **No action needed** - the work is already complete.

          ---
          *Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$COMMENT_BODY" 2>/dev/null || echo "Could not post comment (issue may be closed)"

            # Close any open PRs that Claude might have created (they're now duplicates)
            echo "Checking for any open PRs created by this run that need to be closed..."
            OPEN_PRS=$(gh pr list \
              --repo "$REPO" \
              --search "Closes #$ISSUE_NUMBER in:body" \
              --state open \
              --json number,headRefName \
              --jq '.[] | "\(.number):\(.headRefName)"' 2>/dev/null || echo "")

            for PR_INFO in $OPEN_PRS; do
              PR_NUM=$(echo "$PR_INFO" | cut -d: -f1)
              BRANCH=$(echo "$PR_INFO" | cut -d: -f2)
              echo "  Closing duplicate PR #$PR_NUM (branch: $BRANCH)..."
              gh pr close "$PR_NUM" --repo "$REPO" \
                --comment "**Closing as duplicate**: PR(s) $MERGED_PRS already merged for issue #$ISSUE_NUMBER." \
                --delete-branch 2>/dev/null || echo "    Could not close PR #$PR_NUM"
            done
          fi

          echo "âœ… Duplicate handling complete - exiting successfully (no further action needed)"

      # =========================================================================
      # PHASE 2: Workflow-managed PR creation
      # =========================================================================
      # Claude is now instructed to commit and push, but NOT create PR.
      # The workflow creates the PR to ensure reliable "Closes #XXXX" format.
      # =========================================================================

      - name: Create PR from branch (workflow-managed)
        # Skip if duplicate was detected (issue already closed or PR already merged)
        if: steps.duplicate_check.outputs.is_duplicate != 'true'
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
        run: |
          # =========================================================================
          # PR CONTEXT DETECTION: Handle case where trigger is a PR, not an issue
          # =========================================================================
          # When triggered on PR #6590 that "Closes #4598", ISSUE_NUMBER becomes 6590,
          # but the branch was created as claude/issue-4598-*. We need to detect this
          # and extract the actual linked issue number from the PR body.
          #
          # Detection method: Check if ISSUE_NUMBER corresponds to a PR (not just an issue)
          # If it's a PR with a "Closes #XXXX" in the body, use that issue number instead.

          ORIGINAL_NUMBER="$ISSUE_NUMBER"

          # Check if ISSUE_NUMBER is actually a PR
          PR_CHECK=$(gh pr view "$ISSUE_NUMBER" --repo "$REPO" --json number,body 2>/dev/null || echo "")

          if [ -n "$PR_CHECK" ] && [ "$PR_CHECK" != "null" ]; then
            # This is a PR context - extract linked issue from PR body
            PR_BODY=$(echo "$PR_CHECK" | jq -r '.body // ""')
            LINKED_ISSUE=$(echo "$PR_BODY" | grep -oE 'Closes #[0-9]+' | grep -oE '[0-9]+' | head -1 || echo "")

            if [ -n "$LINKED_ISSUE" ] && [ "$LINKED_ISSUE" != "$ISSUE_NUMBER" ]; then
              echo "Detected PR context: PR #$ISSUE_NUMBER closes issue #$LINKED_ISSUE"
              echo "   Switching to linked issue number for branch search..."
              ISSUE_NUMBER="$LINKED_ISSUE"
            fi
          fi

          echo "Looking for branch to create PR for issue #$ISSUE_NUMBER..."

          # Check if PR already exists (Claude might have created one despite instructions)
          EXISTING_PR=$(gh pr list --repo "$REPO" \
            --json number,headRefName \
            --jq "[.[] | select(.headRefName | test(\"^claude/issue-.*$ISSUE_NUMBER.*\"))][0].number" 2>/dev/null || echo "")

          if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
            echo "âœ… PR #$EXISTING_PR already exists - skipping PR creation"

            # Check if auto-merge is enabled on existing PR
            AUTO_MERGE_STATUS=$(gh pr view "$EXISTING_PR" --repo "$REPO" --json autoMergeRequest --jq '.autoMergeRequest' 2>/dev/null || echo "null")

            if [ "$AUTO_MERGE_STATUS" = "null" ] || [ -z "$AUTO_MERGE_STATUS" ]; then
              echo "Auto-merge not enabled on existing PR - enabling now..."
              if gh pr merge "$EXISTING_PR" --auto --squash --repo "$REPO"; then
                echo "âœ… Auto-merge enabled on PR #$EXISTING_PR"
              else
                echo "âš ï¸  Failed to enable auto-merge on PR #$EXISTING_PR - may need manual merge"
              fi
            else
              echo "âœ… Auto-merge already enabled on PR #$EXISTING_PR"
            fi

            echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT
            echo "pr_created=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Find branch created by Claude
          BRANCH_PATTERN="claude/issue-${ISSUE_NUMBER}-"
          BRANCH_FULL_NAME=$(gh api "/repos/$REPO/branches" \
            --jq "[.[] | select(.name | startswith(\"$BRANCH_PATTERN\"))][0].name" 2>/dev/null || echo "")

          if [ -z "$BRANCH_FULL_NAME" ] || [ "$BRANCH_FULL_NAME" = "null" ]; then
            echo "âŒ No branch found with pattern: $BRANCH_PATTERN"
            echo "   Claude may not have pushed changes."
            echo ""
            echo "Marking issue as failed..."

            gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
              --remove-label "tdd-spec:in-progress" \
              --add-label "tdd-spec:failed"

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "âŒ **TDD Automation Failed: No Branch Found**

          Claude Code finished but no branch was pushed to the repository.

          **Expected branch pattern**: \`$BRANCH_PATTERN*\`

          **Next Steps**:
          1. Check if Claude encountered an error during implementation
          2. Re-run this spec if needed

          **Issue Status**: Marked as \`tdd-spec:failed\` - requires manual intervention.

          ---
          *ğŸ¤– Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            exit 1
          fi

          echo "âœ… Found branch: $BRANCH_FULL_NAME"

          # Get spec ID from issue body
          SPEC_ID=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json body --jq '.body' | grep -oE '[A-Z]+-[A-Z]+-[A-Z0-9-]+' | head -1 || echo "unknown-spec")

          echo "Creating PR for $SPEC_ID..."

          # Create PR with guaranteed correct format
          # CRITICAL: Body is EXACTLY "Closes #XXXX" - nothing else
          # Retry up to 3 times for transient network errors
          #
          # RELIABILITY FIX: Don't use --json --jq flags - they fail when gh pr create
          # returns an error (tries to parse non-JSON error message as JSON).
          # Instead, extract PR number from the URL in the success output.
          PR_NUMBER=""
          PR_CREATE_ERROR=""

          # Disable exit-on-error for retry loop (default behavior can vary)
          set +e

          for attempt in 1 2 3; do
            echo "PR creation attempt $attempt/3..."

            # Capture output AND exit code separately
            PR_CREATE_OUTPUT=$(gh pr create \
              --repo "$REPO" \
              --head "$BRANCH_FULL_NAME" \
              --base main \
              --title "fix: implement $SPEC_ID" \
              --body "Closes #${ISSUE_NUMBER}" \
              --label "tdd-automation" 2>&1)
            PR_EXIT_CODE=$?

            echo "Exit code: $PR_EXIT_CODE"
            echo "Output: $PR_CREATE_OUTPUT"

            # Extract PR number from URL (format: https://github.com/owner/repo/pull/123)
            if [ $PR_EXIT_CODE -eq 0 ]; then
              PR_NUMBER=$(echo "$PR_CREATE_OUTPUT" | grep -oE '/pull/[0-9]+' | grep -oE '[0-9]+' | head -1)
              if [ -n "$PR_NUMBER" ]; then
                echo "âœ… PR creation succeeded on attempt $attempt"
                break
              fi
            fi

            # Check if it's a duplicate error (no retry needed)
            if echo "$PR_CREATE_OUTPUT" | grep -qi "already exists"; then
              echo "PR already exists - no retry needed"
              # Try to extract existing PR number
              PR_NUMBER=$(echo "$PR_CREATE_OUTPUT" | grep -oE '/pull/[0-9]+' | grep -oE '[0-9]+' | head -1)
              PR_CREATE_ERROR="$PR_CREATE_OUTPUT"
              break
            fi

            PR_CREATE_ERROR="$PR_CREATE_OUTPUT"
            if [ "$attempt" -lt 3 ]; then
              DELAY=$((attempt * 5))
              echo "âš ï¸  Attempt $attempt failed (exit code $PR_EXIT_CODE): $PR_CREATE_OUTPUT"
              echo "Retrying in ${DELAY}s..."
              sleep $DELAY
            fi
          done

          # Re-enable exit-on-error
          set -e

          if [ -n "$PR_NUMBER" ] && [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "âœ… PR #$PR_NUMBER created successfully!"
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "pr_created=true" >> $GITHUB_OUTPUT

            # Enable auto-merge
            echo ""
            echo "Enabling auto-merge..."
            if gh pr merge "$PR_NUMBER" --auto --squash --repo "$REPO"; then
              echo "âœ… Auto-merge enabled"
            else
              echo "âš ï¸  Auto-merge failed - PR will need manual merge"
            fi

            # Post success comment
            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "âœ… **PR Created**: #$PR_NUMBER

          Workflow created PR from branch \`$BRANCH_FULL_NAME\` with auto-merge enabled.

          PR will merge automatically when CI passes.

          ---
          *Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"
          else
            echo "âŒ PR creation failed after 3 attempts: $PR_CREATE_ERROR"

            gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
              --remove-label "tdd-spec:in-progress" \
              --add-label "tdd-spec:failed"

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "âŒ **TDD Automation Failed: PR Creation Error**

          Branch \`$BRANCH_FULL_NAME\` exists but PR creation failed after 3 retry attempts.

          **Error**: \`$PR_CREATE_ERROR\`

          **Next Steps**:
          1. Manually create PR from branch \`$BRANCH_FULL_NAME\`
          2. Or investigate the error above

          **Issue Status**: Marked as \`tdd-spec:failed\` - requires manual intervention.

          ---
          *Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            exit 1
          fi

      # Safety net: Validate PR body in case Claude created PR despite instructions
      # (When workflow creates PR, body is guaranteed correct)
      - name: Validate PR body has auto-close keyword
        if: steps.duplicate_check.outputs.is_duplicate != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          CREATED_PR_NUMBER: ${{ steps.create_pr.outputs.pr_number }}
        run: |
          echo "Validating PR body contains auto-close keyword..."

          # Use PR number from create_pr step if available, otherwise find it
          if [ -n "$CREATED_PR_NUMBER" ] && [ "$CREATED_PR_NUMBER" != "" ]; then
            PR_NUMBER="$CREATED_PR_NUMBER"
            echo "Using PR #$PR_NUMBER from create_pr step"
          else
            PR_NUMBER=$(gh pr list --repo "$REPO" \
              --json number,headRefName \
              --jq "[.[] | select(.headRefName | test(\"^claude/issue-.*$ISSUE_NUMBER.*\"))][0].number")
          fi

          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ]; then
            echo "âš ï¸  No PR found to validate - skipping body check"
            exit 0
          fi

          echo "Checking PR #$PR_NUMBER body..."

          # Get current PR body
          PR_BODY=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json body --jq '.body')

          # Check if body contains the required auto-close keyword
          if echo "$PR_BODY" | grep -qE "Closes #$ISSUE_NUMBER([^0-9]|$)"; then
            echo "âœ… PR body contains 'Closes #$ISSUE_NUMBER' - auto-close will work"
          else
            echo "âš ï¸  PR #$PR_NUMBER is MISSING 'Closes #$ISSUE_NUMBER' in body"
            echo "   Auto-close will NOT work without this keyword"
            echo "   Attempting to fix by prepending the keyword..."

            # Prepend the auto-close keyword to the existing body
            # Use printf to avoid YAML parsing issues with multiline strings
            NEW_BODY=$(printf "Closes #%s\n\n%s" "$ISSUE_NUMBER" "$PR_BODY")

            # Update the PR body
            if gh pr edit "$PR_NUMBER" --repo "$REPO" --body "$NEW_BODY"; then
              echo "âœ… Successfully added 'Closes #$ISSUE_NUMBER' to PR body"
              echo "   Auto-close will now work when PR merges"

              # Post comment on issue explaining the fix
              gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
                --body "**Auto-Close Keyword Fix Applied**: PR #$PR_NUMBER was missing \`Closes #$ISSUE_NUMBER\` in its body. Added the keyword - issue will now auto-close when PR merges. *Automated fix*" || true
            else
              echo "âŒ Failed to update PR body - manual intervention may be needed"
              echo "   PR will merge but issue may not auto-close"
            fi
          fi
