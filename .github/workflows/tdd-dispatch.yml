name: TDD - Dispatch (Trigger Claude)

on:
  # Event-driven triggers (immediate response when work is available)
  workflow_run:
    workflows:
      - 'TDD - Scan (Find .fixme tests)' # New specs added to queue
      - 'TDD - Execute (Claude Code)' # Spec completed, pick next one
      - 'TDD - Monitor (Health & Recovery)' # Stuck specs re-queued
    types: [completed]
    branches: [main]

  # Scheduled backup (hourly safety net, reduced from every 15 min)
  schedule:
    - cron: '0 * * * *' # Every hour (Phase 3: event-driven architecture)

  # Manual trigger
  workflow_dispatch:

# Security: Define minimal required permissions
# NOTE: Requires GH_PAT_WORKFLOW secret with 'repo' AND 'workflows' scopes:
# - 'repo': Required to post @claude mentions and manage issues
# - 'workflows': Required for Claude Code to push branches (GitHub security restriction:
#                pushing to repos with .github/workflows/ files requires 'workflows' scope
#                even when the commit doesn't modify workflow files)
# Comments posted with PAT appear from token owner's account (not github-actions bot)
# This triggers Claude Code workflow via issue_comment event
permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

# Prevent concurrent processing (strict serial: one spec at a time)
# IMPORTANT: Shares concurrency group with tdd-refactor.yml
# This ensures queue processor waits when daily refactor is running
concurrency:
  group: tdd-queue
  cancel-in-progress: false

jobs:
  process-queue:
    name: üîÑ Process TDD Queue
    runs-on: ubuntu-latest
    timeout-minutes: 5 # Quick operation: fetch queue, update labels, post @claude comment
    # Only process queue if:
    # 1. Triggered by schedule or manual (always run)
    # 2. Triggered by workflow_run AND the workflow succeeded
    if: |
      github.event_name != 'workflow_run' ||
      github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Log trigger source
        run: |
          echo "üîç Queue Processor Triggered"
          echo "=========================="
          echo "Event: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "Triggered by: ${{ github.event.workflow_run.name }}"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Trigger type: Event-driven (Phase 3)"
          elif [ "${{ github.event_name }}" = "schedule" ]; then
            echo "Trigger type: Scheduled backup (hourly safety net)"
          else
            echo "Trigger type: Manual"
          fi
          echo ""

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for git operations

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Configure git with token user
        run: |
          USER_NAME=$(gh api user --jq '.login')
          USER_EMAIL=$(gh api user --jq '.email')
          git config user.name "$USER_NAME"
          git config user.email "$USER_EMAIL"
          echo "‚úÖ Git configured as $USER_NAME <$USER_EMAIL>"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Get next spec from queue
        id: next
        run: |
          echo "üîç Looking for next spec to process..."
          bun run scripts/tdd-automation/queue-manager.ts next
        env:
          GITHUB_OUTPUT: ${{ github.output }}
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Check if spec available
        id: check
        run: |
          if [ "${{ steps.next.outputs.has_next }}" != "true" ]; then
            echo "üì≠ No specs available to process"
            echo "should_process=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found spec to process: ${{ steps.next.outputs.spec_id }}"
            echo "should_process=true" >> $GITHUB_OUTPUT
          fi

      - name: Validate issue state and check for duplicates
        if: steps.check.outputs.should_process == 'true'
        id: validate
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"

          echo "üîç Validating issue #$ISSUE_NUMBER before processing..."

          # Check if issue is still open
          ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state')

          if [ "$ISSUE_STATE" = "CLOSED" ]; then
            echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER is already CLOSED"
            echo "   Skipping processing (likely already completed by another PR)"

            # Update the issue to remove in-progress label if present
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true

            echo "should_process=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for existing open PRs for this issue
          EXISTING_PRS=$(gh pr list \
            --label tdd-automation \
            --state open \
            --json number,body \
            --jq ".[] | select(.body | contains(\"Closes #$ISSUE_NUMBER\")) | .number")

          if [ -n "$EXISTING_PRS" ]; then
            echo "‚ö†Ô∏è  Found existing open PR(s) for issue #$ISSUE_NUMBER: $EXISTING_PRS"
            echo "   Skipping processing to avoid duplicate PRs"

            # CRITICAL: Change label to in-progress to prevent loop
            # Without this, the issue stays queued and gets picked up again every trigger
            echo "   Updating label to in-progress to prevent reprocessing..."
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:queued" || true
            gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:in-progress" || true

            # Check if we already posted a duplicate PR comment recently (within 1 hour)
            RECENT_COMMENT=$(gh api \
              "/repos/${{ github.repository }}/issues/${ISSUE_NUMBER}/comments" \
              --jq "[.[] | select(.body | contains(\"Duplicate PR Prevention\")) | select(.created_at > \"$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)\")] | length" 2>/dev/null || echo "0")

            if [ "$RECENT_COMMENT" -eq 0 ]; then
              gh issue comment "$ISSUE_NUMBER" --body "ü§ñ Duplicate PR Prevention - Skipping processing because an open PR already exists for this issue (#$EXISTING_PRS). The existing PR will be processed to completion. If the PR is stuck or invalid, please close it manually and the queue will retry this spec."
            else
              echo "   Skipping comment - already posted within last hour"
            fi

            echo "should_process=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Issue is open and no duplicate PRs found"
          echo "should_process=true" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Check if test is already passing in main (superseded)
        if: steps.check.outputs.should_process == 'true' && steps.validate.outputs.should_process == 'true'
        id: superseded
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "üîç Checking if test $SPEC_ID is already passing in main..."

          # Check if the test file exists
          if [ ! -f "$TEST_FILE" ]; then
            echo "‚ö†Ô∏è  Test file $TEST_FILE not found - spec may have been moved"
            echo "is_superseded=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if spec ID exists in the file
          if ! grep -q "$SPEC_ID" "$TEST_FILE"; then
            echo "‚ö†Ô∏è  Test $SPEC_ID not found in file - may have been removed or renamed"
            echo "is_superseded=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Use multiline grep to check if spec ID is associated with .fixme()
          # This handles the case where test.fixme( and spec ID are on different lines
          # Look for pattern: test.fixme( or it.fixme( followed by spec ID within 5 lines
          HAS_FIXME="false"

          # Method 1: Check if file has any .fixme() tests with this spec ID
          # Get line numbers where spec ID appears
          SPEC_LINE=$(grep -n "$SPEC_ID" "$TEST_FILE" | head -1 | cut -d: -f1)

          if [ -n "$SPEC_LINE" ]; then
            # Check the 3 lines before the spec ID for .fixme(
            START_LINE=$((SPEC_LINE - 3))
            if [ "$START_LINE" -lt 1 ]; then
              START_LINE=1
            fi

            # Extract the context and check for .fixme(
            CONTEXT=$(sed -n "${START_LINE},${SPEC_LINE}p" "$TEST_FILE")
            if echo "$CONTEXT" | grep -q "\.fixme("; then
              HAS_FIXME="true"
            fi
          fi

          if [ "$HAS_FIXME" = "true" ]; then
            echo "‚úÖ Test $SPEC_ID still has .fixme() - needs implementation"
            echo "is_superseded=false" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  Test $SPEC_ID no longer has .fixme() - already implemented!"
            echo "is_superseded=true" >> $GITHUB_OUTPUT
          fi

      - name: Close superseded issue
        if: steps.check.outputs.should_process == 'true' && steps.validate.outputs.should_process == 'true' && steps.superseded.outputs.is_superseded == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "üìã Closing superseded issue #$ISSUE_NUMBER..."

          # Retry logic for transient GitHub API errors (GraphQL errors, rate limits, etc.)
          MAX_RETRIES=3
          RETRY_DELAY=5

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "   Attempt $attempt/$MAX_RETRIES: Closing issue..."

            if gh issue close "$ISSUE_NUMBER" --reason completed \
              --comment "‚úÖ **Issue Closed: Test Already Implemented**

          The test \`$SPEC_ID\` no longer has \`.fixme()\` in main branch, meaning it has already been implemented (likely through another PR or manual fix).

          **Details**:
          - **Spec ID**: \`$SPEC_ID\`
          - **Test File**: \`$TEST_FILE\`
          - **Status**: Implementation complete - test is active

          No further action needed. The queue will continue with the next spec.

          ---
          *ü§ñ TDD Queue - Superseded Detection*"; then
              echo "   ‚úÖ Issue closed successfully"
              break
            else
              if [ "$attempt" -eq "$MAX_RETRIES" ]; then
                echo "   ‚ùå Failed to close issue after $MAX_RETRIES attempts"
                echo "   Will continue - issue may need manual closure"
              else
                echo "   ‚ö†Ô∏è  Failed, retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              fi
            fi
          done

          # Update labels (with retry)
          for attempt in $(seq 1 $MAX_RETRIES); do
            if gh issue edit "$ISSUE_NUMBER" \
              --remove-label "tdd-spec:queued" \
              --add-label "tdd-spec:completed" 2>/dev/null; then
              break
            else
              if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                sleep 2
              fi
            fi
          done

          echo "‚úÖ Issue #$ISSUE_NUMBER processed as superseded"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Mark spec as in-progress and trigger Claude Code workflow
        if: steps.check.outputs.should_process == 'true' && steps.validate.outputs.should_process == 'true' && steps.superseded.outputs.is_superseded != 'true'
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "üèÉ Marking issue #$ISSUE_NUMBER as in-progress..."

          # RACE CONDITION PREVENTION: Re-verify issue is still queued before claiming
          # Another workflow run could have claimed this issue between validation and now
          CURRENT_LABELS=$(gh issue view "$ISSUE_NUMBER" --json labels --jq '.labels[].name' | tr '\n' ' ')

          if echo "$CURRENT_LABELS" | grep -q "tdd-spec:in-progress"; then
            echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER already claimed by another run - exiting gracefully"
            echo "   Current labels: $CURRENT_LABELS"
            exit 0
          fi

          if ! echo "$CURRENT_LABELS" | grep -q "tdd-spec:queued"; then
            echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER no longer queued - exiting gracefully"
            echo "   Current labels: $CURRENT_LABELS"
            exit 0
          fi

          # Update labels (atomic claim)
          gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:queued"
          gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:in-progress"

          # NOTE: We only post @claude comment (not workflow_dispatch) to avoid double trigger
          # The @claude comment triggers tdd-execute.yml via issue_comment event
          echo "ü§ñ Posting @claude comment to trigger Claude Code workflow..."

          # Add comment with workflow instructions (triggers tdd-execute.yml)
          gh issue comment "$ISSUE_NUMBER" --body "@claude implement this spec using the TDD automation workflow.

          ## üìã Spec Details

          - **Test File**: \`$TEST_FILE\`
          - **Spec ID**: \`$SPEC_ID\`
          - **Issue**: #$ISSUE_NUMBER

          ## ü§ñ Automation Mode

          **You are in pipeline/automation mode**:
          - ‚úÖ Make autonomous decisions following Sovrium patterns
          - ‚úÖ Implement minimal code to pass the test
          - ‚ùå DO NOT ask questions - proceed with best judgment
          - ‚ùå DO NOT skip any steps - all are MANDATORY

          ## ‚úÖ Critical Steps (ALL REQUIRED)

          1. **Run e2e-test-fixer agent** - Use \`Task\` tool with \`subagent_type='e2e-test-fixer'\` to remove \`.fixme()\` from \`$SPEC_ID\` and implement minimal code to pass the test
          2. **Run codebase-refactor-auditor agent** - Use \`Task\` tool with \`subagent_type='codebase-refactor-auditor'\`:
             - **If src/ files changed**: Full audit (layer architecture, code quality, refactoring) + \`bun run quality\`
             - **If NO src/ files changed** (test-only): Quick Exit - runs \`bun run quality\` only, skips full audit
             - Agent auto-detects and handles appropriately - ensures quality passes before proceeding
          3. **Commit changes** - Run \`bun run license\`, then commit as \`fix: implement $SPEC_ID\`, push to branch
          4. **‚ö†Ô∏è CREATE PR** (EXACT FORMAT REQUIRED - DO NOT MODIFY):
             \`\`\`bash
             gh pr create --title \"fix: implement $SPEC_ID\" --body \"Closes #$ISSUE_NUMBER\" --label \"tdd-automation\"
             \`\`\`
             **CRITICAL**: The PR body MUST be EXACTLY \`Closes #$ISSUE_NUMBER\` - nothing else!
             - ‚ùå DO NOT write a summary or description in the PR body
             - ‚ùå DO NOT add implementation details (put those in commit message)
             - ‚ùå DO NOT add extra text after the issue number
             - ‚úÖ The ONLY content should be: \`Closes #$ISSUE_NUMBER\`
             - **WHY**: GitHub's auto-close feature is format-sensitive and fails with extra text
          5. **‚ö†Ô∏è ENABLE AUTO-MERGE** - \`gh pr merge \$PR_NUMBER --auto --squash\`
          6. **‚ö†Ô∏è VERIFY AUTO-MERGE** - Run \`gh pr view \$PR_NUMBER --json autoMergeRequest\` and confirm autoMergeRequest is NOT null

          ## ‚ö†Ô∏è Error Handling

          - **If \`bun run quality\` fails**:
            1. Read the FULL error output carefully
            2. Fix ALL failing checks (ESLint, TypeScript, Effect diagnostics, unit tests, E2E)
            3. Re-run \`bun run quality\` until it passes completely
            4. Only THEN proceed to commit and PR creation
          - **If layer architecture violations**: Fix cross-layer imports before proceeding - domain must be pure
          - **If PR creation fails**: Retry once, then report error in issue comment
          - **If auto-merge fails**: Comment the failure reason on the PR and retry

          ## üö® MOST COMMON FAILURES (Learn from history)

          - Missing PR creation (issue #1319) ‚Üí spec marked failed after 2 minutes
          - Missing auto-merge (PRs #1541, #1546) ‚Üí pipeline blocked for hours
          - Auto-merge not verified ‚Üí may silently fail, always check with \`gh pr view\`
          - Skipping codebase-refactor-auditor ‚Üí technical debt accumulates
          - **Creating PR with failing regression tests** (PR #4846) ‚Üí CI fails, PR blocked - ALWAYS run \`bun run quality\` and fix ALL failures before PR

          **Complete workflow documentation**: \`@docs/development/tdd-automation-pipeline.md\`

          ---
          *ü§ñ Automated via [Queue Processor](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

          echo "‚úÖ Issue updated and @claude mentioned - Claude Code will trigger automatically"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
