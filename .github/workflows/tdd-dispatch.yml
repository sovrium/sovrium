name: TDD - Dispatch (Trigger Claude)
# Trigger: Picks next spec from queue and invokes Claude Code

on:
  # Event-driven triggers (immediate response when work is available)
  # NOTE: workflow_run does NOT support self-triggers (GitHub security feature).
  # Self-continuation (after pre-validation/superseded) is done via workflow_dispatch API.
  workflow_run:
    workflows:
      - 'TDD - Scan (Find .fixme tests)' # New specs added to queue
      - 'TDD - Execute (Claude Code)' # Spec completed, pick next one
      - 'TDD - Monitor (Health & Recovery)' # Stuck specs re-queued
    types: [completed]
    branches: [main]

  # Scheduled backup (hourly safety net, reduced from every 15 min)
  schedule:
    - cron: '0 * * * *' # Every hour (Phase 3: event-driven architecture)

  # Manual trigger
  workflow_dispatch:

# Security: Define minimal required permissions
# NOTE: Requires GH_PAT_WORKFLOW secret with 'repo' AND 'workflows' scopes:
# - 'repo': Required to post @claude mentions and manage issues
# - 'workflows': Required for Claude Code to push branches (GitHub security restriction:
#                pushing to repos with .github/workflows/ files requires 'workflows' scope
#                even when the commit doesn't modify workflow files)
# Comments posted with PAT appear from token owner's account (not github-actions bot)
# This triggers Claude Code workflow via issue_comment event
permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

# Prevent concurrent processing (strict serial: one spec at a time)
# IMPORTANT: Shares concurrency group with tdd-refactor.yml
# This ensures queue processor waits when daily refactor is running
concurrency:
  group: tdd-queue
  cancel-in-progress: false

jobs:
  process-queue:
    name: Process TDD Queue
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Includes pre-validation step which runs tests
    # Only process queue if:
    # 1. Triggered by schedule or manual (always run)
    # 2. Triggered by workflow_run AND the workflow succeeded
    if: |
      github.event_name != 'workflow_run' ||
      github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Log trigger source
        run: |
          echo "Queue Processor Triggered"
          echo "========================="
          echo "Event: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "Triggered by: ${{ github.event.workflow_run.name }}"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Trigger type: Event-driven (Phase 3)"
          elif [ "${{ github.event_name }}" = "schedule" ]; then
            echo "Trigger type: Scheduled backup (hourly safety net)"
          else
            echo "Trigger type: Manual"
          fi
          echo ""

      # =========================================================================
      # Checkout with retry (GitHub API rate limit resilience)
      # =========================================================================
      - name: Checkout repository with retry
        id: checkout
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          MAX_ATTEMPTS=3
          RETRY_DELAY=30

          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo "Checkout attempt $attempt/$MAX_ATTEMPTS..."

            # Need full history for git operations (fetch-depth: 0)
            if git clone "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git" . 2>&1; then
              echo "✅ Checkout successful on attempt $attempt"
              exit 0
            else
              echo "❌ Checkout failed on attempt $attempt"

              if [ $attempt -lt $MAX_ATTEMPTS ]; then
                echo "   Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              else
                echo "❌ All checkout attempts failed"
                exit 1
              fi
            fi
          done

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      # =========================================================================
      # Usage tracking with BLOCKING behavior (fail-closed)
      # =========================================================================
      # Uses cost-based limits from historical GitHub Actions logs.
      # Blocks queue processing when:
      # - Daily cost exceeds $200.00 (20% of weekly)
      # - Weekly cost exceeds $1000.00 (weekly allocation)
      # - Usage data unavailable (fail-closed)
      # =========================================================================
      - name: Check usage limits (fail-closed)
        id: usage
        run: |
          echo "Checking usage limits before processing..."
          # Run usage check and capture exit code
          set +e
          bun run scripts/tdd-automation/check-claude-code-usage.ts --check
          EXIT_CODE=$?
          set -e

          # Mark that script completed (even if limits exceeded)
          echo "script_completed=true" >> $GITHUB_OUTPUT

          # Exit with the script's exit code
          exit $EXIT_CODE
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TDD_DAILY_COST_LIMIT: '200.00'
          TDD_WEEKLY_COST_LIMIT: '1000.00'
        continue-on-error: true

      - name: Fail if usage check crashed (fail-closed safety)
        if: steps.usage.outcome == 'failure' && steps.usage.outputs.script_completed != 'true'
        run: |
          echo "CRITICAL: Usage check script crashed before completion!"
          echo ""
          echo "This is a fail-closed safety mechanism. The workflow cannot proceed"
          echo "because we cannot verify that usage is within limits."
          echo ""
          echo "Possible causes:"
          echo "  - Network timeout fetching workflow logs"
          echo "  - GitHub API authentication failure"
          echo "  - Script parsing error"
          echo ""
          echo "Action required: Investigate the usage check step logs above."
          exit 1

      - name: Skip if usage limits exceeded
        if: steps.usage.outcome == 'failure' && steps.usage.outputs.script_completed == 'true'
        run: |
          echo "Usage limits exceeded - graceful skip"
          echo "   Reason: ${{ steps.usage.outputs.reason || 'limits_exceeded' }}"
          echo "   Daily cost: ${{ steps.usage.outputs.daily_cost || 'unknown' }}"
          echo "   Weekly cost: ${{ steps.usage.outputs.weekly_cost || 'unknown' }}"
          echo ""
          echo "Skipping queue processing until usage is reduced."
          echo "Run 'bun run scripts/tdd-automation/check-claude-code-usage.ts' for details."
          exit 0

      # =========================================================================
      # Check if queue is paused (credit exhaustion)
      # When Claude Code runs out of credits, tdd-execute.yml pauses the queue
      # by creating/updating an issue with 'tdd-queue:paused' label.
      # =========================================================================
      - name: Check if queue is paused (credit exhaustion)
        id: queue_status
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          echo "Checking if TDD queue is paused..."

          # Retry wrapper for gh commands (GitHub API rate limit resilience)
          gh_retry() {
            local max_attempts=3
            local delay=10
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if output=$("$@" 2>&1); then
                echo "$output"
                return 0
              else
                echo "⚠️  gh command failed (attempt $attempt/$max_attempts): $output" >&2
                if [ $attempt -lt $max_attempts ]; then
                  echo "   Retrying in ${delay}s..." >&2
                  sleep $delay
                  delay=$((delay * 2))
                fi
                attempt=$((attempt + 1))
              fi
            done
            echo "{}"  # Return empty JSON on failure
            return 1
          }

          # Check for queue pause label (with retry)
          PAUSE_ISSUE=$(gh_retry gh issue list \
            --repo "$REPO" \
            --label "tdd-queue-status,tdd-queue:paused" \
            --state open \
            --json number,title,updatedAt \
            --jq '.[0]')

          PAUSE_NUMBER=$(echo "$PAUSE_ISSUE" | jq -r '.number // empty')

          if [ -n "$PAUSE_NUMBER" ]; then
            PAUSE_TITLE=$(echo "$PAUSE_ISSUE" | jq -r '.title // "Unknown"')
            PAUSE_TIME=$(echo "$PAUSE_ISSUE" | jq -r '.updatedAt // "Unknown"')

            echo ""
            echo "╔══════════════════════════════════════════════════════════════════════╗"
            echo "║  ⏸️  TDD QUEUE IS PAUSED                                               ║"
            echo "╠══════════════════════════════════════════════════════════════════════╣"
            echo "║  Status Issue: #$PAUSE_NUMBER"
            echo "║  Title: $PAUSE_TITLE"
            echo "║  Paused Since: $PAUSE_TIME"
            echo "║                                                                      ║"
            echo "║  Queue will not process new specs until resumed.                    ║"
            echo "║  Auto-resume: ~2 hours via tdd-monitor.yml                          ║"
            echo "║                                                                      ║"
            echo "║  Manual Resume:                                                      ║"
            echo "║    gh issue edit $PAUSE_NUMBER --remove-label 'tdd-queue:paused'    ║"
            echo "╚══════════════════════════════════════════════════════════════════════╝"
            echo ""
            echo "paused=true" >> $GITHUB_OUTPUT
            echo "pause_issue=$PAUSE_NUMBER" >> $GITHUB_OUTPUT
          else
            echo "✅ Queue is active (not paused)"
            echo "paused=false" >> $GITHUB_OUTPUT
          fi

      - name: Skip if queue is paused
        if: steps.queue_status.outputs.paused == 'true'
        run: |
          echo "Queue is paused due to credit/rate limit exhaustion."
          echo "Skipping spec processing until queue is resumed."
          echo ""
          echo "The queue will auto-resume in ~2 hours or can be manually resumed:"
          echo "  gh issue edit ${{ steps.queue_status.outputs.pause_issue }} --remove-label 'tdd-queue:paused'"
          exit 0

      - name: Configure git with token user
        run: |
          USER_NAME=$(gh api user --jq '.login')
          USER_EMAIL=$(gh api user --jq '.email')
          git config user.name "$USER_NAME"
          git config user.email "$USER_EMAIL"
          echo "✅ Git configured as $USER_NAME <$USER_EMAIL>"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Get next spec from queue
        id: next
        run: |
          echo "Looking for next spec to process..."
          bun run scripts/tdd-automation/queue-manager.ts next
        env:
          GITHUB_OUTPUT: ${{ github.output }}
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Check if spec available
        id: check
        run: |
          if [ "${{ steps.next.outputs.has_next }}" != "true" ]; then
            echo "No specs available to process"
            echo "should_process=false" >> $GITHUB_OUTPUT
          else
            echo "✅ Found spec to process: ${{ steps.next.outputs.spec_id }}"
            echo "should_process=true" >> $GITHUB_OUTPUT
          fi

      - name: Validate issue state and check for duplicates
        if: steps.check.outputs.should_process == 'true'
        id: validate
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"

          echo "Validating issue #$ISSUE_NUMBER before processing..."

          # Retry wrapper for gh commands (GitHub API rate limit resilience)
          gh_retry() {
            local max_attempts=3
            local delay=10
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if output=$("$@" 2>&1); then
                echo "$output"
                return 0
              else
                echo "⚠️  gh command failed (attempt $attempt/$max_attempts): $output" >&2
                if [ $attempt -lt $max_attempts ]; then
                  echo "   Retrying in ${delay}s..." >&2
                  sleep $delay
                  delay=$((delay * 2))
                fi
                attempt=$((attempt + 1))
              fi
            done
            return 1
          }

          # Check if issue is still open (with retry)
          ISSUE_STATE=$(gh_retry gh issue view "$ISSUE_NUMBER" --json state --jq '.state')

          if [ "$ISSUE_STATE" = "CLOSED" ]; then
            echo "⚠️  Issue #$ISSUE_NUMBER is already CLOSED"
            echo "   Skipping processing (likely already completed by another PR)"

            # Update the issue to remove in-progress label if present
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true

            echo "should_process=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for existing open PRs for this issue (with retry)
          EXISTING_PRS=$(gh_retry gh pr list \
            --label tdd-automation \
            --state open \
            --json number,body \
            --jq ".[] | select(.body | contains(\"Closes #$ISSUE_NUMBER\")) | .number")

          if [ -n "$EXISTING_PRS" ]; then
            echo "⚠️  Found existing open PR(s) for issue #$ISSUE_NUMBER: $EXISTING_PRS"
            echo "   Skipping processing to avoid duplicate PRs"

            # CRITICAL: Change label to in-progress to prevent loop
            # Without this, the issue stays queued and gets picked up again every trigger
            echo "   Updating label to in-progress to prevent reprocessing..."
            gh_retry gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:queued" --add-label "tdd-spec:in-progress" || true

            # Check if we already posted a duplicate PR comment recently (within 1 hour)
            RECENT_COMMENT=$(gh api \
              "/repos/${{ github.repository }}/issues/${ISSUE_NUMBER}/comments" \
              --jq "[.[] | select(.body | contains(\"Duplicate PR Prevention\")) | select(.created_at > \"$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)\")] | length" 2>/dev/null || echo "0")

            if [ "$RECENT_COMMENT" -eq 0 ]; then
              gh issue comment "$ISSUE_NUMBER" --body "Duplicate PR Prevention - Skipping processing because an open PR already exists for this issue (#$EXISTING_PRS). The existing PR will be processed to completion. If the PR is stuck or invalid, please close it manually and the queue will retry this spec."
            else
              echo "   Skipping comment - already posted within last hour"
            fi

            echo "should_process=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "✅ Issue is open and no duplicate PRs found"
          echo "should_process=true" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Check if test is already passing in main (superseded)
        if: steps.check.outputs.should_process == 'true' && steps.validate.outputs.should_process == 'true'
        id: superseded
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "Checking if test $SPEC_ID is already passing in main..."

          # Check if the test file exists at the expected path
          if [ ! -f "$TEST_FILE" ]; then
            echo "⚠️  Test file $TEST_FILE not found at expected path"
            echo "   Searching for spec $SPEC_ID in codebase..."

            # Search for the spec ID in all spec files
            ACTUAL_FILE=$(grep -rl "$SPEC_ID" specs/ 2>/dev/null | head -1)

            if [ -n "$ACTUAL_FILE" ]; then
              echo "Found spec at: $ACTUAL_FILE (path in issue was stale)"
              TEST_FILE="$ACTUAL_FILE"
              # Continue with the corrected path
            else
              echo "❌ Spec $SPEC_ID not found anywhere in specs/ - treating as superseded"
              echo "is_superseded=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # Check if spec ID exists in the file
          if ! grep -q "$SPEC_ID" "$TEST_FILE"; then
            echo "⚠️  Test $SPEC_ID not found in $TEST_FILE"
            echo "   Searching for spec in other files..."

            # Search for the spec ID in all spec files
            ACTUAL_FILE=$(grep -rl "$SPEC_ID" specs/ 2>/dev/null | head -1)

            if [ -n "$ACTUAL_FILE" ] && [ "$ACTUAL_FILE" != "$TEST_FILE" ]; then
              echo "Found spec at: $ACTUAL_FILE"
              TEST_FILE="$ACTUAL_FILE"
              # Continue with the corrected path
            else
              echo "❌ Spec $SPEC_ID not found in codebase - treating as superseded"
              echo "is_superseded=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # Use multiline grep to check if spec ID is associated with .fixme()
          # This handles the case where test.fixme( and spec ID are on different lines
          # Look for pattern: test.fixme( or it.fixme( followed by spec ID within 5 lines
          HAS_FIXME="false"

          # Method 1: Check if file has any .fixme() tests with this spec ID
          # Get line numbers where spec ID appears
          SPEC_LINE=$(grep -n "$SPEC_ID" "$TEST_FILE" | head -1 | cut -d: -f1)

          if [ -n "$SPEC_LINE" ]; then
            # Check the 3 lines before the spec ID for .fixme(
            START_LINE=$((SPEC_LINE - 3))
            if [ "$START_LINE" -lt 1 ]; then
              START_LINE=1
            fi

            # Extract the context and check for .fixme(
            CONTEXT=$(sed -n "${START_LINE},${SPEC_LINE}p" "$TEST_FILE")
            if echo "$CONTEXT" | grep -q "\.fixme("; then
              HAS_FIXME="true"
            fi
          fi

          if [ "$HAS_FIXME" = "true" ]; then
            echo "✅ Test $SPEC_ID still has .fixme() - needs implementation"
            echo "is_superseded=false" >> $GITHUB_OUTPUT
          else
            echo "⚠️  Test $SPEC_ID no longer has .fixme() - already implemented!"
            echo "is_superseded=true" >> $GITHUB_OUTPUT
          fi

      - name: Close superseded issue
        if: steps.check.outputs.should_process == 'true' && steps.validate.outputs.should_process == 'true' && steps.superseded.outputs.is_superseded == 'true'
        id: close_superseded
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "Closing superseded issue #$ISSUE_NUMBER..."

          # Retry logic for transient GitHub API errors (GraphQL errors, rate limits, etc.)
          MAX_RETRIES=3
          RETRY_DELAY=5

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "   Attempt $attempt/$MAX_RETRIES: Closing issue..."

            if gh issue close "$ISSUE_NUMBER" --reason completed \
              --comment "✅ **Issue Closed: Test Already Implemented**

          The test \`$SPEC_ID\` no longer has \`.fixme()\` in main branch, meaning it has already been implemented (likely through another PR or manual fix).

          **Details**:
          - **Spec ID**: \`$SPEC_ID\`
          - **Test File**: \`$TEST_FILE\`
          - **Status**: Implementation complete - test is active

          No further action needed. The queue will continue with the next spec.

          ---
          *TDD Queue - Superseded Detection*"; then
              echo "   ✅ Issue closed successfully"
              break
            else
              if [ "$attempt" -eq "$MAX_RETRIES" ]; then
                echo "   ❌ Failed to close issue after $MAX_RETRIES attempts"
                echo "   Will continue - issue may need manual closure"
              else
                echo "   ⚠️  Failed, retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              fi
            fi
          done

          # Update labels (with retry)
          for attempt in $(seq 1 $MAX_RETRIES); do
            if gh issue edit "$ISSUE_NUMBER" \
              --remove-label "tdd-spec:queued" \
              --add-label "tdd-spec:completed" 2>/dev/null; then
              break
            else
              if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                sleep 2
              fi
            fi
          done

          echo "✅ Issue #$ISSUE_NUMBER processed as superseded"
          echo "should_trigger_next=true" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Trigger next queue run (after superseded issue closed)
        if: steps.close_superseded.outputs.should_trigger_next == 'true'
        run: |
          echo "Superseded issue closed - triggering next queue run..."
          echo ""
          echo "Note: GitHub Actions does not support workflow_run self-triggers."
          echo "Using workflow_dispatch API to continue queue processing."
          echo ""

          # Small delay to ensure GitHub has processed the issue closure
          sleep 3

          # Trigger the next queue run
          gh workflow run "TDD - Dispatch (Trigger Claude)" \
            --ref main

          echo "✅ Next queue run triggered via workflow_dispatch"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      # =========================================================================
      # PHASE 1: Pre-validation with validate-specs.ts
      # =========================================================================
      # Before invoking Claude, check if the test already passes.
      # If yes → commit, push, close issue → skip Claude (saves time and cost)
      # If no → continue to Claude invocation (current behavior)
      # =========================================================================

      - name: Pre-validate spec (check if test passes without Claude)
        if: steps.check.outputs.should_process == 'true' && steps.validate.outputs.should_process == 'true' && steps.superseded.outputs.is_superseded != 'true'
        id: prevalidate
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "Pre-validating $SPEC_ID..."
          echo "   This checks if the test passes without any code changes."
          echo "   If it passes, the feature is already implemented → skip Claude."
          echo ""

          # Run validate-specs.ts with JSON output for parsing
          # This will: remove .fixme(), run test, commit if passes, close issue
          RESULT=$(bun run scripts/validate-specs.ts --json "$SPEC_ID" 2>&1) || true
          EXIT_CODE=$?

          echo "Exit code: $EXIT_CODE"
          echo "Raw output:"
          echo "$RESULT"

          # Parse JSON result
          # NOTE: Use extended regex (-E) to handle optional whitespace after colons
          # The validate-specs.ts script outputs formatted JSON with spaces (e.g., "status": "passed")
          # Previous regex only matched "status":"passed" (no space), causing silent parsing failures
          STATUS=$(echo "$RESULT" | grep -oE '"status"\s*:\s*"[^"]*"' | head -1 | sed 's/"status"[[:space:]]*:[[:space:]]*"//' | tr -d '"')
          HAS_SRC_CHANGES=$(echo "$RESULT" | grep -oE '"hasSrcChanges"\s*:\s*(true|false)' | head -1 | sed 's/"hasSrcChanges"[[:space:]]*:[[:space:]]*//')
          COMMITTED=$(echo "$RESULT" | grep -oE '"committed"\s*:\s*(true|false)' | head -1 | sed 's/"committed"[[:space:]]*:[[:space:]]*//')
          ISSUE_CLOSED=$(echo "$RESULT" | grep -oE '"issueClosed"\s*:\s*(true|false)' | head -1 | sed 's/"issueClosed"[[:space:]]*:[[:space:]]*//')

          # Apply defaults if parsing failed
          STATUS="${STATUS:-unknown}"
          HAS_SRC_CHANGES="${HAS_SRC_CHANGES:-false}"
          COMMITTED="${COMMITTED:-false}"
          ISSUE_CLOSED="${ISSUE_CLOSED:-false}"

          echo ""
          echo "Parsed results:"
          echo "  Status: $STATUS"
          echo "  Has src changes: $HAS_SRC_CHANGES"
          echo "  Committed: $COMMITTED"
          echo "  Issue closed: $ISSUE_CLOSED"

          # Validate parsing succeeded - STATUS should be "passed", "failed", or similar
          if [ "$STATUS" = "unknown" ] || [ -z "$STATUS" ]; then
            echo ""
            echo "⚠️  Warning: Failed to parse validation result (status='$STATUS')"
            echo "   This may indicate a JSON parsing issue or script error."
            echo "   Proceeding with Claude invocation as fallback."

            echo "test_passed=false" >> $GITHUB_OUTPUT
            echo "needs_claude=true" >> $GITHUB_OUTPUT
            echo "should_trigger_next=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$STATUS" = "passed" ]; then
            echo ""
            echo "✅ Test passed! Feature already implemented."
            echo "   validate-specs.ts has committed the change locally."
            echo "   Skipping Claude invocation."

            # Push the commit to main
            echo ""
            echo "Pushing commit to main..."
            if git push origin main; then
              echo "✅ Push successful"

              # Clean up any orphaned Claude branches for this issue
              echo ""
              echo "Cleaning up orphaned claude branches..."
              ORPHAN_BRANCHES=$(git ls-remote --heads origin "claude/issue-${ISSUE_NUMBER}-*" 2>/dev/null | awk '{print $2}' | sed 's|refs/heads/||' || true)
              if [ -n "$ORPHAN_BRANCHES" ]; then
                echo "Found orphaned branches:"
                echo "$ORPHAN_BRANCHES" | while read branch; do
                  echo "  Deleting: $branch"
                  git push origin --delete "$branch" 2>/dev/null || true
                done
                echo "✅ Orphaned branches cleaned up"
              else
                echo "No orphaned branches found"
              fi

              # Close issue AFTER successful push (atomic: close only when code is in main)
              echo ""
              echo "Closing issue #$ISSUE_NUMBER..."

              # Remove old state labels
              gh issue edit "$ISSUE_NUMBER" \
                --remove-label "tdd-spec:queued" \
                --remove-label "tdd-spec:in-progress" \
                --remove-label "tdd-spec:failed" 2>/dev/null || true

              # Add completed label
              gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed" 2>/dev/null || true

              # Add closure comment
              gh issue comment "$ISSUE_NUMBER" --body "✅ **Spec Completed via Pre-Validation**

          Test \\\`$SPEC_ID\\\` passed without code changes - feature was already implemented.

          - **Pre-validation**: Removed \\\`.fixme()\\\`, test passed
          - **Commit**: Created and pushed to main
          - **Status**: Complete

          *TDD Queue - Pre-Validation*" || true

              # Close issue
              gh issue close "$ISSUE_NUMBER" --reason completed || true

              echo "✅ Issue #$ISSUE_NUMBER closed"
              echo "test_passed=true" >> $GITHUB_OUTPUT
              echo "needs_claude=false" >> $GITHUB_OUTPUT
              echo "should_trigger_next=true" >> $GITHUB_OUTPUT
            else
              echo ""
              echo "❌ Push to main failed! Re-queuing issue for retry..."

              # Re-queue issue (issue was NOT closed since we're in CI mode)
              gh issue edit "$ISSUE_NUMBER" \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:queued" 2>/dev/null || true

              gh issue comment "$ISSUE_NUMBER" --body "**Push Failed** - Pre-validation passed but push to main failed. Test \\\`$SPEC_ID\\\` passed after removing \\\`.fixme()\\\`, commit created locally, but push failed (network issue, branch protection, etc.). Issue re-queued for retry. *TDD Queue*"

              echo "test_passed=false" >> $GITHUB_OUTPUT
              echo "needs_claude=false" >> $GITHUB_OUTPUT
              echo "should_trigger_next=false" >> $GITHUB_OUTPUT
            fi
          else
            echo ""
            echo "❌ Test failed (status: $STATUS)"
            echo "   This is expected - the feature needs implementation."
            echo "   Proceeding to Claude invocation."

            echo "test_passed=false" >> $GITHUB_OUTPUT
            echo "needs_claude=true" >> $GITHUB_OUTPUT
            echo "should_trigger_next=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      # =========================================================================
      # SELF-TRIGGER: Queue continuation after pre-validation success
      # =========================================================================
      # GitHub Actions does NOT allow workflow_run to trigger the same workflow.
      # When pre-validation passes, we must explicitly trigger the next queue run
      # via workflow_dispatch API to continue processing the queue.
      # =========================================================================

      - name: Trigger next queue run (after pre-validation success)
        if: steps.prevalidate.outputs.should_trigger_next == 'true'
        run: |
          echo "Pre-validation succeeded - triggering next queue run..."
          echo ""
          echo "Note: GitHub Actions does not support workflow_run self-triggers."
          echo "Using workflow_dispatch API to continue queue processing."
          echo ""

          # Small delay to ensure GitHub has processed the issue closure
          sleep 3

          # Trigger the next queue run
          gh workflow run "TDD - Dispatch (Trigger Claude)" \
            --ref main

          echo "✅ Next queue run triggered via workflow_dispatch"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Mark spec as in-progress and trigger Claude Code workflow
        if: |
          steps.check.outputs.should_process == 'true' &&
          steps.validate.outputs.should_process == 'true' &&
          steps.superseded.outputs.is_superseded != 'true' &&
          steps.prevalidate.outputs.needs_claude == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "Marking issue #$ISSUE_NUMBER as in-progress..."

          # Retry wrapper for gh commands (GitHub API rate limit resilience)
          gh_retry() {
            local max_attempts=3
            local delay=10
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if output=$("$@" 2>&1); then
                echo "$output"
                return 0
              else
                echo "⚠️  gh command failed (attempt $attempt/$max_attempts): $output" >&2
                if [ $attempt -lt $max_attempts ]; then
                  echo "   Retrying in ${delay}s..." >&2
                  sleep $delay
                  delay=$((delay * 2))
                fi
                attempt=$((attempt + 1))
              fi
            done
            return 1
          }

          # RACE CONDITION PREVENTION: Re-verify issue is still queued before claiming
          # Another workflow run could have claimed this issue between validation and now
          CURRENT_LABELS=$(gh_retry gh issue view "$ISSUE_NUMBER" --json labels --jq '.labels[].name' | tr '\n' ' ')

          if echo "$CURRENT_LABELS" | grep -q "tdd-spec:in-progress"; then
            echo "⚠️  Issue #$ISSUE_NUMBER already claimed by another run - exiting gracefully"
            echo "   Current labels: $CURRENT_LABELS"
            exit 0
          fi

          if ! echo "$CURRENT_LABELS" | grep -q "tdd-spec:queued"; then
            echo "⚠️  Issue #$ISSUE_NUMBER no longer queued - exiting gracefully"
            echo "   Current labels: $CURRENT_LABELS"
            exit 0
          fi

          # Update labels (atomic claim - single command to prevent inconsistent state)
          gh_retry gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:queued" --add-label "tdd-spec:in-progress"

          # NOTE: We only post @claude comment (not workflow_dispatch) to avoid double trigger
          # The @claude comment triggers tdd-execute.yml via issue_comment event
          echo "Posting @claude comment to trigger Claude Code workflow..."

          # Add comment with workflow instructions (triggers tdd-execute.yml)
          # NOTE: Claude runs e2e-test-fixer agent ONLY. The workflow handles:
          # - bun run license (finalize-fixer job)
          # - Commit and push (finalize-fixer job)
          # - codebase-refactor-auditor (execute-refactor-auditor job, conditional on src/ changes)
          gh issue comment "$ISSUE_NUMBER" --body "@claude implement this spec using the TDD automation workflow.

          ## Spec Details

          - **Test File**: \`$TEST_FILE\`
          - **Spec ID**: \`$SPEC_ID\`
          - **Issue**: #$ISSUE_NUMBER

          ## Automation Mode

          **You are in pipeline/automation mode**:
          - ✅ Make autonomous decisions following Sovrium patterns
          - ✅ Implement minimal code to pass the test
          - ❌ DO NOT ask questions - proceed with best judgment
          - ❌ DO NOT skip any steps - all are MANDATORY

          ## Your Task (e2e-test-fixer agent ONLY)

          Run the e2e-test-fixer agent using \`Task\` tool with \`subagent_type='e2e-test-fixer'\`:
          1. Remove \`.fixme()\` from \`$SPEC_ID\`
          2. Implement minimal code to pass the test
          3. Commit changes as \`fix: implement $SPEC_ID\`
          4. Push to branch \`claude/issue-$ISSUE_NUMBER-*\`

          ## What You Should NOT Do

          - ❌ DO NOT run codebase-refactor-auditor (separate workflow job handles this)
          - ❌ DO NOT run \`bun run license\` (finalization job handles this)
          - ❌ DO NOT create PR (workflow handles this)

          ## Error Handling

          - **If tests fail**: Fix implementation until tests pass
          - **If layer architecture violations**: Fix cross-layer imports - domain must be pure
          - **Focus on making the test GREEN**, other quality checks run in finalization

          **Complete workflow documentation**: \`@docs/development/tdd-automation-pipeline.md\`

          ---
          *Automated via [Queue Processor](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

          echo "✅ Issue updated and @claude mentioned - Claude Code will trigger automatically"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
