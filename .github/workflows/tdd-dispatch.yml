name: TDD - Dispatch (Trigger Claude)
# Trigger: Picks next spec from queue and invokes Claude Code

on:
  # Event-driven triggers (immediate response when work is available)
  # NOTE: workflow_run does NOT support self-triggers (GitHub security feature).
  # Self-continuation (after pre-validation/superseded) is done via workflow_dispatch API.
  workflow_run:
    workflows:
      - 'TDD - Scan (Find .fixme tests)' # New specs added to queue
      - 'TDD - Execute (Claude Code)' # Spec completed, pick next one
      - 'TDD - Monitor (Health & Recovery)' # Stuck specs re-queued
    types: [completed]
    branches: [main]

  # Scheduled backup (hourly safety net, reduced from every 15 min)
  schedule:
    - cron: '0 * * * *' # Every hour (Phase 3: event-driven architecture)

  # Manual trigger
  workflow_dispatch:

# Security: Define minimal required permissions
# NOTE: Requires GH_PAT_WORKFLOW secret with 'repo' AND 'workflows' scopes:
# - 'repo': Required to post @claude mentions and manage issues
# - 'workflows': Required for Claude Code to push branches (GitHub security restriction:
#                pushing to repos with .github/workflows/ files requires 'workflows' scope
#                even when the commit doesn't modify workflow files)
# Comments posted with PAT appear from token owner's account (not github-actions bot)
# This triggers Claude Code workflow via issue_comment event
permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

# Prevent concurrent processing (strict serial: one spec at a time)
# IMPORTANT: Shares concurrency group with tdd-refactor.yml
# This ensures queue processor waits when daily refactor is running
concurrency:
  group: tdd-queue
  cancel-in-progress: false

jobs:
  process-queue:
    name: üîÑ Process TDD Queue
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Includes pre-validation step which runs tests
    # Only process queue if:
    # 1. Triggered by schedule or manual (always run)
    # 2. Triggered by workflow_run AND the workflow succeeded
    if: |
      github.event_name != 'workflow_run' ||
      github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Log trigger source
        run: |
          echo "üîç Queue Processor Triggered"
          echo "=========================="
          echo "Event: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "Triggered by: ${{ github.event.workflow_run.name }}"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Trigger type: Event-driven (Phase 3)"
          elif [ "${{ github.event_name }}" = "schedule" ]; then
            echo "Trigger type: Scheduled backup (hourly safety net)"
          else
            echo "Trigger type: Manual"
          fi
          echo ""

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for git operations

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      # =========================================================================
      # Usage tracking with BLOCKING behavior (fail-closed)
      # =========================================================================
      # Uses cost-based limits from historical GitHub Actions logs.
      # Blocks queue processing when:
      # - Daily cost exceeds $15.00 (15% of weekly)
      # - Weekly cost exceeds $90.00 (90% of weekly allocation)
      # - Usage data unavailable (fail-closed)
      # =========================================================================
      - name: üí∞ Check usage limits (fail-closed)
        id: usage
        run: |
          echo "Checking usage limits before processing..."
          # Run usage check and capture exit code
          set +e
          bun run scripts/tdd-automation/check-claude-code-usage.ts --check
          EXIT_CODE=$?
          set -e

          # Mark that script completed (even if limits exceeded)
          echo "script_completed=true" >> $GITHUB_OUTPUT

          # Exit with the script's exit code
          exit $EXIT_CODE
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TDD_DAILY_COST_LIMIT: '15.00'
          TDD_WEEKLY_COST_LIMIT: '90.00'
        continue-on-error: true

      - name: üö® Fail if usage check crashed (fail-closed safety)
        if: steps.usage.outcome == 'failure' && steps.usage.outputs.script_completed != 'true'
        run: |
          echo "üö® CRITICAL: Usage check script crashed before completion!"
          echo ""
          echo "This is a fail-closed safety mechanism. The workflow cannot proceed"
          echo "because we cannot verify that usage is within limits."
          echo ""
          echo "Possible causes:"
          echo "  - Network timeout fetching workflow logs"
          echo "  - GitHub API authentication failure"
          echo "  - Script parsing error"
          echo ""
          echo "Action required: Investigate the usage check step logs above."
          exit 1

      - name: ‚õî Skip if usage limits exceeded
        if: steps.usage.outcome == 'failure' && steps.usage.outputs.script_completed == 'true'
        run: |
          echo "‚õî Usage limits exceeded - graceful skip"
          echo "   Reason: ${{ steps.usage.outputs.reason || 'limits_exceeded' }}"
          echo "   Daily cost: ${{ steps.usage.outputs.daily_cost || 'unknown' }}"
          echo "   Weekly cost: ${{ steps.usage.outputs.weekly_cost || 'unknown' }}"
          echo ""
          echo "Skipping queue processing until usage is reduced."
          echo "Run 'bun run scripts/tdd-automation/check-claude-code-usage.ts' for details."
          exit 0

      - name: Configure git with token user
        run: |
          USER_NAME=$(gh api user --jq '.login')
          USER_EMAIL=$(gh api user --jq '.email')
          git config user.name "$USER_NAME"
          git config user.email "$USER_EMAIL"
          echo "‚úÖ Git configured as $USER_NAME <$USER_EMAIL>"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Get next spec from queue
        id: next
        run: |
          echo "üîç Looking for next spec to process..."
          bun run scripts/tdd-automation/queue-manager.ts next
        env:
          GITHUB_OUTPUT: ${{ github.output }}
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Check if spec available
        id: check
        run: |
          if [ "${{ steps.next.outputs.has_next }}" != "true" ]; then
            echo "üì≠ No specs available to process"
            echo "should_process=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found spec to process: ${{ steps.next.outputs.spec_id }}"
            echo "should_process=true" >> $GITHUB_OUTPUT
          fi

      - name: Validate issue state and check for duplicates
        if: steps.check.outputs.should_process == 'true'
        id: validate
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"

          echo "üîç Validating issue #$ISSUE_NUMBER before processing..."

          # Check if issue is still open
          ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state')

          if [ "$ISSUE_STATE" = "CLOSED" ]; then
            echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER is already CLOSED"
            echo "   Skipping processing (likely already completed by another PR)"

            # Update the issue to remove in-progress label if present
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true

            echo "should_process=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for existing open PRs for this issue
          EXISTING_PRS=$(gh pr list \
            --label tdd-automation \
            --state open \
            --json number,body \
            --jq ".[] | select(.body | contains(\"Closes #$ISSUE_NUMBER\")) | .number")

          if [ -n "$EXISTING_PRS" ]; then
            echo "‚ö†Ô∏è  Found existing open PR(s) for issue #$ISSUE_NUMBER: $EXISTING_PRS"
            echo "   Skipping processing to avoid duplicate PRs"

            # CRITICAL: Change label to in-progress to prevent loop
            # Without this, the issue stays queued and gets picked up again every trigger
            echo "   Updating label to in-progress to prevent reprocessing..."
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:queued" || true
            gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:in-progress" || true

            # Check if we already posted a duplicate PR comment recently (within 1 hour)
            RECENT_COMMENT=$(gh api \
              "/repos/${{ github.repository }}/issues/${ISSUE_NUMBER}/comments" \
              --jq "[.[] | select(.body | contains(\"Duplicate PR Prevention\")) | select(.created_at > \"$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)\")] | length" 2>/dev/null || echo "0")

            if [ "$RECENT_COMMENT" -eq 0 ]; then
              gh issue comment "$ISSUE_NUMBER" --body "ü§ñ Duplicate PR Prevention - Skipping processing because an open PR already exists for this issue (#$EXISTING_PRS). The existing PR will be processed to completion. If the PR is stuck or invalid, please close it manually and the queue will retry this spec."
            else
              echo "   Skipping comment - already posted within last hour"
            fi

            echo "should_process=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Issue is open and no duplicate PRs found"
          echo "should_process=true" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Check if test is already passing in main (superseded)
        if: steps.check.outputs.should_process == 'true' && steps.validate.outputs.should_process == 'true'
        id: superseded
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "üîç Checking if test $SPEC_ID is already passing in main..."

          # Check if the test file exists at the expected path
          if [ ! -f "$TEST_FILE" ]; then
            echo "‚ö†Ô∏è  Test file $TEST_FILE not found at expected path"
            echo "   Searching for spec $SPEC_ID in codebase..."

            # Search for the spec ID in all spec files
            ACTUAL_FILE=$(grep -rl "$SPEC_ID" specs/ 2>/dev/null | head -1)

            if [ -n "$ACTUAL_FILE" ]; then
              echo "üìç Found spec at: $ACTUAL_FILE (path in issue was stale)"
              TEST_FILE="$ACTUAL_FILE"
              # Continue with the corrected path
            else
              echo "‚ùå Spec $SPEC_ID not found anywhere in specs/ - treating as superseded"
              echo "is_superseded=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # Check if spec ID exists in the file
          if ! grep -q "$SPEC_ID" "$TEST_FILE"; then
            echo "‚ö†Ô∏è  Test $SPEC_ID not found in $TEST_FILE"
            echo "   Searching for spec in other files..."

            # Search for the spec ID in all spec files
            ACTUAL_FILE=$(grep -rl "$SPEC_ID" specs/ 2>/dev/null | head -1)

            if [ -n "$ACTUAL_FILE" ] && [ "$ACTUAL_FILE" != "$TEST_FILE" ]; then
              echo "üìç Found spec at: $ACTUAL_FILE"
              TEST_FILE="$ACTUAL_FILE"
              # Continue with the corrected path
            else
              echo "‚ùå Spec $SPEC_ID not found in codebase - treating as superseded"
              echo "is_superseded=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # Use multiline grep to check if spec ID is associated with .fixme()
          # This handles the case where test.fixme( and spec ID are on different lines
          # Look for pattern: test.fixme( or it.fixme( followed by spec ID within 5 lines
          HAS_FIXME="false"

          # Method 1: Check if file has any .fixme() tests with this spec ID
          # Get line numbers where spec ID appears
          SPEC_LINE=$(grep -n "$SPEC_ID" "$TEST_FILE" | head -1 | cut -d: -f1)

          if [ -n "$SPEC_LINE" ]; then
            # Check the 3 lines before the spec ID for .fixme(
            START_LINE=$((SPEC_LINE - 3))
            if [ "$START_LINE" -lt 1 ]; then
              START_LINE=1
            fi

            # Extract the context and check for .fixme(
            CONTEXT=$(sed -n "${START_LINE},${SPEC_LINE}p" "$TEST_FILE")
            if echo "$CONTEXT" | grep -q "\.fixme("; then
              HAS_FIXME="true"
            fi
          fi

          if [ "$HAS_FIXME" = "true" ]; then
            echo "‚úÖ Test $SPEC_ID still has .fixme() - needs implementation"
            echo "is_superseded=false" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  Test $SPEC_ID no longer has .fixme() - already implemented!"
            echo "is_superseded=true" >> $GITHUB_OUTPUT
          fi

      - name: Close superseded issue
        if: steps.check.outputs.should_process == 'true' && steps.validate.outputs.should_process == 'true' && steps.superseded.outputs.is_superseded == 'true'
        id: close_superseded
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "üìã Closing superseded issue #$ISSUE_NUMBER..."

          # Retry logic for transient GitHub API errors (GraphQL errors, rate limits, etc.)
          MAX_RETRIES=3
          RETRY_DELAY=5

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "   Attempt $attempt/$MAX_RETRIES: Closing issue..."

            if gh issue close "$ISSUE_NUMBER" --reason completed \
              --comment "‚úÖ **Issue Closed: Test Already Implemented**

          The test \`$SPEC_ID\` no longer has \`.fixme()\` in main branch, meaning it has already been implemented (likely through another PR or manual fix).

          **Details**:
          - **Spec ID**: \`$SPEC_ID\`
          - **Test File**: \`$TEST_FILE\`
          - **Status**: Implementation complete - test is active

          No further action needed. The queue will continue with the next spec.

          ---
          *ü§ñ TDD Queue - Superseded Detection*"; then
              echo "   ‚úÖ Issue closed successfully"
              break
            else
              if [ "$attempt" -eq "$MAX_RETRIES" ]; then
                echo "   ‚ùå Failed to close issue after $MAX_RETRIES attempts"
                echo "   Will continue - issue may need manual closure"
              else
                echo "   ‚ö†Ô∏è  Failed, retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              fi
            fi
          done

          # Update labels (with retry)
          for attempt in $(seq 1 $MAX_RETRIES); do
            if gh issue edit "$ISSUE_NUMBER" \
              --remove-label "tdd-spec:queued" \
              --add-label "tdd-spec:completed" 2>/dev/null; then
              break
            else
              if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                sleep 2
              fi
            fi
          done

          echo "‚úÖ Issue #$ISSUE_NUMBER processed as superseded"
          echo "should_trigger_next=true" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Trigger next queue run (after superseded issue closed)
        if: steps.close_superseded.outputs.should_trigger_next == 'true'
        run: |
          echo "üîÑ Superseded issue closed - triggering next queue run..."
          echo ""
          echo "Note: GitHub Actions does not support workflow_run self-triggers."
          echo "Using workflow_dispatch API to continue queue processing."
          echo ""

          # Small delay to ensure GitHub has processed the issue closure
          sleep 3

          # Trigger the next queue run
          gh workflow run "TDD - Dispatch (Trigger Claude)" \
            --ref main

          echo "‚úÖ Next queue run triggered via workflow_dispatch"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      # =========================================================================
      # PHASE 1: Pre-validation with validate-specs.ts
      # =========================================================================
      # Before invoking Claude, check if the test already passes.
      # If yes ‚Üí commit, push, close issue ‚Üí skip Claude (saves time and cost)
      # If no ‚Üí continue to Claude invocation (current behavior)
      # =========================================================================

      - name: Pre-validate spec (check if test passes without Claude)
        if: steps.check.outputs.should_process == 'true' && steps.validate.outputs.should_process == 'true' && steps.superseded.outputs.is_superseded != 'true'
        id: prevalidate
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "üß™ Pre-validating $SPEC_ID..."
          echo "   This checks if the test passes without any code changes."
          echo "   If it passes, the feature is already implemented ‚Üí skip Claude."
          echo ""

          # Run validate-specs.ts with JSON output for parsing
          # This will: remove .fixme(), run test, commit if passes, close issue
          RESULT=$(bun run scripts/validate-specs.ts --json "$SPEC_ID" 2>&1) || true
          EXIT_CODE=$?

          echo "Exit code: $EXIT_CODE"
          echo "Raw output:"
          echo "$RESULT"

          # Parse JSON result
          # NOTE: Use extended regex (-E) to handle optional whitespace after colons
          # The validate-specs.ts script outputs formatted JSON with spaces (e.g., "status": "passed")
          # Previous regex only matched "status":"passed" (no space), causing silent parsing failures
          STATUS=$(echo "$RESULT" | grep -oE '"status"\s*:\s*"[^"]*"' | head -1 | sed 's/"status"[[:space:]]*:[[:space:]]*"//' | tr -d '"')
          HAS_SRC_CHANGES=$(echo "$RESULT" | grep -oE '"hasSrcChanges"\s*:\s*(true|false)' | head -1 | sed 's/"hasSrcChanges"[[:space:]]*:[[:space:]]*//')
          COMMITTED=$(echo "$RESULT" | grep -oE '"committed"\s*:\s*(true|false)' | head -1 | sed 's/"committed"[[:space:]]*:[[:space:]]*//')
          ISSUE_CLOSED=$(echo "$RESULT" | grep -oE '"issueClosed"\s*:\s*(true|false)' | head -1 | sed 's/"issueClosed"[[:space:]]*:[[:space:]]*//')

          # Apply defaults if parsing failed
          STATUS="${STATUS:-unknown}"
          HAS_SRC_CHANGES="${HAS_SRC_CHANGES:-false}"
          COMMITTED="${COMMITTED:-false}"
          ISSUE_CLOSED="${ISSUE_CLOSED:-false}"

          echo ""
          echo "Parsed results:"
          echo "  Status: $STATUS"
          echo "  Has src changes: $HAS_SRC_CHANGES"
          echo "  Committed: $COMMITTED"
          echo "  Issue closed: $ISSUE_CLOSED"

          # Validate parsing succeeded - STATUS should be "passed", "failed", or similar
          if [ "$STATUS" = "unknown" ] || [ -z "$STATUS" ]; then
            echo ""
            echo "‚ö†Ô∏è  Warning: Failed to parse validation result (status='$STATUS')"
            echo "   This may indicate a JSON parsing issue or script error."
            echo "   Proceeding with Claude invocation as fallback."

            echo "test_passed=false" >> $GITHUB_OUTPUT
            echo "needs_claude=true" >> $GITHUB_OUTPUT
            echo "should_trigger_next=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$STATUS" = "passed" ]; then
            echo ""
            echo "‚úÖ Test passed! Feature already implemented."
            echo "   validate-specs.ts has committed the change locally."
            echo "   Skipping Claude invocation."

            # Push the commit to main
            echo ""
            echo "üì§ Pushing commit to main..."
            if git push origin main; then
              echo "‚úÖ Push successful"

              # Clean up any orphaned Claude branches for this issue
              echo ""
              echo "üßπ Cleaning up orphaned claude branches..."
              ORPHAN_BRANCHES=$(git ls-remote --heads origin "claude/issue-${ISSUE_NUMBER}-*" 2>/dev/null | awk '{print $2}' | sed 's|refs/heads/||' || true)
              if [ -n "$ORPHAN_BRANCHES" ]; then
                echo "Found orphaned branches:"
                echo "$ORPHAN_BRANCHES" | while read branch; do
                  echo "  Deleting: $branch"
                  git push origin --delete "$branch" 2>/dev/null || true
                done
                echo "‚úÖ Orphaned branches cleaned up"
              else
                echo "No orphaned branches found"
              fi

              # Close issue AFTER successful push (atomic: close only when code is in main)
              echo ""
              echo "üîí Closing issue #$ISSUE_NUMBER..."

              # Remove old state labels
              gh issue edit "$ISSUE_NUMBER" \
                --remove-label "tdd-spec:queued" \
                --remove-label "tdd-spec:in-progress" \
                --remove-label "tdd-spec:failed" 2>/dev/null || true

              # Add completed label
              gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed" 2>/dev/null || true

              # Add closure comment
              gh issue comment "$ISSUE_NUMBER" --body "‚úÖ **Spec Completed via Pre-Validation**

          Test \\\`$SPEC_ID\\\` passed without code changes - feature was already implemented.

          - **Pre-validation**: Removed \\\`.fixme()\\\`, test passed
          - **Commit**: Created and pushed to main
          - **Status**: Complete

          *ü§ñ TDD Queue - Pre-Validation*" || true

              # Close issue
              gh issue close "$ISSUE_NUMBER" --reason completed || true

              echo "‚úÖ Issue #$ISSUE_NUMBER closed"
              echo "test_passed=true" >> $GITHUB_OUTPUT
              echo "needs_claude=false" >> $GITHUB_OUTPUT
              echo "should_trigger_next=true" >> $GITHUB_OUTPUT
            else
              echo ""
              echo "‚ùå Push to main failed! Re-queuing issue for retry..."

              # Re-queue issue (issue was NOT closed since we're in CI mode)
              gh issue edit "$ISSUE_NUMBER" \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:queued" 2>/dev/null || true

              gh issue comment "$ISSUE_NUMBER" --body "‚ö†Ô∏è **Push Failed** - Pre-validation passed but push to main failed. Test \\\`$SPEC_ID\\\` passed after removing \\\`.fixme()\\\`, commit created locally, but push failed (network issue, branch protection, etc.). Issue re-queued for retry. *ü§ñ TDD Queue*"

              echo "test_passed=false" >> $GITHUB_OUTPUT
              echo "needs_claude=false" >> $GITHUB_OUTPUT
              echo "should_trigger_next=false" >> $GITHUB_OUTPUT
            fi
          else
            echo ""
            echo "‚ùå Test failed (status: $STATUS)"
            echo "   This is expected - the feature needs implementation."
            echo "   Proceeding to Claude invocation."

            echo "test_passed=false" >> $GITHUB_OUTPUT
            echo "needs_claude=true" >> $GITHUB_OUTPUT
            echo "should_trigger_next=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      # =========================================================================
      # SELF-TRIGGER: Queue continuation after pre-validation success
      # =========================================================================
      # GitHub Actions does NOT allow workflow_run to trigger the same workflow.
      # When pre-validation passes, we must explicitly trigger the next queue run
      # via workflow_dispatch API to continue processing the queue.
      # =========================================================================

      - name: Trigger next queue run (after pre-validation success)
        if: steps.prevalidate.outputs.should_trigger_next == 'true'
        run: |
          echo "üîÑ Pre-validation succeeded - triggering next queue run..."
          echo ""
          echo "Note: GitHub Actions does not support workflow_run self-triggers."
          echo "Using workflow_dispatch API to continue queue processing."
          echo ""

          # Small delay to ensure GitHub has processed the issue closure
          sleep 3

          # Trigger the next queue run
          gh workflow run "TDD - Dispatch (Trigger Claude)" \
            --ref main

          echo "‚úÖ Next queue run triggered via workflow_dispatch"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Mark spec as in-progress and trigger Claude Code workflow
        if: |
          steps.check.outputs.should_process == 'true' &&
          steps.validate.outputs.should_process == 'true' &&
          steps.superseded.outputs.is_superseded != 'true' &&
          steps.prevalidate.outputs.needs_claude == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "üèÉ Marking issue #$ISSUE_NUMBER as in-progress..."

          # RACE CONDITION PREVENTION: Re-verify issue is still queued before claiming
          # Another workflow run could have claimed this issue between validation and now
          CURRENT_LABELS=$(gh issue view "$ISSUE_NUMBER" --json labels --jq '.labels[].name' | tr '\n' ' ')

          if echo "$CURRENT_LABELS" | grep -q "tdd-spec:in-progress"; then
            echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER already claimed by another run - exiting gracefully"
            echo "   Current labels: $CURRENT_LABELS"
            exit 0
          fi

          if ! echo "$CURRENT_LABELS" | grep -q "tdd-spec:queued"; then
            echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER no longer queued - exiting gracefully"
            echo "   Current labels: $CURRENT_LABELS"
            exit 0
          fi

          # Update labels (atomic claim)
          gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:queued"
          gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:in-progress"

          # NOTE: We only post @claude comment (not workflow_dispatch) to avoid double trigger
          # The @claude comment triggers tdd-execute.yml via issue_comment event
          echo "ü§ñ Posting @claude comment to trigger Claude Code workflow..."

          # Add comment with workflow instructions (triggers tdd-execute.yml)
          gh issue comment "$ISSUE_NUMBER" --body "@claude implement this spec using the TDD automation workflow.

          ## üìã Spec Details

          - **Test File**: \`$TEST_FILE\`
          - **Spec ID**: \`$SPEC_ID\`
          - **Issue**: #$ISSUE_NUMBER

          ## ü§ñ Automation Mode

          **You are in pipeline/automation mode**:
          - ‚úÖ Make autonomous decisions following Sovrium patterns
          - ‚úÖ Implement minimal code to pass the test
          - ‚ùå DO NOT ask questions - proceed with best judgment
          - ‚ùå DO NOT skip any steps - all are MANDATORY

          ## ‚úÖ Critical Steps (ALL REQUIRED)

          1. **Run e2e-test-fixer agent** - Use \`Task\` tool with \`subagent_type='e2e-test-fixer'\` to remove \`.fixme()\` from \`$SPEC_ID\` and implement minimal code to pass the test
          2. **Run codebase-refactor-auditor agent** - Use \`Task\` tool with \`subagent_type='codebase-refactor-auditor'\`:
             - **If src/ files changed**: Full audit (layer architecture, code quality, refactoring) + \`bun run quality\`
             - **If NO src/ files changed** (test-only): Quick Exit - runs \`bun run quality\` only, skips full audit
             - Agent auto-detects and handles appropriately - ensures quality passes before proceeding
          3. **Commit and push** - Run \`bun run license\`, then commit as \`fix: implement $SPEC_ID\`, push to branch

          ‚ö†Ô∏è **IMPORTANT: DO NOT CREATE PR** - The workflow will create the PR automatically after you push.

          ## ‚ö†Ô∏è Error Handling

          - **If \`bun run quality\` fails**:
            1. Read the FULL error output carefully
            2. Fix ALL failing checks (ESLint, TypeScript, Effect diagnostics, unit tests, E2E)
            3. Re-run \`bun run quality\` until it passes completely
            4. Only THEN proceed to commit and push
          - **If layer architecture violations**: Fix cross-layer imports before proceeding - domain must be pure

          ## üö® MOST COMMON FAILURES (Learn from history)

          - Skipping codebase-refactor-auditor ‚Üí technical debt accumulates
          - **Creating commits with failing regression tests** (PR #4846) ‚Üí CI fails, PR blocked - ALWAYS run \`bun run quality\` and fix ALL failures before commit
          - Not pushing to branch ‚Üí workflow can't create PR

          **Complete workflow documentation**: \`@docs/development/tdd-automation-pipeline.md\`

          ---
          *ü§ñ Automated via [Queue Processor](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

          echo "‚úÖ Issue updated and @claude mentioned - Claude Code will trigger automatically"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
