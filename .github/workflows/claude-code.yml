name: Claude Code

on:
  issue_comment:
    types: [created]

# Required permissions for Claude Code Action
permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read
  id-token: write  # Required for OIDC authentication

jobs:
  # ============================================================================
  # JOB 1: VALIDATE TRIGGER
  #
  # Pre-conditions:
  # 1. Comment author is thomas-jeanneau (TDD bot account)
  # 2. PR has tdd-automation label
  # 3. Credit limits not exceeded
  # ============================================================================
  validate:
    name: Validate Trigger
    if: |
      github.event.issue.pull_request &&
      startsWith(github.event.comment.body, '@claude') &&
      github.event.comment.user.login == 'thomas-jeanneau'
    runs-on: ubuntu-latest
    outputs:
      is-valid: ${{ steps.validate.outputs.is-valid }}
      pr-number: ${{ github.event.issue.number }}
      pr-branch: ${{ steps.pr-info.outputs.branch }}
      agent-type: ${{ steps.parse.outputs.agent-type }}
      spec-file: ${{ steps.parse.outputs.spec-file }}
      spec-id: ${{ steps.parse.outputs.spec-id }}
      timeout: ${{ steps.config.outputs.timeout }}
    steps:
      - name: Get PR info
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          PR_DATA=$(gh pr view "${{ github.event.issue.number }}" --repo "${{ github.repository }}" --json headRefName,labels)
          BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
          HAS_LABEL=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "tdd-automation" || echo "0")
          IS_TDD_BRANCH=$(echo "$BRANCH" | grep -c "^tdd/" || echo "0")

          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

          if [ "$HAS_LABEL" -gt 0 ] || [ "$IS_TDD_BRANCH" -gt 0 ]; then
            echo "is-tdd=true" >> "$GITHUB_OUTPUT"
          else
            echo "is-tdd=false" >> "$GITHUB_OUTPUT"
            echo "âš ï¸ Not a TDD PR - skipping"
          fi

      - name: Parse @claude comment
        id: parse
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          # Extract agent type from comment
          if echo "$COMMENT_BODY" | grep -q "e2e-test-fixer"; then
            echo "agent-type=e2e-test-fixer" >> "$GITHUB_OUTPUT"
          elif echo "$COMMENT_BODY" | grep -q "codebase-refactor-auditor"; then
            echo "agent-type=codebase-refactor-auditor" >> "$GITHUB_OUTPUT"
          else
            echo "agent-type=e2e-test-fixer" >> "$GITHUB_OUTPUT"  # Default
          fi

          # Extract spec file if mentioned (format: `specs/...`)
          # shellcheck disable=SC2016
          SPEC_FILE=$(echo "$COMMENT_BODY" | grep -oP 'File: `\K[^`]+' | head -1 || echo "")
          if [ -z "$SPEC_FILE" ]; then
            SPEC_FILE=$(echo "$COMMENT_BODY" | grep -oP '`specs/[^`]+`' | tr -d '`' | head -1 || echo "")
          fi
          echo "spec-file=$SPEC_FILE" >> "$GITHUB_OUTPUT"

          # Extract spec ID (format: Spec: `SPEC-ID`)
          SPEC_ID=$(echo "$COMMENT_BODY" | grep -oP 'Spec: `\K[^`]+' | head -1 || echo "")
          echo "spec-id=$SPEC_ID" >> "$GITHUB_OUTPUT"

          echo "ðŸ“‹ Parsed: agent=${{ steps.parse.outputs.agent-type || 'e2e-test-fixer' }}, spec-file=$SPEC_FILE, spec-id=$SPEC_ID"

      - name: Check credit limits
        id: credits
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          # Secondary credit check (defense in depth with pr-creator.yml)
          # Cost limits: $100/day, $500/week (see docs/development/tdd-automation-pipeline.md)

          # Query successful claude-code.yml runs with full details from past 7 days
          gh run list --repo "${{ github.repository }}" --workflow="claude-code.yml" \
            --created ">$(date -u -d '7 days ago' +%Y-%m-%dT%H:%M:%SZ)" \
            --json databaseId,conclusion,createdAt,displayTitle,status --limit 100 > /tmp/all_runs.json

          # Filter successful runs
          jq '[.[] | select(.conclusion == "success")]' /tmp/all_runs.json > /tmp/successful_runs.json

          # Calculate daily runs (past 24 hours)
          DAILY_CUTOFF=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%SZ)
          DAILY_RUNS=$(jq "[.[] | select(.createdAt > \"$DAILY_CUTOFF\")] | length" /tmp/successful_runs.json)
          WEEKLY_RUNS=$(jq 'length' /tmp/successful_runs.json)

          # Extract actual costs from Claude Code execution results
          DAILY_TOTAL=0
          WEEKLY_TOTAL=0
          DAILY_RUNS_COUNT=0
          WEEKLY_RUNS_COUNT=0

          echo "ðŸ“Š Extracting actual costs from workflow logs..."

          # Process each successful run
          while IFS='|' read -r run_id created_at; do
            echo "  Fetching logs for run $run_id..."

            # Fetch workflow logs and extract cost
            LOGS=$(gh run view "$run_id" --repo "${{ github.repository }}" --log 2>/dev/null || echo "")

            # Try pattern 1: "total_cost_usd": <number> (Claude Code result JSON)
            COST=$(echo "$LOGS" | grep -oP '"total_cost_usd":\s*\K[0-9]+(\.[0-9]+)?' | head -1 || echo "")

            # Try pattern 2: Total cost: $X.XX (legacy log format)
            if [ -z "$COST" ]; then
              COST=$(echo "$LOGS" | grep -oP 'Total cost: \$\K[0-9]+(\.[0-9]+)?' | head -1 || echo "")
            fi

            # Try pattern 3: Cost: $X.XX (alternative short format)
            if [ -z "$COST" ]; then
              COST=$(echo "$LOGS" | grep -oP 'Cost: \$\K[0-9]+(\.[0-9]+)?' | head -1 || echo "")
            fi

            # Try pattern 4: Session cost: X.XX USD (legacy format)
            if [ -z "$COST" ]; then
              COST=$(echo "$LOGS" | grep -oP 'Session cost: \K[0-9]+(\.[0-9]+)? USD' | sed 's/ USD//' | head -1 || echo "")
            fi

            # Fallback: $15 estimate if no pattern matched
            if [ -z "$COST" ]; then
              COST="15.00"
              echo "    âš ï¸ No cost found in logs, using fallback estimate: \$15.00"
            else
              echo "    âœ… Actual cost extracted: \$$COST"
            fi

            # Add to weekly total
            WEEKLY_TOTAL=$(echo "$WEEKLY_TOTAL + $COST" | bc)
            WEEKLY_RUNS_COUNT=$((WEEKLY_RUNS_COUNT + 1))

            # Add to daily total if within 24h
            if [[ "$created_at" > "$DAILY_CUTOFF" ]]; then
              DAILY_TOTAL=$(echo "$DAILY_TOTAL + $COST" | bc)
              DAILY_RUNS_COUNT=$((DAILY_RUNS_COUNT + 1))
            fi
          done < <(jq -r '.[] | "\(.databaseId)|\(.createdAt)"' /tmp/successful_runs.json)

          # Round totals to 2 decimal places
          ACTUAL_DAILY=$(printf "%.2f" "$DAILY_TOTAL")
          ACTUAL_WEEKLY=$(printf "%.2f" "$WEEKLY_TOTAL")

          # Convert to integers for comparison (multiply by 100 to avoid float issues)
          ACTUAL_DAILY_CENTS=$(printf "%.0f" "$(echo "$ACTUAL_DAILY * 100" | bc)")
          ACTUAL_WEEKLY_CENTS=$(printf "%.0f" "$(echo "$ACTUAL_WEEKLY * 100" | bc)")

          # Calculate limits (in cents for comparison)
          DAILY_LIMIT=100
          WEEKLY_LIMIT=500
          DAILY_WARNING=80
          WEEKLY_WARNING=400
          DAILY_LIMIT_CENTS=$((DAILY_LIMIT * 100))
          WEEKLY_LIMIT_CENTS=$((WEEKLY_LIMIT * 100))

          # Calculate remaining budget
          DAILY_REMAINING=$(echo "$DAILY_LIMIT - $ACTUAL_DAILY" | bc)
          WEEKLY_REMAINING=$(echo "$WEEKLY_LIMIT - $ACTUAL_WEEKLY" | bc)

          # Calculate usage percentages
          DAILY_PERCENT=$(printf "%.0f" "$(echo "$ACTUAL_DAILY * 100 / $DAILY_LIMIT" | bc -l)")
          WEEKLY_PERCENT=$(printf "%.0f" "$(echo "$ACTUAL_WEEKLY * 100 / $WEEKLY_LIMIT" | bc -l)")

          # Time until reset
          HOURS_UNTIL_DAILY_RESET=$(( 24 - $(date -u +%H) ))
          DAYS_UNTIL_WEEKLY_RESET=$(( 7 - $(date -u +%u) ))

          # Store all metrics for comment
          echo "daily-runs=$DAILY_RUNS_COUNT" >> "$GITHUB_OUTPUT"
          echo "weekly-runs=$WEEKLY_RUNS_COUNT" >> "$GITHUB_OUTPUT"
          echo "actual-daily=$ACTUAL_DAILY" >> "$GITHUB_OUTPUT"
          echo "actual-weekly=$ACTUAL_WEEKLY" >> "$GITHUB_OUTPUT"
          echo "daily-limit=$DAILY_LIMIT" >> "$GITHUB_OUTPUT"
          echo "weekly-limit=$WEEKLY_LIMIT" >> "$GITHUB_OUTPUT"
          echo "daily-remaining=$DAILY_REMAINING" >> "$GITHUB_OUTPUT"
          echo "weekly-remaining=$WEEKLY_REMAINING" >> "$GITHUB_OUTPUT"
          echo "daily-percent=$DAILY_PERCENT" >> "$GITHUB_OUTPUT"
          echo "weekly-percent=$WEEKLY_PERCENT" >> "$GITHUB_OUTPUT"
          echo "hours-until-daily-reset=$HOURS_UNTIL_DAILY_RESET" >> "$GITHUB_OUTPUT"
          echo "days-until-weekly-reset=$DAYS_UNTIL_WEEKLY_RESET" >> "$GITHUB_OUTPUT"

          echo "ðŸ“Š Credit Usage Metrics (Actual Costs):"
          echo "  Daily:  \$${ACTUAL_DAILY}/\$${DAILY_LIMIT} USD ($DAILY_PERCENT%) - $DAILY_RUNS_COUNT runs - Reset in ${HOURS_UNTIL_DAILY_RESET}h"
          echo "  Weekly: \$${ACTUAL_WEEKLY}/\$${WEEKLY_LIMIT} USD ($WEEKLY_PERCENT%) - $WEEKLY_RUNS_COUNT runs - Reset in ${DAYS_UNTIL_WEEKLY_RESET}d"

          # Check if limits exceeded (use cent comparison to avoid float issues)
          if [ "$ACTUAL_DAILY_CENTS" -ge "$DAILY_LIMIT_CENTS" ] || [ "$ACTUAL_WEEKLY_CENTS" -ge "$WEEKLY_LIMIT_CENTS" ]; then
            echo "credits-ok=false" >> "$GITHUB_OUTPUT"
            if [ "$ACTUAL_DAILY_CENTS" -ge "$DAILY_LIMIT_CENTS" ]; then
              echo "limit-type=daily" >> "$GITHUB_OUTPUT"
              echo "â›” Daily credit limit (\$$DAILY_LIMIT) reached"
            else
              echo "limit-type=weekly" >> "$GITHUB_OUTPUT"
              echo "â›” Weekly credit limit (\$$WEEKLY_LIMIT) reached"
            fi
          else
            echo "credits-ok=true" >> "$GITHUB_OUTPUT"
            echo "limit-type=none" >> "$GITHUB_OUTPUT"
            echo "âœ… Credits OK"
          fi

      - name: Post credit usage comment (always)
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          # Always post credit usage comment for transparency
          # Extract metrics from previous step
          CREDITS_OK="${{ steps.credits.outputs.credits-ok }}"
          LIMIT_TYPE="${{ steps.credits.outputs.limit-type }}"
          DAILY_RUNS="${{ steps.credits.outputs.daily-runs }}"
          WEEKLY_RUNS="${{ steps.credits.outputs.weekly-runs }}"
          ACTUAL_DAILY="${{ steps.credits.outputs.actual-daily }}"
          ACTUAL_WEEKLY="${{ steps.credits.outputs.actual-weekly }}"
          DAILY_LIMIT="${{ steps.credits.outputs.daily-limit }}"
          WEEKLY_LIMIT="${{ steps.credits.outputs.weekly-limit }}"
          DAILY_REMAINING="${{ steps.credits.outputs.daily-remaining }}"
          WEEKLY_REMAINING="${{ steps.credits.outputs.weekly-remaining }}"
          DAILY_PERCENT="${{ steps.credits.outputs.daily-percent }}"
          WEEKLY_PERCENT="${{ steps.credits.outputs.weekly-percent }}"
          HOURS_RESET="${{ steps.credits.outputs.hours-until-daily-reset }}"
          DAYS_RESET="${{ steps.credits.outputs.days-until-weekly-reset }}"

          # Determine comment header based on status
          {
            if [ "$CREDITS_OK" != "true" ]; then
              # Limit exceeded
              if [ "$LIMIT_TYPE" = "daily" ]; then
                echo "## â¸ï¸ Daily Credit Limit Reached"
                echo ""
                echo "TDD automation paused until daily limit resets in **${HOURS_RESET} hours**."
              else
                echo "## â¸ï¸ Weekly Credit Limit Reached"
                echo ""
                echo "TDD automation paused until weekly limit resets in **${DAYS_RESET} days**."
              fi
            elif [ "$DAILY_PERCENT" -ge 80 ] || [ "$WEEKLY_PERCENT" -ge 80 ]; then
              # Warning: approaching limit
              echo "## âš ï¸ Warning: Approaching Credit Limit"
              echo ""
              if [ "$DAILY_PERCENT" -ge 80 ]; then
                echo "Daily usage is at **${DAILY_PERCENT}%** of limit. Execution will continue but monitor usage closely."
              else
                echo "Weekly usage is at **${WEEKLY_PERCENT}%** of limit. Execution will continue but monitor usage closely."
              fi
            else
              # Under limits
              echo "## âœ… Credits Available"
              echo ""
              echo "Claude Code execution proceeding. Current usage is below warning thresholds."
            fi
            echo ""
            echo "### ðŸ“Š Current Usage (Actual Costs)"
            echo ""
            echo "| Period | Usage | Limit | Remaining | % Used | Runs | Reset In |"
            echo "|--------|-------|-------|-----------|--------|------|----------|"
            echo "| **Daily** | \$$ACTUAL_DAILY | \$$DAILY_LIMIT | \$$DAILY_REMAINING | $DAILY_PERCENT% | $DAILY_RUNS | ${HOURS_RESET}h |"
            echo "| **Weekly** | \$$ACTUAL_WEEKLY | \$$WEEKLY_LIMIT | \$$WEEKLY_REMAINING | $WEEKLY_PERCENT% | $WEEKLY_RUNS | ${DAYS_RESET}d |"
          } > /tmp/credit_usage.md

          # Post comment (always)
          gh pr comment "${{ github.event.issue.number }}" --repo "${{ github.repository }}" --body-file /tmp/credit_usage.md
          echo "âœ… Credit usage comment posted"

      - name: Validate all conditions
        id: validate
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          IS_TDD="${{ steps.pr-info.outputs.is-tdd }}"
          CREDITS_OK="${{ steps.credits.outputs.credits-ok }}"

          if [ "$IS_TDD" != "true" ]; then
            echo "is-valid=false" >> "$GITHUB_OUTPUT"
            echo "âŒ Validation failed: Not a TDD PR"
            exit 0
          fi

          if [ "$CREDITS_OK" != "true" ]; then
            echo "is-valid=false" >> "$GITHUB_OUTPUT"
            echo "â›” Credit limit reached - execution blocked (comment already posted)"
            exit 0
          fi

          echo "is-valid=true" >> "$GITHUB_OUTPUT"
          echo "âœ… All validation checks passed"

      - uses: actions/checkout@v4
        if: steps.validate.outputs.is-valid == 'true'
        with:
          ref: ${{ steps.pr-info.outputs.branch }}

      - name: Extract per-spec timeout
        id: config
        if: steps.validate.outputs.is-valid == 'true'
        run: |
          SPEC_FILE="${{ steps.parse.outputs.spec-file }}"
          DEFAULT_TIMEOUT=45

          if [ -n "$SPEC_FILE" ] && [ -f "$SPEC_FILE" ]; then
            # Extract @tdd-timeout annotation if present
            TIMEOUT=$(grep -oP '@tdd-timeout \K[0-9]+' "$SPEC_FILE" 2>/dev/null || echo "$DEFAULT_TIMEOUT")
          else
            TIMEOUT=$DEFAULT_TIMEOUT
          fi

          echo "timeout=$TIMEOUT" >> "$GITHUB_OUTPUT"
          echo "â±ï¸ Timeout: ${TIMEOUT} minutes"

  # ============================================================================
  # JOB 2: EXECUTE CLAUDE CODE
  #
  # Steps:
  # 1. Checkout PR branch
  # 2. Sync with main (detect conflicts)
  # 3. Configure agent based on failure type
  # 4. Run anthropics/claude-code-action@v1
  # 5. Push changes (handled by action)
  # ============================================================================
  execute:
    name: Execute Claude Code
    needs: validate
    if: needs.validate.outputs.is-valid == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: ${{ fromJSON(needs.validate.outputs.timeout) || 45 }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate.outputs.pr-branch }}
          token: ${{ secrets.GH_PAT_WORKFLOW }}
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Sync with main branch
        id: sync
        run: |
          git fetch origin main

          BEHIND=$(git rev-list --count HEAD..origin/main)
          echo "behind=$BEHIND" >> "$GITHUB_OUTPUT"

          if [ "$BEHIND" -gt 0 ]; then
            echo "ðŸ“¥ Main branch has $BEHIND new commits, merging..."

            if ! git merge origin/main --no-edit 2>&1 | tee /tmp/merge_output.txt; then
              echo "âš ï¸ Merge failed. Analyzing failure type..."

              # Check for actual merge conflicts using git status
              # Conflict markers: UU (both modified), AA (both added), DD (both deleted),
              # AU (added by us), UA (added by them), DU (deleted by us), UD (deleted by them)
              if git status --porcelain | grep -q '^UU\|^AA\|^DD\|^AU\|^UA\|^DU\|^UD'; then
                # Actual conflicts detected
                echo "has-conflict=true" >> "$GITHUB_OUTPUT"
                git diff --name-only --diff-filter=U > /tmp/conflicted_files.txt
                CONFLICT_FILES=$(cat /tmp/conflicted_files.txt | tr '\n' ', ' | sed 's/,$//')
                echo "conflict-files=$CONFLICT_FILES" >> "$GITHUB_OUTPUT"

                # Abort merge if in progress
                if [ -f .git/MERGE_HEAD ]; then
                  git merge --abort
                fi

                echo "âš ï¸ Merge conflict detected in: $CONFLICT_FILES"
                echo "ðŸ“ Conflict markers found in git status - requires manual resolution"
              else
                # No conflicts - merge failed for other reasons
                echo "has-conflict=false" >> "$GITHUB_OUTPUT"

                # Abort merge if in progress
                if [ -f .git/MERGE_HEAD ]; then
                  git merge --abort
                fi

                # Log error details
                echo "âŒ Merge failed but no conflicts detected"
                echo "Merge output:"
                cat /tmp/merge_output.txt

                echo "Git status:"
                git status --porcelain

                # Fail the workflow - this is not a conflict, it's an error
                echo "::error::Merge with origin/main failed without conflicts. This may indicate a git error, network issue, or other problem. See logs for details."
                exit 1
              fi
            else
              echo "has-conflict=false" >> "$GITHUB_OUTPUT"
              git push origin HEAD
              echo "âœ… Successfully merged and pushed"
            fi
          else
            echo "has-conflict=false" >> "$GITHUB_OUTPUT"
            echo "âœ… Already up to date with main"
          fi

      - name: Add conflict label if needed
        if: steps.sync.outputs.has-conflict == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          gh pr edit "${{ needs.validate.outputs.pr-number }}" \
            --repo "${{ github.repository }}" \
            --add-label "tdd-automation:had-conflict"

          # Disable auto-merge until human reviews conflict resolution
          gh pr merge "${{ needs.validate.outputs.pr-number }}" \
            --repo "${{ github.repository }}" --disable-auto || true

      - name: Configure agent
        id: agent-config
        env:
          AGENT_TYPE: ${{ needs.validate.outputs.agent-type }}
          HAS_CONFLICT: ${{ steps.sync.outputs.has-conflict }}
          CONFLICT_FILES: ${{ steps.sync.outputs.conflict-files }}
          SPEC_ID: ${{ needs.validate.outputs.spec-id }}
          SPEC_FILE: ${{ needs.validate.outputs.spec-file }}
          ORIGINAL_COMMENT: ${{ github.event.comment.body }}
        run: |
          # Configure claude_args based on agent type
          # See: docs/development/tdd-automation-pipeline.md#agent-configurations

          if [ "$AGENT_TYPE" = "codebase-refactor-auditor" ]; then
            ALLOWED_TOOLS="Bash,Read,Write,Edit,Glob,Grep,Task,TodoWrite,LSP"
            DISALLOWED_TOOLS="WebFetch,WebSearch,Skill,AskUserQuestion,NotebookEdit"
            MAX_TURNS=40
          else
            # Default: e2e-test-fixer
            ALLOWED_TOOLS="Bash,Read,Write,Edit,Glob,Grep,Task,TodoWrite,LSP,Skill"
            DISALLOWED_TOOLS="WebFetch,WebSearch,AskUserQuestion,NotebookEdit"
            MAX_TURNS=50
          fi

          # Build claude_args for the action
          CLAUDE_ARGS="--max-turns $MAX_TURNS --allowedTools \"$ALLOWED_TOOLS\" --disallowedTools \"$DISALLOWED_TOOLS\""
          echo "claude-args=$CLAUDE_ARGS" >> "$GITHUB_OUTPUT"

          # Build prompt based on context and agent type
          # CRITICAL: Must explicitly instruct Claude Code to invoke Task tool with subagent_type
          # Why: Agents are not activated by text instructions alone. They must be explicitly
          # invoked via the Task tool for their specialized system prompts and behaviors to activate.
          # Tool restrictions (--allowedTools) apply to the base assistant, not automatically to agents.
          if [ "$HAS_CONFLICT" = "true" ]; then
            {
              echo "âš ï¸ **MERGE CONFLICT DETECTED**"
              echo ""
              echo "Conflicted files: \`$CONFLICT_FILES\`"
              echo ""
              echo "**Step 1: Resolve conflicts first**"
              echo "1. Run: \`git fetch origin main && git merge origin/main\`"
              echo "2. Carefully resolve each conflict:"
              echo "   - For DOMAIN MODEL conflicts: prefer main (newer schema)"
              echo "   - For TEST FILE conflicts: merge both test cases"
              echo "   - For CONFIG conflicts: prefer main"
              echo "3. After resolving, run full quality + regression tests"
              echo "4. If unsure about ANY conflict, add comment: \`// TODO human review needed\`"
              echo "5. Commit the resolved merge"
              echo ""
              echo "**Step 2: Use Task tool to invoke specialized agent**"
              echo ""
              echo "After resolving conflicts, invoke the \`$AGENT_TYPE\` agent via the Task tool:"
              echo ""
              if [ "$AGENT_TYPE" = "codebase-refactor-auditor" ]; then
                echo "- Agent type: \`codebase-refactor-auditor\`"
                echo "- Spec: \`$SPEC_ID\`"
                echo "- Instructions: Fix quality issues (lint, format, type errors)"
              else
                echo "- Agent type: \`e2e-test-fixer\`"
                echo "- Spec: \`$SPEC_ID\`"
                echo "- Test file: \`$SPEC_FILE\`"
                echo "- Instructions: Implement feature to make tests pass"
              fi
            } > /tmp/claude_prompt.txt
          else
            # Generate agent invocation prompt based on agent type
            if [ "$AGENT_TYPE" = "codebase-refactor-auditor" ]; then
              {
                echo "Use the Task tool to invoke the \`codebase-refactor-auditor\` agent to fix quality issues for this spec."
                echo ""
                echo "**Context:**"
                echo "- Spec: \`$SPEC_ID\`"
                echo "- Branch: \`tdd/$(echo "$SPEC_ID" | tr '[:upper:]' '[:lower:]')\`"
                echo "- Failure type: Quality issues only (tests pass, but quality check fails)"
                echo ""
                echo "**Instructions for the agent:**"
                echo "1. Run \`bun run quality\` to identify specific quality issues"
                echo "2. Fix lint, format, or type errors in production code"
                echo "3. Do NOT modify test files - this is a quality issue, not a test failure"
                echo "4. Run \`bun run quality\` again to verify all issues are fixed"
                echo "5. Run \`bun test:e2e -- $SPEC_FILE\` to confirm tests still pass"
                echo "6. Commit with message: \"fix: resolve quality issues for $SPEC_ID\""
                echo "7. Push to origin (MANDATORY for pipeline to continue)"
                echo ""
                echo "**Constraints:**"
                echo "- NEVER modify test logic or assertions"
                echo "- NEVER ask clarifying questions (autonomous mode)"
                echo "- Maximum 3 iterations before reporting failure"
                echo "- Follow functional programming patterns (no push/mutation)"
              } > /tmp/claude_prompt.txt
            else
              {
                echo "Use the Task tool to invoke the \`e2e-test-fixer\` agent to implement this spec."
                echo ""
                echo "**Context:**"
                echo "- Spec: \`$SPEC_ID\`"
                echo "- Test file: \`$SPEC_FILE\`"
                echo "- Branch: \`tdd/$(echo "$SPEC_ID" | tr '[:upper:]' '[:lower:]')\`"
                echo ""
                echo "**Instructions for the agent:**"
                echo "1. Analyze the test to understand what it expects"
                echo "2. Verify required schemas exist (use Skill tool if missing)"
                echo "3. Implement minimal code to pass the test"
                echo "4. Run \`bun test:e2e -- $SPEC_FILE\` to verify tests pass"
                echo "5. Run \`bun run quality\` to ensure code quality"
                echo "6. Commit with message: \"fix: implement $SPEC_ID\""
                echo "7. Push to origin (MANDATORY for pipeline to continue)"
                echo ""
                echo "**Constraints:**"
                echo "- NEVER modify test logic or assertions"
                echo "- NEVER ask clarifying questions (autonomous mode)"
                echo "- Maximum 3 iterations before reporting failure"
                echo "- Follow functional programming patterns (no push/mutation)"
              } > /tmp/claude_prompt.txt
            fi
          fi

          # Store prompt for action
          PROMPT=$(cat /tmp/claude_prompt.txt)
          echo "prompt<<EOF" >> "$GITHUB_OUTPUT"
          echo "$PROMPT" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Run Claude Code Action
        uses: anthropics/claude-code-action@v1
        timeout-minutes: ${{ fromJSON(needs.validate.outputs.timeout) || 45 }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: ${{ steps.agent-config.outputs.prompt }}
          claude_args: ${{ steps.agent-config.outputs.claude-args }}
          track_progress: true
          use_sticky_comment: true

      - name: Handle conflict resolution notice
        if: steps.sync.outputs.has-conflict == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          PR_NUMBER="${{ needs.validate.outputs.pr-number }}"

          # Post conflict review notice
          {
            echo "âš ï¸ **Merge Conflict Resolution Notice**"
            echo ""
            echo "This PR had merge conflicts that were auto-resolved by Claude Code."
            echo ""
            echo "**Human review required before merge.**"
            echo ""
            echo "Please verify:"
            echo "- [ ] Conflict resolution is correct"
            echo "- [ ] Tests pass"
            echo "- [ ] Code logic makes sense"
            echo ""
            echo "After review, re-enable auto-merge or merge manually."
          } > /tmp/conflict_comment.txt

          gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/conflict_comment.txt
