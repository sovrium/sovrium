name: Claude Code

on:
  issue_comment:
    types: [created]

# Required permissions for Claude Code Action
permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read
  id-token: write  # Required for OIDC authentication

jobs:
  # ============================================================================
  # JOB 1: VALIDATE TRIGGER
  #
  # Pre-conditions:
  # 1. Comment author is thomas-jeanneau (TDD bot account)
  # 2. PR has tdd-automation label
  # 3. Credit limits not exceeded
  # ============================================================================
  validate:
    name: Validate Trigger
    if: |
      github.event.issue.pull_request &&
      startsWith(github.event.comment.body, '@claude') &&
      github.event.comment.user.login == 'thomas-jeanneau'
    runs-on: ubuntu-latest
    outputs:
      is-valid: ${{ steps.validate.outputs.is-valid }}
      pr-number: ${{ github.event.issue.number }}
      pr-branch: ${{ steps.pr-info.outputs.branch }}
      agent-type: ${{ steps.parse.outputs.agent-type }}
      spec-file: ${{ steps.parse.outputs.spec-file }}
      spec-id: ${{ steps.parse.outputs.spec-id }}
      timeout: ${{ steps.config.outputs.timeout }}
    steps:
      - name: Get PR info
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          PR_DATA=$(gh pr view "${{ github.event.issue.number }}" --repo "${{ github.repository }}" --json headRefName,labels)
          BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
          HAS_LABEL=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "tdd-automation" || echo "0")
          IS_TDD_BRANCH=$(echo "$BRANCH" | grep -c "^tdd/" || echo "0")

          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

          if [ "$HAS_LABEL" -gt 0 ] || [ "$IS_TDD_BRANCH" -gt 0 ]; then
            echo "is-tdd=true" >> "$GITHUB_OUTPUT"
          else
            echo "is-tdd=false" >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è Not a TDD PR - skipping"
          fi

      - name: Parse @claude comment
        id: parse
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          # Extract agent type from comment
          if echo "$COMMENT_BODY" | grep -q "e2e-test-fixer"; then
            echo "agent-type=e2e-test-fixer" >> "$GITHUB_OUTPUT"
          elif echo "$COMMENT_BODY" | grep -q "codebase-refactor-auditor"; then
            echo "agent-type=codebase-refactor-auditor" >> "$GITHUB_OUTPUT"
          else
            echo "agent-type=e2e-test-fixer" >> "$GITHUB_OUTPUT"  # Default
          fi

          # Extract spec file if mentioned (format: `specs/...`)
          # shellcheck disable=SC2016
          SPEC_FILE=$(echo "$COMMENT_BODY" | grep -oP 'File: `\K[^`]+' | head -1 || echo "")
          if [ -z "$SPEC_FILE" ]; then
            SPEC_FILE=$(echo "$COMMENT_BODY" | grep -oP '`specs/[^`]+`' | tr -d '`' | head -1 || echo "")
          fi
          echo "spec-file=$SPEC_FILE" >> "$GITHUB_OUTPUT"

          # Extract spec ID (format: Spec: `SPEC-ID`)
          SPEC_ID=$(echo "$COMMENT_BODY" | grep -oP 'Spec: `\K[^`]+' | head -1 || echo "")
          echo "spec-id=$SPEC_ID" >> "$GITHUB_OUTPUT"

          echo "üìã Parsed: agent=${{ steps.parse.outputs.agent-type || 'e2e-test-fixer' }}, spec-file=$SPEC_FILE, spec-id=$SPEC_ID"

      - name: Check credit limits
        id: credits
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          # Secondary credit check (defense in depth with pr-creator.yml)
          # Cost limits: $100/day, $500/week (see docs/development/tdd-automation-pipeline.md)

          # Query successful claude-code.yml runs with full details from past 7 days
          gh run list --repo "${{ github.repository }}" --workflow="claude-code.yml" \
            --created ">$(date -u -d '7 days ago' +%Y-%m-%dT%H:%M:%SZ)" \
            --json databaseId,conclusion,createdAt,displayTitle,status --limit 100 > /tmp/all_runs.json

          # Filter successful runs
          jq '[.[] | select(.conclusion == "success")]' /tmp/all_runs.json > /tmp/successful_runs.json

          # Calculate daily runs (past 24 hours)
          DAILY_CUTOFF=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%SZ)
          DAILY_RUNS=$(jq "[.[] | select(.createdAt > \"$DAILY_CUTOFF\")] | length" /tmp/successful_runs.json)
          WEEKLY_RUNS=$(jq 'length' /tmp/successful_runs.json)

          # Extract actual costs from Claude Code execution results
          DAILY_TOTAL=0
          WEEKLY_TOTAL=0
          DAILY_RUNS_COUNT=0
          WEEKLY_RUNS_COUNT=0

          echo "üìä Extracting actual costs from workflow logs..."

          # Process each successful run
          while IFS='|' read -r run_id created_at; do
            echo "  Fetching logs for run $run_id..."

            # Fetch workflow logs and extract cost
            LOGS=$(gh run view "$run_id" --repo "${{ github.repository }}" --log 2>/dev/null || echo "")

            # Try pattern 1: "total_cost_usd": <number> (Claude Code result JSON)
            COST=$(echo "$LOGS" | grep -oP '"total_cost_usd":\s*\K[0-9]+(\.[0-9]+)?' | head -1 || echo "")

            # Try pattern 2: Total cost: $X.XX (legacy log format)
            if [ -z "$COST" ]; then
              COST=$(echo "$LOGS" | grep -oP 'Total cost: \$\K[0-9]+(\.[0-9]+)?' | head -1 || echo "")
            fi

            # Try pattern 3: Cost: $X.XX (alternative short format)
            if [ -z "$COST" ]; then
              COST=$(echo "$LOGS" | grep -oP 'Cost: \$\K[0-9]+(\.[0-9]+)?' | head -1 || echo "")
            fi

            # Try pattern 4: Session cost: X.XX USD (legacy format)
            if [ -z "$COST" ]; then
              COST=$(echo "$LOGS" | grep -oP 'Session cost: \K[0-9]+(\.[0-9]+)? USD' | sed 's/ USD//' | head -1 || echo "")
            fi

            # Fallback: $15 estimate if no pattern matched
            if [ -z "$COST" ]; then
              COST="15.00"
              echo "    ‚ö†Ô∏è No cost found in logs, using fallback estimate: \$15.00"
            else
              echo "    ‚úÖ Actual cost extracted: \$$COST"
            fi

            # Add to weekly total
            WEEKLY_TOTAL=$(echo "$WEEKLY_TOTAL + $COST" | bc)
            WEEKLY_RUNS_COUNT=$((WEEKLY_RUNS_COUNT + 1))

            # Add to daily total if within 24h
            if [[ "$created_at" > "$DAILY_CUTOFF" ]]; then
              DAILY_TOTAL=$(echo "$DAILY_TOTAL + $COST" | bc)
              DAILY_RUNS_COUNT=$((DAILY_RUNS_COUNT + 1))
            fi
          done < <(jq -r '.[] | "\(.databaseId)|\(.createdAt)"' /tmp/successful_runs.json)

          # Round totals to 2 decimal places
          ACTUAL_DAILY=$(printf "%.2f" "$DAILY_TOTAL")
          ACTUAL_WEEKLY=$(printf "%.2f" "$WEEKLY_TOTAL")

          # Convert to integers for comparison (multiply by 100 to avoid float issues)
          ACTUAL_DAILY_CENTS=$(printf "%.0f" "$(echo "$ACTUAL_DAILY * 100" | bc)")
          ACTUAL_WEEKLY_CENTS=$(printf "%.0f" "$(echo "$ACTUAL_WEEKLY * 100" | bc)")

          # Calculate limits (in cents for comparison)
          DAILY_LIMIT=100
          WEEKLY_LIMIT=500
          DAILY_WARNING=80
          WEEKLY_WARNING=400
          DAILY_LIMIT_CENTS=$((DAILY_LIMIT * 100))
          WEEKLY_LIMIT_CENTS=$((WEEKLY_LIMIT * 100))

          # Calculate remaining budget
          DAILY_REMAINING=$(echo "$DAILY_LIMIT - $ACTUAL_DAILY" | bc)
          WEEKLY_REMAINING=$(echo "$WEEKLY_LIMIT - $ACTUAL_WEEKLY" | bc)

          # Calculate usage percentages
          DAILY_PERCENT=$(printf "%.0f" "$(echo "$ACTUAL_DAILY * 100 / $DAILY_LIMIT" | bc -l)")
          WEEKLY_PERCENT=$(printf "%.0f" "$(echo "$ACTUAL_WEEKLY * 100 / $WEEKLY_LIMIT" | bc -l)")

          # Time until reset
          HOURS_UNTIL_DAILY_RESET=$(( 24 - $(date -u +%H) ))
          DAYS_UNTIL_WEEKLY_RESET=$(( 7 - $(date -u +%u) ))

          # Store all metrics for comment
          echo "daily-runs=$DAILY_RUNS_COUNT" >> "$GITHUB_OUTPUT"
          echo "weekly-runs=$WEEKLY_RUNS_COUNT" >> "$GITHUB_OUTPUT"
          echo "actual-daily=$ACTUAL_DAILY" >> "$GITHUB_OUTPUT"
          echo "actual-weekly=$ACTUAL_WEEKLY" >> "$GITHUB_OUTPUT"
          echo "daily-limit=$DAILY_LIMIT" >> "$GITHUB_OUTPUT"
          echo "weekly-limit=$WEEKLY_LIMIT" >> "$GITHUB_OUTPUT"
          echo "daily-remaining=$DAILY_REMAINING" >> "$GITHUB_OUTPUT"
          echo "weekly-remaining=$WEEKLY_REMAINING" >> "$GITHUB_OUTPUT"
          echo "daily-percent=$DAILY_PERCENT" >> "$GITHUB_OUTPUT"
          echo "weekly-percent=$WEEKLY_PERCENT" >> "$GITHUB_OUTPUT"
          echo "hours-until-daily-reset=$HOURS_UNTIL_DAILY_RESET" >> "$GITHUB_OUTPUT"
          echo "days-until-weekly-reset=$DAYS_UNTIL_WEEKLY_RESET" >> "$GITHUB_OUTPUT"

          echo "üìä Credit Usage Metrics (Actual Costs):"
          echo "  Daily:  \$${ACTUAL_DAILY}/\$${DAILY_LIMIT} USD ($DAILY_PERCENT%) - $DAILY_RUNS_COUNT runs - Reset in ${HOURS_UNTIL_DAILY_RESET}h"
          echo "  Weekly: \$${ACTUAL_WEEKLY}/\$${WEEKLY_LIMIT} USD ($WEEKLY_PERCENT%) - $WEEKLY_RUNS_COUNT runs - Reset in ${DAYS_UNTIL_WEEKLY_RESET}d"

          # Check if limits exceeded (use cent comparison to avoid float issues)
          if [ "$ACTUAL_DAILY_CENTS" -ge "$DAILY_LIMIT_CENTS" ] || [ "$ACTUAL_WEEKLY_CENTS" -ge "$WEEKLY_LIMIT_CENTS" ]; then
            echo "credits-ok=false" >> "$GITHUB_OUTPUT"
            if [ "$ACTUAL_DAILY_CENTS" -ge "$DAILY_LIMIT_CENTS" ]; then
              echo "limit-type=daily" >> "$GITHUB_OUTPUT"
              echo "‚õî Daily credit limit (\$$DAILY_LIMIT) reached"
            else
              echo "limit-type=weekly" >> "$GITHUB_OUTPUT"
              echo "‚õî Weekly credit limit (\$$WEEKLY_LIMIT) reached"
            fi
          else
            echo "credits-ok=true" >> "$GITHUB_OUTPUT"
            echo "limit-type=none" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Credits OK"
          fi

      - name: Setup Bun (for credit comment script)
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            scripts/tdd-automation/workflows/claude-code/
            package.json

      - name: Post credit usage comment (always)
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          # Pass credit metrics as environment variables
          credits-ok: ${{ steps.credits.outputs.credits-ok }}
          limit-type: ${{ steps.credits.outputs.limit-type }}
          daily-runs: ${{ steps.credits.outputs.daily-runs }}
          weekly-runs: ${{ steps.credits.outputs.weekly-runs }}
          actual-daily: ${{ steps.credits.outputs.actual-daily }}
          actual-weekly: ${{ steps.credits.outputs.actual-weekly }}
          daily-limit: ${{ steps.credits.outputs.daily-limit }}
          weekly-limit: ${{ steps.credits.outputs.weekly-limit }}
          daily-remaining: ${{ steps.credits.outputs.daily-remaining }}
          weekly-remaining: ${{ steps.credits.outputs.weekly-remaining }}
          daily-percent: ${{ steps.credits.outputs.daily-percent }}
          weekly-percent: ${{ steps.credits.outputs.weekly-percent }}
          hours-until-daily-reset: ${{ steps.credits.outputs.hours-until-daily-reset }}
          days-until-weekly-reset: ${{ steps.credits.outputs.days-until-weekly-reset }}
        run: |
          # Generate credit usage comment using TypeScript (replaces 60 lines of bash)
          bun run scripts/tdd-automation/workflows/claude-code/generate-credit-comment.ts > /tmp/credit_usage.md

          # Post comment (always)
          gh pr comment "${{ github.event.issue.number }}" --repo "${{ github.repository }}" --body-file /tmp/credit_usage.md
          echo "‚úÖ Credit usage comment posted"

      - name: Validate all conditions
        id: validate
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          IS_TDD="${{ steps.pr-info.outputs.is-tdd }}"
          CREDITS_OK="${{ steps.credits.outputs.credits-ok }}"

          if [ "$IS_TDD" != "true" ]; then
            echo "is-valid=false" >> "$GITHUB_OUTPUT"
            echo "‚ùå Validation failed: Not a TDD PR"
            exit 0
          fi

          if [ "$CREDITS_OK" != "true" ]; then
            echo "is-valid=false" >> "$GITHUB_OUTPUT"
            echo "‚õî Credit limit reached - execution blocked (comment already posted)"
            exit 0
          fi

          echo "is-valid=true" >> "$GITHUB_OUTPUT"
          echo "‚úÖ All validation checks passed"

      - uses: actions/checkout@v4
        if: steps.validate.outputs.is-valid == 'true'
        with:
          ref: ${{ steps.pr-info.outputs.branch }}

      - name: Extract per-spec timeout
        id: config
        if: steps.validate.outputs.is-valid == 'true'
        run: |
          SPEC_FILE="${{ steps.parse.outputs.spec-file }}"
          DEFAULT_TIMEOUT=45

          if [ -n "$SPEC_FILE" ] && [ -f "$SPEC_FILE" ]; then
            # Extract @tdd-timeout annotation if present
            TIMEOUT=$(grep -oP '@tdd-timeout \K[0-9]+' "$SPEC_FILE" 2>/dev/null || echo "$DEFAULT_TIMEOUT")
          else
            TIMEOUT=$DEFAULT_TIMEOUT
          fi

          echo "timeout=$TIMEOUT" >> "$GITHUB_OUTPUT"
          echo "‚è±Ô∏è Timeout: ${TIMEOUT} minutes"

  # ============================================================================
  # JOB 2: EXECUTE CLAUDE CODE
  #
  # Steps:
  # 1. Checkout PR branch
  # 2. Sync with main (detect conflicts)
  # 3. Configure agent based on failure type
  # 4. Run anthropics/claude-code-action@v1
  # 5. Push changes (handled by action)
  # ============================================================================
  execute:
    name: Execute Claude Code
    needs: validate
    if: needs.validate.outputs.is-valid == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: ${{ fromJSON(needs.validate.outputs.timeout) || 45 }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate.outputs.pr-branch }}
          token: ${{ secrets.GH_PAT_WORKFLOW }}
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Sync with main branch
        id: sync
        run: |
          git fetch origin main

          BEHIND=$(git rev-list --count HEAD..origin/main)
          echo "behind=$BEHIND" >> "$GITHUB_OUTPUT"

          if [ "$BEHIND" -gt 0 ]; then
            echo "üì• Main branch has $BEHIND new commits, merging..."

            if ! git merge origin/main --no-edit 2>&1 | tee /tmp/merge_output.txt; then
              echo "‚ö†Ô∏è Merge failed. Analyzing failure type..."

              # Check for actual merge conflicts using git status
              # Conflict markers: UU (both modified), AA (both added), DD (both deleted),
              # AU (added by us), UA (added by them), DU (deleted by us), UD (deleted by them)
              if git status --porcelain | grep -q '^UU\|^AA\|^DD\|^AU\|^UA\|^DU\|^UD'; then
                # Actual conflicts detected
                echo "has-conflict=true" >> "$GITHUB_OUTPUT"
                git diff --name-only --diff-filter=U > /tmp/conflicted_files.txt
                CONFLICT_FILES=$(cat /tmp/conflicted_files.txt | tr '\n' ', ' | sed 's/,$//')
                echo "conflict-files=$CONFLICT_FILES" >> "$GITHUB_OUTPUT"

                # Abort merge if in progress
                if [ -f .git/MERGE_HEAD ]; then
                  git merge --abort
                fi

                echo "‚ö†Ô∏è Merge conflict detected in: $CONFLICT_FILES"
                echo "üìù Conflict markers found in git status - requires manual resolution"
              else
                # No conflicts - merge failed for other reasons
                echo "has-conflict=false" >> "$GITHUB_OUTPUT"

                # Abort merge if in progress
                if [ -f .git/MERGE_HEAD ]; then
                  git merge --abort
                fi

                # Log error details
                echo "‚ùå Merge failed but no conflicts detected"
                echo "Merge output:"
                cat /tmp/merge_output.txt

                echo "Git status:"
                git status --porcelain

                # Fail the workflow - this is not a conflict, it's an error
                echo "::error::Merge with origin/main failed without conflicts. This may indicate a git error, network issue, or other problem. See logs for details."
                exit 1
              fi
            else
              echo "has-conflict=false" >> "$GITHUB_OUTPUT"
              git push origin HEAD
              echo "‚úÖ Successfully merged and pushed"
            fi
          else
            echo "has-conflict=false" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Already up to date with main"
          fi

      - name: Add conflict label if needed
        if: steps.sync.outputs.has-conflict == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          gh pr edit "${{ needs.validate.outputs.pr-number }}" \
            --repo "${{ github.repository }}" \
            --add-label "tdd-automation:had-conflict"

          # Disable auto-merge until human reviews conflict resolution
          gh pr merge "${{ needs.validate.outputs.pr-number }}" \
            --repo "${{ github.repository }}" --disable-auto || true

      - name: Configure agent
        id: agent-config
        env:
          AGENT_TYPE: ${{ needs.validate.outputs.agent-type }}
          HAS_CONFLICT: ${{ steps.sync.outputs.has-conflict }}
          CONFLICT_FILES: ${{ steps.sync.outputs.conflict-files }}
          SPEC_ID: ${{ needs.validate.outputs.spec-id }}
          SPEC_FILE: ${{ needs.validate.outputs.spec-file }}
          ORIGINAL_COMMENT: ${{ github.event.comment.body }}
        run: |
          # Configure claude_args based on agent type
          # See: docs/development/tdd-automation-pipeline.md#agent-configurations

          if [ "$AGENT_TYPE" = "codebase-refactor-auditor" ]; then
            ALLOWED_TOOLS="Bash,Read,Write,Edit,Glob,Grep,Task,TodoWrite,LSP"
            DISALLOWED_TOOLS="WebFetch,WebSearch,Skill,AskUserQuestion,NotebookEdit"
            MAX_TURNS=40
          else
            # Default: e2e-test-fixer
            ALLOWED_TOOLS="Bash,Read,Write,Edit,Glob,Grep,Task,TodoWrite,LSP,Skill"
            DISALLOWED_TOOLS="WebFetch,WebSearch,AskUserQuestion,NotebookEdit"
            MAX_TURNS=50
          fi

          # Build claude_args for the action
          CLAUDE_ARGS="--max-turns $MAX_TURNS --allowedTools \"$ALLOWED_TOOLS\" --disallowedTools \"$DISALLOWED_TOOLS\""
          echo "claude-args=$CLAUDE_ARGS" >> "$GITHUB_OUTPUT"

          # Generate prompt using TypeScript (replaces 85+ lines of bash template logic)
          # CRITICAL: Must explicitly instruct Claude Code to invoke Task tool with subagent_type
          # Why: Agents are not activated by text instructions alone. They must be explicitly
          # invoked via the Task tool for their specialized system prompts and behaviors to activate.
          # Tool restrictions (--allowedTools) apply to the base assistant, not automatically to agents.
          agent_type="$AGENT_TYPE" \
          spec_id="$SPEC_ID" \
          spec_file="$SPEC_FILE" \
          has_conflict="$HAS_CONFLICT" \
          conflict_files="$CONFLICT_FILES" \
          bun run scripts/tdd-automation/workflows/claude-code/generate-prompt.ts > /tmp/claude_prompt.txt

          # Store prompt for action
          PROMPT=$(cat /tmp/claude_prompt.txt)
          echo "prompt<<EOF" >> "$GITHUB_OUTPUT"
          echo "$PROMPT" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Run Claude Code Action
        id: claude-code
        uses: anthropics/claude-code-action@v1
        timeout-minutes: ${{ fromJSON(needs.validate.outputs.timeout) || 45 }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: ${{ steps.agent-config.outputs.prompt }}
          claude_args: ${{ steps.agent-config.outputs.claude-args }} --max-budget-usd 5.00
          track_progress: true
          use_sticky_comment: true

      - name: Parse Claude Code Result
        id: parse-result
        if: always()
        env:
          EXECUTION_FILE: ${{ steps.claude-code.outputs.execution_file }}
          CONCLUSION: ${{ steps.claude-code.outputs.conclusion }}
        run: |
          # Parse Claude Code execution result
          # Output structure: { type: "result", subtype: "success" | "error_max_turns" | "error_max_budget_usd" | "error_during_execution" | "error_max_structured_output_retries" }

          RESULT_SUBTYPE=""
          ERROR_MESSAGE=""

          if [ "$CONCLUSION" = "success" ]; then
            RESULT_SUBTYPE="success"
            echo "result-subtype=success" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Claude Code execution succeeded"
            exit 0
          fi

          if [ -f "$EXECUTION_FILE" ]; then
            # Extract result message from execution file
            RESULT_JSON=$(jq -r '.[] | select(.type == "result")' "$EXECUTION_FILE" 2>/dev/null || echo "{}")
            RESULT_SUBTYPE=$(echo "$RESULT_JSON" | jq -r '.subtype // "unknown"')
            ERROR_MESSAGE=$(echo "$RESULT_JSON" | jq -r '.errors // [] | join(", ")' 2>/dev/null || echo "")

            echo "result-subtype=$RESULT_SUBTYPE" >> "$GITHUB_OUTPUT"
            echo "error-message=$ERROR_MESSAGE" >> "$GITHUB_OUTPUT"
            echo "üìä Result subtype: $RESULT_SUBTYPE"
            [ -n "$ERROR_MESSAGE" ] && echo "‚ö†Ô∏è Error message: $ERROR_MESSAGE"
          else
            echo "result-subtype=unknown" >> "$GITHUB_OUTPUT"
            echo "error-message=Execution file not found" >> "$GITHUB_OUTPUT"
            echo "‚ùå No execution file found"
          fi

      - name: Categorize Error Type
        id: categorize-error
        if: steps.parse-result.outputs.result-subtype != 'success'
        env:
          RESULT_SUBTYPE: ${{ steps.parse-result.outputs.result-subtype }}
          ERROR_MESSAGE: ${{ steps.parse-result.outputs.error-message }}
        run: |
          # Categorize error based on subtype and message patterns
          # Categories: transient (retry), persistent (close PR), unknown (retry once)

          ERROR_CATEGORY="unknown"
          SHOULD_RETRY="false"

          case "$RESULT_SUBTYPE" in
            error_max_turns)
              ERROR_CATEGORY="max_turns"
              echo "‚ùå Max turns exceeded (50 turns) - spec too complex"
              ;;
            error_max_budget_usd)
              ERROR_CATEGORY="max_budget"
              echo "‚ùå Per-run budget exceeded ($5.00 limit)"
              ;;
            error_max_structured_output_retries)
              ERROR_CATEGORY="structured_output_retries"
              SHOULD_RETRY="true"
              echo "‚ö†Ô∏è Structured output retries exceeded - will retry once"
              ;;
            error_during_execution)
              # Pattern matching for transient vs persistent errors
              if echo "$ERROR_MESSAGE" | grep -qE "timeout|ETIMEDOUT|ECONNREFUSED|network|429|502|503|504|out of memory|ENOMEM"; then
                ERROR_CATEGORY="transient"
                SHOULD_RETRY="true"
                echo "‚ö†Ô∏è Transient error detected - will retry with backoff"
              elif echo "$ERROR_MESSAGE" | grep -qE "SyntaxError|TypeError|ReferenceError|Cannot find module|ENOENT|parse error"; then
                ERROR_CATEGORY="persistent"
                echo "‚ùå Persistent error detected - requires manual intervention"
              else
                ERROR_CATEGORY="unknown_execution"
                SHOULD_RETRY="true"
                echo "‚ö†Ô∏è Unknown execution error - will retry once"
              fi
              ;;
            unknown)
              ERROR_CATEGORY="unknown"
              echo "‚ùå Unknown error - no result message"
              ;;
            *)
              ERROR_CATEGORY="unknown"
              echo "‚ùå Unknown error subtype: $RESULT_SUBTYPE"
              ;;
          esac

          echo "error-category=$ERROR_CATEGORY" >> "$GITHUB_OUTPUT"
          echo "should-retry=$SHOULD_RETRY" >> "$GITHUB_OUTPUT"
          echo "üìã Error category: $ERROR_CATEGORY (retry: $SHOULD_RETRY)"

      - name: Route by Error Type
        if: steps.parse-result.outputs.result-subtype != 'success'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ needs.validate.outputs.pr-number }}
          ERROR_CATEGORY: ${{ steps.categorize-error.outputs.error-category }}
          SHOULD_RETRY: ${{ steps.categorize-error.outputs.should-retry }}
          ERROR_MESSAGE: ${{ steps.parse-result.outputs.error-message }}
          SPEC_ID: ${{ needs.validate.outputs.spec-id }}
          SPEC_FILE: ${{ needs.validate.outputs.spec-file }}
        run: |
          # Route based on error category

          if [ "$SHOULD_RETRY" = "true" ]; then
            echo "üîÑ Retryable error - triggering automatic retry with exponential backoff..."

            # Fetch PR title to extract attempt number
            PR_TITLE=$(gh pr view "$PR_NUMBER" --repo "${{ github.repository }}" --json title --jq '.title')
            echo "PR Title: $PR_TITLE"

            # Extract attempt number from PR title (format: "Implement SPEC-ID | Attempt X/Y")
            CURRENT_ATTEMPT=$(echo "$PR_TITLE" | grep -oP 'Attempt\s+\K\d+' || echo "1")
            MAX_ATTEMPTS=$(echo "$PR_TITLE" | grep -oP 'Attempt\s+\d+/\K\d+' || echo "5")

            echo "üìä Current attempt: $CURRENT_ATTEMPT/$MAX_ATTEMPTS"

            # Guard: Don't retry if already at max attempts
            if [ "$CURRENT_ATTEMPT" -ge "$MAX_ATTEMPTS" ]; then
              echo "‚ö†Ô∏è Already at max attempts ($MAX_ATTEMPTS) - skipping automatic retry"
              echo "Manual intervention required (will be handled by non-retriable error flow)"
              SHOULD_RETRY="false"  # Override to trigger manual intervention flow
            else
              # Calculate exponential backoff: delay = 60 * (2^(attempt-1) - 1)
              # Attempt 1: 0s (immediate)
              # Attempt 2: 60s (1 min)
              # Attempt 3: 180s (3 min)
              # Attempt 4: 420s (7 min)
              # Attempt 5: 900s (15 min)
              BACKOFF_SECONDS=$((60 * ((1 << (CURRENT_ATTEMPT - 1)) - 1)))

              echo "üìä Automatic Retry Configuration:"
              echo "   Error Category: $ERROR_CATEGORY"
              echo "   Current Attempt: $CURRENT_ATTEMPT/$MAX_ATTEMPTS"
              echo "   Backoff Delay: ${BACKOFF_SECONDS}s"

              # Post status comment (non-blocking - informational)
              {
                echo "‚ö†Ô∏è **Claude Code Execution Failed (Retryable Error)**"
                echo ""
                echo "**Error Category**: \`$ERROR_CATEGORY\`"
                echo "**Error Message**:"
                echo "\`\`\`"
                echo "$ERROR_MESSAGE"
                echo "\`\`\`"
                echo ""
                echo "**Attempt**: $CURRENT_ATTEMPT/$MAX_ATTEMPTS"
                echo "**Backoff Delay**: ${BACKOFF_SECONDS}s"
                echo ""
                echo "**Automatic Recovery**: Retrying after exponential backoff..."
                echo ""
                if [ "$BACKOFF_SECONDS" -gt 0 ]; then
                  echo "‚è≥ Next retry in: ${BACKOFF_SECONDS}s"
                else
                  echo "‚ö° Retrying immediately (first failure)"
                fi
                echo ""
                echo "---"
                echo "_Automated retry triggered by TDD pipeline error handling_"
              } > /tmp/retry_status.md

              gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/retry_status.md

              # Sleep for exponential backoff (max 15 minutes for attempt 5)
              if [ "$BACKOFF_SECONDS" -gt 0 ]; then
                echo "‚è≥ Sleeping for ${BACKOFF_SECONDS}s..."
                sleep "$BACKOFF_SECONDS"
              else
                echo "‚ö° No backoff delay (immediate retry)"
              fi

              # Post @claude comment to trigger claude-code.yml via issue_comment event
              NEXT_ATTEMPT=$((CURRENT_ATTEMPT + 1))
              {
                echo "@claude"
                echo ""
                echo "Spec: \`$SPEC_ID\`"
                echo "File: \`$SPEC_FILE\`"
                echo ""
                echo "_Automatic retry after transient error (Attempt $NEXT_ATTEMPT/$MAX_ATTEMPTS)_"
              } > /tmp/claude_retry.md

              gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/claude_retry.md

              echo "‚úÖ Automatic retry triggered - claude-code.yml will execute via issue_comment event"
              exit 0
            fi
          fi

          # Non-retriable errors: close PR with appropriate label
          case "$ERROR_CATEGORY" in
            max_turns)
              LABEL="tdd-automation:spec-review-needed"
              REASON="Spec too complex (exceeded 50 conversation turns)"
              MESSAGE="This spec requires too many steps to implement. Consider breaking it into smaller specs or simplifying the requirements."
              ;;
            max_budget)
              LABEL="tdd-automation:budget-exceeded"
              REASON="Per-run budget exceeded (\$5.00 limit)"
              MESSAGE="This execution exceeded the \$5.00 per-run budget limit. The spec may be too complex or require optimization."
              ;;
            persistent)
              LABEL="tdd-automation:manual-intervention"
              REASON="Persistent execution error"
              MESSAGE="Claude Code encountered a persistent error that cannot be resolved automatically: $ERROR_MESSAGE"
              ;;
            *)
              LABEL="tdd-automation:manual-intervention"
              REASON="Unknown error"
              MESSAGE="Claude Code failed with an unknown error. Manual review required."
              ;;
          esac

          echo "‚ùå Closing PR with label: $LABEL"

          # Add label
          gh pr edit "$PR_NUMBER" --repo "${{ github.repository }}" --add-label "$LABEL"

          # Post closing comment
          {
            echo "‚ùå **TDD Automation Failed: $REASON**"
            echo ""
            echo "**Error Category**: \`$ERROR_CATEGORY\`"
            echo "**Spec ID**: \`$SPEC_ID\`"
            echo ""
            echo "**Reason**: $MESSAGE"
            echo ""
            echo "**What This Means**:"
            echo "- This PR cannot be automatically implemented"
            echo "- Manual intervention is required"
            echo ""
            echo "**Recovery Options** (via workflow_dispatch in \`.github/workflows/recovery.yml\`):"
            echo "- \`retry-claude-code\`: Post @claude comment to retry (if error might be transient)"
            echo "- \`reset-attempt-counter\`: Reset attempt counter to 1/5 (if retrying after fixing issue)"
            echo "- \`mark-for-spec-review\`: Close PR and add spec-review-needed label"
            echo "- \`close-and-reset-spec\`: Close PR and create new PR to add .fixme() back to spec"
            echo ""
            echo "---"
            echo "_Automated closure by TDD pipeline error handling_"
          } > /tmp/close_comment.md

          gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/close_comment.md

          # Close PR
          gh pr close "$PR_NUMBER" --repo "${{ github.repository }}" --comment "Closed due to: $REASON"

          echo "‚úÖ PR closed with label $LABEL"

      - name: Handle conflict resolution notice
        if: steps.sync.outputs.has-conflict == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          PR_NUMBER="${{ needs.validate.outputs.pr-number }}"

          # Post conflict review notice
          {
            echo "‚ö†Ô∏è **Merge Conflict Resolution Notice**"
            echo ""
            echo "This PR had merge conflicts that were auto-resolved by Claude Code."
            echo ""
            echo "**Human review required before merge.**"
            echo ""
            echo "Please verify:"
            echo "- [ ] Conflict resolution is correct"
            echo "- [ ] Tests pass"
            echo "- [ ] Code logic makes sense"
            echo ""
            echo "After review, re-enable auto-merge or merge manually."
          } > /tmp/conflict_comment.txt

          gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/conflict_comment.txt
