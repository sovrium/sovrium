name: Claude Code

on:
  issue_comment:
    types: [created]

# Required permissions for Claude Code Action
permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read
  id-token: write  # Required for OIDC authentication

jobs:
  # ============================================================================
  # JOB 1: VALIDATE TRIGGER
  #
  # Pre-conditions:
  # 1. Comment author is thomas-jeanneau (TDD bot account)
  # 2. PR has tdd-automation label
  # 3. Credit limits not exceeded
  # ============================================================================
  validate:
    name: Validate Trigger
    if: |
      github.event.issue.pull_request &&
      startsWith(github.event.comment.body, '@claude') &&
      github.event.comment.user.login == 'thomas-jeanneau'
    runs-on: ubuntu-latest
    outputs:
      is-valid: ${{ steps.validate.outputs.is-valid }}
      pr-number: ${{ github.event.issue.number }}
      pr-branch: ${{ steps.pr-info.outputs.branch }}
      agent-type: ${{ steps.parse.outputs.agent-type }}
      spec-file: ${{ steps.parse.outputs.spec-file }}
      spec-id: ${{ steps.parse.outputs.spec-id }}
      timeout: ${{ steps.config.outputs.timeout }}
    steps:
      - name: Get PR info
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          PR_DATA=$(gh pr view "${{ github.event.issue.number }}" --repo "${{ github.repository }}" --json headRefName,labels)
          BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
          HAS_LABEL=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "tdd-automation" || echo "0")
          IS_TDD_BRANCH=$(echo "$BRANCH" | grep -c "^tdd/" || echo "0")

          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

          if [ "$HAS_LABEL" -gt 0 ] || [ "$IS_TDD_BRANCH" -gt 0 ]; then
            echo "is-tdd=true" >> "$GITHUB_OUTPUT"
          else
            echo "is-tdd=false" >> "$GITHUB_OUTPUT"
            echo "âš ï¸ Not a TDD PR - skipping"
          fi

      - name: Parse @claude comment
        id: parse
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          # Extract agent type from comment
          if echo "$COMMENT_BODY" | grep -q "e2e-test-fixer"; then
            echo "agent-type=e2e-test-fixer" >> "$GITHUB_OUTPUT"
          elif echo "$COMMENT_BODY" | grep -q "codebase-refactor-auditor"; then
            echo "agent-type=codebase-refactor-auditor" >> "$GITHUB_OUTPUT"
          else
            echo "agent-type=e2e-test-fixer" >> "$GITHUB_OUTPUT"  # Default
          fi

          # Extract spec file if mentioned (format: `specs/...`)
          # shellcheck disable=SC2016
          SPEC_FILE=$(echo "$COMMENT_BODY" | grep -oP 'File: `\K[^`]+' | head -1 || echo "")
          if [ -z "$SPEC_FILE" ]; then
            SPEC_FILE=$(echo "$COMMENT_BODY" | grep -oP '`specs/[^`]+`' | tr -d '`' | head -1 || echo "")
          fi
          echo "spec-file=$SPEC_FILE" >> "$GITHUB_OUTPUT"

          # Extract spec ID (format: Spec: `SPEC-ID`)
          SPEC_ID=$(echo "$COMMENT_BODY" | grep -oP 'Spec: `\K[^`]+' | head -1 || echo "")
          echo "spec-id=$SPEC_ID" >> "$GITHUB_OUTPUT"

          echo "ðŸ“‹ Parsed: agent=${{ steps.parse.outputs.agent-type || 'e2e-test-fixer' }}, spec-file=$SPEC_FILE, spec-id=$SPEC_ID"

      - name: Check credit limits
        id: credits
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          # Secondary credit check (defense in depth with pr-creator.yml)
          # Cost limits: $100/day, $500/week (see docs/development/tdd-automation-pipeline.md)

          # Query successful claude-code.yml runs with full details from past 7 days
          gh run list --repo "${{ github.repository }}" --workflow="claude-code.yml" \
            --created ">$(date -u -d '7 days ago' +%Y-%m-%dT%H:%M:%SZ)" \
            --json databaseId,conclusion,createdAt,displayTitle,status --limit 100 > /tmp/all_runs.json

          # Filter successful runs
          jq '[.[] | select(.conclusion == "success")]' /tmp/all_runs.json > /tmp/successful_runs.json

          # Calculate daily runs (past 24 hours)
          DAILY_CUTOFF=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%SZ)
          DAILY_RUNS=$(jq "[.[] | select(.createdAt > \"$DAILY_CUTOFF\")] | length" /tmp/successful_runs.json)
          WEEKLY_RUNS=$(jq 'length' /tmp/successful_runs.json)

          # Extract actual costs from Claude Code execution results
          DAILY_TOTAL=0
          WEEKLY_TOTAL=0
          DAILY_RUNS_COUNT=0
          WEEKLY_RUNS_COUNT=0

          echo "ðŸ“Š Extracting actual costs from workflow logs..."

          # Process each successful run
          while IFS='|' read -r run_id created_at; do
            echo "  Fetching logs for run $run_id..."

            # Fetch workflow logs and extract cost
            LOGS=$(gh run view "$run_id" --repo "${{ github.repository }}" --log 2>/dev/null || echo "")

            # Try pattern 1: "total_cost_usd": <number> (Claude Code result JSON)
            COST=$(echo "$LOGS" | grep -oP '"total_cost_usd":\s*\K[0-9]+(\.[0-9]+)?' | head -1 || echo "")

            # Try pattern 2: Total cost: $X.XX (legacy log format)
            if [ -z "$COST" ]; then
              COST=$(echo "$LOGS" | grep -oP 'Total cost: \$\K[0-9]+(\.[0-9]+)?' | head -1 || echo "")
            fi

            # Try pattern 3: Cost: $X.XX (alternative short format)
            if [ -z "$COST" ]; then
              COST=$(echo "$LOGS" | grep -oP 'Cost: \$\K[0-9]+(\.[0-9]+)?' | head -1 || echo "")
            fi

            # Try pattern 4: Session cost: X.XX USD (legacy format)
            if [ -z "$COST" ]; then
              COST=$(echo "$LOGS" | grep -oP 'Session cost: \K[0-9]+(\.[0-9]+)? USD' | sed 's/ USD//' | head -1 || echo "")
            fi

            # Fallback: $15 estimate if no pattern matched
            if [ -z "$COST" ]; then
              COST="15.00"
              echo "    âš ï¸ No cost found in logs, using fallback estimate: \$15.00"
            else
              echo "    âœ… Actual cost extracted: \$$COST"
            fi

            # Add to weekly total
            WEEKLY_TOTAL=$(echo "$WEEKLY_TOTAL + $COST" | bc)
            WEEKLY_RUNS_COUNT=$((WEEKLY_RUNS_COUNT + 1))

            # Add to daily total if within 24h
            if [[ "$created_at" > "$DAILY_CUTOFF" ]]; then
              DAILY_TOTAL=$(echo "$DAILY_TOTAL + $COST" | bc)
              DAILY_RUNS_COUNT=$((DAILY_RUNS_COUNT + 1))
            fi
          done < <(jq -r '.[] | "\(.databaseId)|\(.createdAt)"' /tmp/successful_runs.json)

          # Round totals to 2 decimal places
          ACTUAL_DAILY=$(printf "%.2f" "$DAILY_TOTAL")
          ACTUAL_WEEKLY=$(printf "%.2f" "$WEEKLY_TOTAL")

          # Convert to integers for comparison (multiply by 100 to avoid float issues)
          ACTUAL_DAILY_CENTS=$(printf "%.0f" "$(echo "$ACTUAL_DAILY * 100" | bc)")
          ACTUAL_WEEKLY_CENTS=$(printf "%.0f" "$(echo "$ACTUAL_WEEKLY * 100" | bc)")

          # Calculate limits (in cents for comparison)
          DAILY_LIMIT=100
          WEEKLY_LIMIT=500
          DAILY_WARNING=80
          WEEKLY_WARNING=400
          DAILY_LIMIT_CENTS=$((DAILY_LIMIT * 100))
          WEEKLY_LIMIT_CENTS=$((WEEKLY_LIMIT * 100))

          # Calculate remaining budget
          DAILY_REMAINING=$(echo "$DAILY_LIMIT - $ACTUAL_DAILY" | bc)
          WEEKLY_REMAINING=$(echo "$WEEKLY_LIMIT - $ACTUAL_WEEKLY" | bc)

          # Calculate usage percentages
          DAILY_PERCENT=$(printf "%.0f" "$(echo "$ACTUAL_DAILY * 100 / $DAILY_LIMIT" | bc -l)")
          WEEKLY_PERCENT=$(printf "%.0f" "$(echo "$ACTUAL_WEEKLY * 100 / $WEEKLY_LIMIT" | bc -l)")

          # Time until reset
          HOURS_UNTIL_DAILY_RESET=$(( 24 - $(date -u +%H) ))
          DAYS_UNTIL_WEEKLY_RESET=$(( 7 - $(date -u +%u) ))

          # Store all metrics for comment
          echo "daily-runs=$DAILY_RUNS_COUNT" >> "$GITHUB_OUTPUT"
          echo "weekly-runs=$WEEKLY_RUNS_COUNT" >> "$GITHUB_OUTPUT"
          echo "actual-daily=$ACTUAL_DAILY" >> "$GITHUB_OUTPUT"
          echo "actual-weekly=$ACTUAL_WEEKLY" >> "$GITHUB_OUTPUT"
          echo "daily-limit=$DAILY_LIMIT" >> "$GITHUB_OUTPUT"
          echo "weekly-limit=$WEEKLY_LIMIT" >> "$GITHUB_OUTPUT"
          echo "daily-remaining=$DAILY_REMAINING" >> "$GITHUB_OUTPUT"
          echo "weekly-remaining=$WEEKLY_REMAINING" >> "$GITHUB_OUTPUT"
          echo "daily-percent=$DAILY_PERCENT" >> "$GITHUB_OUTPUT"
          echo "weekly-percent=$WEEKLY_PERCENT" >> "$GITHUB_OUTPUT"
          echo "hours-until-daily-reset=$HOURS_UNTIL_DAILY_RESET" >> "$GITHUB_OUTPUT"
          echo "days-until-weekly-reset=$DAYS_UNTIL_WEEKLY_RESET" >> "$GITHUB_OUTPUT"

          echo "ðŸ“Š Credit Usage Metrics (Actual Costs):"
          echo "  Daily:  \$${ACTUAL_DAILY}/\$${DAILY_LIMIT} USD ($DAILY_PERCENT%) - $DAILY_RUNS_COUNT runs - Reset in ${HOURS_UNTIL_DAILY_RESET}h"
          echo "  Weekly: \$${ACTUAL_WEEKLY}/\$${WEEKLY_LIMIT} USD ($WEEKLY_PERCENT%) - $WEEKLY_RUNS_COUNT runs - Reset in ${DAYS_UNTIL_WEEKLY_RESET}d"

          # Check if limits exceeded (use cent comparison to avoid float issues)
          if [ "$ACTUAL_DAILY_CENTS" -ge "$DAILY_LIMIT_CENTS" ] || [ "$ACTUAL_WEEKLY_CENTS" -ge "$WEEKLY_LIMIT_CENTS" ]; then
            echo "credits-ok=false" >> "$GITHUB_OUTPUT"
            if [ "$ACTUAL_DAILY_CENTS" -ge "$DAILY_LIMIT_CENTS" ]; then
              echo "limit-type=daily" >> "$GITHUB_OUTPUT"
              echo "â›” Daily credit limit (\$$DAILY_LIMIT) reached"
            else
              echo "limit-type=weekly" >> "$GITHUB_OUTPUT"
              echo "â›” Weekly credit limit (\$$WEEKLY_LIMIT) reached"
            fi
          else
            echo "credits-ok=true" >> "$GITHUB_OUTPUT"
            echo "limit-type=none" >> "$GITHUB_OUTPUT"
            echo "âœ… Credits OK"
          fi

      - name: Setup Bun (for credit comment script)
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            scripts/tdd-automation/workflows/claude-code/
            package.json

      - name: Post credit usage comment (always)
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          # Pass credit metrics as environment variables
          credits-ok: ${{ steps.credits.outputs.credits-ok }}
          limit-type: ${{ steps.credits.outputs.limit-type }}
          daily-runs: ${{ steps.credits.outputs.daily-runs }}
          weekly-runs: ${{ steps.credits.outputs.weekly-runs }}
          actual-daily: ${{ steps.credits.outputs.actual-daily }}
          actual-weekly: ${{ steps.credits.outputs.actual-weekly }}
          daily-limit: ${{ steps.credits.outputs.daily-limit }}
          weekly-limit: ${{ steps.credits.outputs.weekly-limit }}
          daily-remaining: ${{ steps.credits.outputs.daily-remaining }}
          weekly-remaining: ${{ steps.credits.outputs.weekly-remaining }}
          daily-percent: ${{ steps.credits.outputs.daily-percent }}
          weekly-percent: ${{ steps.credits.outputs.weekly-percent }}
          hours-until-daily-reset: ${{ steps.credits.outputs.hours-until-daily-reset }}
          days-until-weekly-reset: ${{ steps.credits.outputs.days-until-weekly-reset }}
        run: |
          # Generate credit usage comment using TypeScript (replaces 60 lines of bash)
          bun run scripts/tdd-automation/workflows/claude-code/generate-credit-comment.ts > /tmp/credit_usage.md

          # Post comment (always)
          gh pr comment "${{ github.event.issue.number }}" --repo "${{ github.repository }}" --body-file /tmp/credit_usage.md
          echo "âœ… Credit usage comment posted"

      - name: Validate all conditions
        id: validate
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          IS_TDD="${{ steps.pr-info.outputs.is-tdd }}"
          CREDITS_OK="${{ steps.credits.outputs.credits-ok }}"

          if [ "$IS_TDD" != "true" ]; then
            echo "is-valid=false" >> "$GITHUB_OUTPUT"
            echo "âŒ Validation failed: Not a TDD PR"
            exit 0
          fi

          if [ "$CREDITS_OK" != "true" ]; then
            echo "is-valid=false" >> "$GITHUB_OUTPUT"
            echo "â›” Credit limit reached - execution blocked (comment already posted)"
            exit 0
          fi

          echo "is-valid=true" >> "$GITHUB_OUTPUT"
          echo "âœ… All validation checks passed"

      - uses: actions/checkout@v4
        if: steps.validate.outputs.is-valid == 'true'
        with:
          ref: ${{ steps.pr-info.outputs.branch }}

      - name: Extract per-spec timeout
        id: config
        if: steps.validate.outputs.is-valid == 'true'
        run: |
          SPEC_FILE="${{ steps.parse.outputs.spec-file }}"
          DEFAULT_TIMEOUT=45

          if [ -n "$SPEC_FILE" ] && [ -f "$SPEC_FILE" ]; then
            # Extract @tdd-timeout annotation if present
            TIMEOUT=$(grep -oP '@tdd-timeout \K[0-9]+' "$SPEC_FILE" 2>/dev/null || echo "$DEFAULT_TIMEOUT")
          else
            TIMEOUT=$DEFAULT_TIMEOUT
          fi

          echo "timeout=$TIMEOUT" >> "$GITHUB_OUTPUT"
          echo "â±ï¸ Timeout: ${TIMEOUT} minutes"

  # ============================================================================
  # JOB 2: EXECUTE CLAUDE CODE
  #
  # Steps:
  # 1. Checkout PR branch
  # 2. Sync with main (detect conflicts)
  # 3. Configure agent based on failure type
  # 4. Run anthropics/claude-code-action@v1
  # 5. Push changes (handled by action)
  # ============================================================================
  execute:
    name: Execute Claude Code
    needs: validate
    if: needs.validate.outputs.is-valid == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: ${{ fromJSON(needs.validate.outputs.timeout) || 45 }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate.outputs.pr-branch }}
          token: ${{ secrets.GH_PAT_WORKFLOW }}
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Sync with main branch
        id: sync
        run: |
          git fetch origin main

          BEHIND=$(git rev-list --count HEAD..origin/main)
          echo "behind=$BEHIND" >> "$GITHUB_OUTPUT"

          if [ "$BEHIND" -gt 0 ]; then
            echo "ðŸ“¥ Main branch has $BEHIND new commits, merging..."

            if ! git merge origin/main --no-edit 2>&1 | tee /tmp/merge_output.txt; then
              echo "âš ï¸ Merge failed. Analyzing failure type..."

              # Check for actual merge conflicts using git status
              # Conflict markers: UU (both modified), AA (both added), DD (both deleted),
              # AU (added by us), UA (added by them), DU (deleted by us), UD (deleted by them)
              if git status --porcelain | grep -q '^UU\|^AA\|^DD\|^AU\|^UA\|^DU\|^UD'; then
                # Actual conflicts detected
                echo "has-conflict=true" >> "$GITHUB_OUTPUT"
                git diff --name-only --diff-filter=U > /tmp/conflicted_files.txt
                CONFLICT_FILES=$(cat /tmp/conflicted_files.txt | tr '\n' ', ' | sed 's/,$//')
                echo "conflict-files=$CONFLICT_FILES" >> "$GITHUB_OUTPUT"

                # Abort merge if in progress
                if [ -f .git/MERGE_HEAD ]; then
                  git merge --abort
                fi

                echo "âš ï¸ Merge conflict detected in: $CONFLICT_FILES"
                echo "ðŸ“ Conflict markers found in git status - requires manual resolution"
              else
                # No conflicts - merge failed for other reasons
                echo "has-conflict=false" >> "$GITHUB_OUTPUT"

                # Abort merge if in progress
                if [ -f .git/MERGE_HEAD ]; then
                  git merge --abort
                fi

                # Log error details
                echo "âŒ Merge failed but no conflicts detected"
                echo "Merge output:"
                cat /tmp/merge_output.txt

                echo "Git status:"
                git status --porcelain

                # Fail the workflow - this is not a conflict, it's an error
                echo "::error::Merge with origin/main failed without conflicts. This may indicate a git error, network issue, or other problem. See logs for details."
                exit 1
              fi
            else
              echo "has-conflict=false" >> "$GITHUB_OUTPUT"
              git push origin HEAD
              echo "âœ… Successfully merged and pushed"
            fi
          else
            echo "has-conflict=false" >> "$GITHUB_OUTPUT"
            echo "âœ… Already up to date with main"
          fi

      - name: Add conflict label if needed
        if: steps.sync.outputs.has-conflict == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          gh pr edit "${{ needs.validate.outputs.pr-number }}" \
            --repo "${{ github.repository }}" \
            --add-label "tdd-automation:manual-intervention"

          # Disable auto-merge until human reviews conflict resolution
          gh pr merge "${{ needs.validate.outputs.pr-number }}" \
            --repo "${{ github.repository }}" --disable-auto || true

      - name: Configure agent
        id: agent-config
        env:
          AGENT_TYPE: ${{ needs.validate.outputs.agent-type }}
          HAS_CONFLICT: ${{ steps.sync.outputs.has-conflict }}
          CONFLICT_FILES: ${{ steps.sync.outputs.conflict-files }}
          SPEC_ID: ${{ needs.validate.outputs.spec-id }}
          SPEC_FILE: ${{ needs.validate.outputs.spec-file }}
          ORIGINAL_COMMENT: ${{ github.event.comment.body }}
        run: |
          # Configure claude_args based on agent type
          # See: docs/development/tdd-automation-pipeline.md#agent-configurations

          if [ "$AGENT_TYPE" = "codebase-refactor-auditor" ]; then
            ALLOWED_TOOLS="Bash,Read,Write,Edit,Glob,Grep,Task,TodoWrite,LSP"
            DISALLOWED_TOOLS="WebFetch,WebSearch,Skill,AskUserQuestion,NotebookEdit"
            MAX_TURNS=40
          else
            # Default: e2e-test-fixer
            ALLOWED_TOOLS="Bash,Read,Write,Edit,Glob,Grep,Task,TodoWrite,LSP,Skill"
            DISALLOWED_TOOLS="WebFetch,WebSearch,AskUserQuestion,NotebookEdit"
            MAX_TURNS=50
          fi

          # Build claude_args for the action
          CLAUDE_ARGS="--max-turns $MAX_TURNS --allowedTools \"$ALLOWED_TOOLS\" --disallowedTools \"$DISALLOWED_TOOLS\""
          echo "claude-args=$CLAUDE_ARGS" >> "$GITHUB_OUTPUT"

          # Generate prompt using TypeScript (replaces 85+ lines of bash template logic)
          # CRITICAL: Must explicitly instruct Claude Code to invoke Task tool with subagent_type
          # Why: Agents are not activated by text instructions alone. They must be explicitly
          # invoked via the Task tool for their specialized system prompts and behaviors to activate.
          # Tool restrictions (--allowedTools) apply to the base assistant, not automatically to agents.
          agent_type="$AGENT_TYPE" \
          spec_id="$SPEC_ID" \
          spec_file="$SPEC_FILE" \
          has_conflict="$HAS_CONFLICT" \
          conflict_files="$CONFLICT_FILES" \
          bun run scripts/tdd-automation/workflows/claude-code/generate-prompt.ts > /tmp/claude_prompt.txt

          # Store prompt for action
          PROMPT=$(cat /tmp/claude_prompt.txt)
          echo "prompt<<EOF" >> "$GITHUB_OUTPUT"
          echo "$PROMPT" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Run Claude Code Action
        id: claude-code
        uses: anthropics/claude-code-action@v1
        timeout-minutes: ${{ fromJSON(needs.validate.outputs.timeout) || 45 }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: ${{ steps.agent-config.outputs.prompt }}
          claude_args: ${{ steps.agent-config.outputs.claude-args }} --max-budget-usd 5.00
          track_progress: true
          use_sticky_comment: true

      - name: Parse Claude Code Result
        id: parse-result
        if: always()
        env:
          EXECUTION_FILE: ${{ steps.claude-code.outputs.execution_file }}
          CONCLUSION: ${{ steps.claude-code.outputs.conclusion }}
        run: |
          # Parse Claude Code execution result
          # Output structure: { type: "result", subtype: "success" | "error_max_turns" | "error_max_budget_usd" | "error_during_execution" | "error_max_structured_output_retries" }

          RESULT_SUBTYPE=""
          ERROR_MESSAGE=""

          if [ "$CONCLUSION" = "success" ]; then
            RESULT_SUBTYPE="success"
            echo "result-subtype=success" >> "$GITHUB_OUTPUT"
            echo "âœ… Claude Code execution succeeded"
            exit 0
          fi

          if [ -f "$EXECUTION_FILE" ]; then
            # Extract result message from execution file
            RESULT_JSON=$(jq -r '.[] | select(.type == "result")' "$EXECUTION_FILE" 2>/dev/null || echo "{}")
            RESULT_SUBTYPE=$(echo "$RESULT_JSON" | jq -r '.subtype // "unknown"')
            ERROR_MESSAGE=$(echo "$RESULT_JSON" | jq -r '.errors // [] | join(", ")' 2>/dev/null || echo "")

            echo "result-subtype=$RESULT_SUBTYPE" >> "$GITHUB_OUTPUT"
            echo "error-message=$ERROR_MESSAGE" >> "$GITHUB_OUTPUT"
            echo "ðŸ“Š Result subtype: $RESULT_SUBTYPE"
            [ -n "$ERROR_MESSAGE" ] && echo "âš ï¸ Error message: $ERROR_MESSAGE"
          else
            echo "result-subtype=unknown" >> "$GITHUB_OUTPUT"
            echo "error-message=Execution file not found" >> "$GITHUB_OUTPUT"
            echo "âŒ No execution file found"
          fi

      - name: Extract Execution Metrics
        id: extract-metrics
        if: always()
        env:
          EXECUTION_FILE: ${{ steps.claude-code.outputs.execution_file }}
        run: |
          # Extract execution metrics from Claude Code result JSON
          # Metrics: duration_ms, num_turns, total_cost_usd

          if [ -f "$EXECUTION_FILE" ]; then
            RESULT_JSON=$(jq -r '.[] | select(.type == "result")' "$EXECUTION_FILE" 2>/dev/null || echo "{}")

            # Extract metrics with fallbacks
            DURATION_MS=$(echo "$RESULT_JSON" | jq -r '.duration_ms // 0')
            NUM_TURNS=$(echo "$RESULT_JSON" | jq -r '.num_turns // 0')
            TOTAL_COST=$(echo "$RESULT_JSON" | jq -r '.total_cost_usd // 0')

            # Convert duration to human-readable format (e.g., "10m 26s")
            DURATION_SECONDS=$((DURATION_MS / 1000))
            DURATION_MINUTES=$((DURATION_SECONDS / 60))
            DURATION_REMAINDER=$((DURATION_SECONDS % 60))
            DURATION_FORMATTED="${DURATION_MINUTES}m ${DURATION_REMAINDER}s"

            # Format cost to 2 decimal places
            COST_FORMATTED=$(printf "%.2f" "$TOTAL_COST")

            echo "duration-ms=$DURATION_MS" >> "$GITHUB_OUTPUT"
            echo "duration-formatted=$DURATION_FORMATTED" >> "$GITHUB_OUTPUT"
            echo "num-turns=$NUM_TURNS" >> "$GITHUB_OUTPUT"
            echo "total-cost=$COST_FORMATTED" >> "$GITHUB_OUTPUT"

            echo "ðŸ“Š Execution Metrics:"
            echo "   Duration: $DURATION_FORMATTED ($DURATION_MS ms)"
            echo "   Turns: $NUM_TURNS"
            echo "   Total Cost: \$$COST_FORMATTED"
          else
            echo "duration-ms=0" >> "$GITHUB_OUTPUT"
            echo "duration-formatted=N/A" >> "$GITHUB_OUTPUT"
            echo "num-turns=0" >> "$GITHUB_OUTPUT"
            echo "total-cost=0.00" >> "$GITHUB_OUTPUT"
            echo "âš ï¸ No execution file found - metrics unavailable"
          fi

      - name: Post Success Comment with Metrics
        if: steps.parse-result.outputs.result-subtype == 'success'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ needs.validate.outputs.pr-number }}
          DURATION: ${{ steps.extract-metrics.outputs.duration-formatted }}
          TURNS: ${{ steps.extract-metrics.outputs.num-turns }}
          COST: ${{ steps.extract-metrics.outputs.total-cost }}
        run: |
          # Post success comment with execution metrics
          {
            echo "âœ… **Claude Code Execution Succeeded**"
            echo ""
            echo "**Execution Metrics**:"
            echo "- **Duration**: $DURATION"
            echo "- **Turns**: $TURNS"
            echo "- **Total Cost**: \$$COST"
            echo ""
            echo "Changes pushed successfully. Tests will run next."
          } > /tmp/success_comment.md

          gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/success_comment.md
          echo "âœ… Success comment with metrics posted"

      - name: Handle Claude Code Error
        if: steps.parse-result.outputs.result-subtype != 'success'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ needs.validate.outputs.pr-number }}
          RESULT_SUBTYPE: ${{ steps.parse-result.outputs.result-subtype }}
          ERROR_MESSAGE: ${{ steps.parse-result.outputs.error-message }}
          SPEC_ID: ${{ needs.validate.outputs.spec-id }}
        run: |
          # Simplified error handling: ALL errors â†’ post comment â†’ add label â†’ close PR
          # No automatic retries - manual intervention required for all failures

          echo "âŒ Claude Code execution failed: $RESULT_SUBTYPE"

          # Add manual-intervention label
          gh pr edit "$PR_NUMBER" --repo "${{ github.repository }}" --add-label "tdd-automation:manual-intervention"

          # Post error comment with execution metrics
          {
            echo "âŒ **Claude Code Execution Failed**"
            echo ""
            echo "**Error Type**: \`$RESULT_SUBTYPE\`"
            echo "**Spec ID**: \`$SPEC_ID\`"
            echo ""
            echo "**Error Details**:"
            echo "\`\`\`"
            echo "$ERROR_MESSAGE"
            echo "\`\`\`"
            echo ""
            echo "**Execution Metrics**:"
            echo "- **Duration**: ${{ steps.extract-metrics.outputs.duration-formatted }}"
            echo "- **Turns**: ${{ steps.extract-metrics.outputs.num-turns }}"
            echo "- **Total Cost**: \$${{ steps.extract-metrics.outputs.total-cost }}"
            echo ""
            echo "**Recovery**:"
            echo "1. Review the error above"
            echo "2. Fix the spec or codebase issue"
            echo "3. Remove \`tdd-automation:manual-intervention\` label"
            echo "4. Post \`@claude\` comment to retry"
            echo ""
            echo "---"
            echo "_TDD Automation paused for this spec_"
          } > /tmp/error_comment.md

          gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/error_comment.md

          # Close PR
          gh pr close "$PR_NUMBER" --repo "${{ github.repository }}" --comment "Closed: Claude Code execution failed - manual intervention required"

          echo "âœ… Error handled - PR closed with manual-intervention label"
