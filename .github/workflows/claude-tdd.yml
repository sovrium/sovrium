name: Claude Code TDD

# This workflow handles all Claude Code execution with infrastructure-level retry logic
# It handles both automated queue processing and manual @claude mentions
# Infrastructure errors (EPERM, timeouts, crashes) are automatically retried up to 3 times

on:
  # Manual trigger: Process specific issue number with optional retry
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process'
        required: true
        type: number
      retry_attempt:
        description: 'Current retry attempt (1-3)'
        required: false
        type: number
        default: 1

  # Manual triggers: @claude mentions in issues/PRs (interactive use)
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

# Concurrency control: One run per issue/PR, queued not cancelled
# Groups runs by issue/PR number to prevent duplicate execution
# Note: claude[bot] comments are filtered in validate-context job (lines 80-98)
concurrency:
  group: claude-issue-${{ github.event.issue.number || github.event.pull_request.number || github.event.inputs.issue_number || 'default' }}
  cancel-in-progress: false

env:
  MAX_INFRASTRUCTURE_RETRIES: 3
  CLAUDE_TIMEOUT_MINUTES: 60

jobs:
  # Pre-check job: Validate context exists before running Claude Code
  # Prevents wasted resources when there's no spec to process
  validate-context:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      issues: read
    outputs:
      has_context: ${{ steps.check.outputs.has_context }}
      issue_number: ${{ steps.check.outputs.issue_number }}
      issue_body: ${{ steps.check.outputs.issue_body }}
    steps:
      - name: Check for valid context
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
          # Security: Use env vars for untrusted user input to prevent code injection
          EVENT_COMMENT_BODY: ${{ github.event.comment.body }}
          EVENT_ISSUE_BODY: ${{ github.event.issue.body }}
          EVENT_ISSUE_TITLE: ${{ github.event.issue.title }}
          EVENT_REVIEW_BODY: ${{ github.event.review.body }}
          COMMENT_USER: ${{ github.event.comment.user.login }}
        run: |
          HAS_CONTEXT="false"
          ISSUE_NUMBER=""
          ISSUE_BODY=""

          # Skip if comment is from Claude bot (prevents race condition with error comments)
          # Also skip "Claude Code is working" status comments (prevents self-cancellation)
          if [ "${{ github.event_name }}" = "issue_comment" ]; then
            if [ "$COMMENT_USER" = "claude[bot]" ]; then
              echo "‚ö†Ô∏è  Comment from Claude bot - skipping to prevent cancellation race"
              echo "has_context=false" >> $GITHUB_OUTPUT
              echo "issue_number=" >> $GITHUB_OUTPUT
              echo "issue_body<<EOF" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 0
            elif [[ "$EVENT_COMMENT_BODY" == *"Claude Code is working"* ]]; then
              echo "‚ö†Ô∏è  Claude Code status comment - skipping to prevent self-cancellation"
              echo "has_context=false" >> $GITHUB_OUTPUT
              echo "issue_number=" >> $GITHUB_OUTPUT
              echo "issue_body<<EOF" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # workflow_dispatch: Must have valid issue number
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ISSUE_NUMBER="${{ github.event.inputs.issue_number }}"
            if [ -n "$ISSUE_NUMBER" ]; then
              echo "üîç Validating issue #$ISSUE_NUMBER (workflow_dispatch trigger)..."
              if gh issue view "$ISSUE_NUMBER" &>/dev/null; then
                ISSUE_BODY=$(gh issue view "$ISSUE_NUMBER" --json body --jq '.body')
                HAS_CONTEXT="true"
                echo "‚úÖ Valid issue found: #$ISSUE_NUMBER"
              else
                echo "‚ùå Issue #$ISSUE_NUMBER not found - skipping workflow"
              fi
            else
              echo "‚ùå No issue number provided - skipping workflow"
            fi

          # issue_comment/PR review: Must have @claude mention and valid issue/PR
          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            if [[ "$EVENT_COMMENT_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.issue.number }}"
              ISSUE_BODY="$EVENT_ISSUE_BODY"
              HAS_CONTEXT="true"
              echo "‚úÖ Valid @claude mention in issue #$ISSUE_NUMBER"
            else
              echo "‚ö†Ô∏è  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
            if [[ "$EVENT_COMMENT_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.pull_request.number }}"
              HAS_CONTEXT="true"
              echo "‚úÖ Valid @claude mention in PR #$ISSUE_NUMBER"
            else
              echo "‚ö†Ô∏è  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "pull_request_review" ]; then
            if [[ "$EVENT_REVIEW_BODY" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.pull_request.number }}"
              HAS_CONTEXT="true"
              echo "‚úÖ Valid @claude mention in PR review #$ISSUE_NUMBER"
            else
              echo "‚ö†Ô∏è  No @claude mention found - skipping workflow"
            fi

          elif [ "${{ github.event_name }}" = "issues" ]; then
            if [[ "$EVENT_ISSUE_BODY" == *"@claude"* ]] || [[ "$EVENT_ISSUE_TITLE" == *"@claude"* ]]; then
              ISSUE_NUMBER="${{ github.event.issue.number }}"
              ISSUE_BODY="$EVENT_ISSUE_BODY"
              HAS_CONTEXT="true"
              echo "‚úÖ Valid @claude mention in issue #$ISSUE_NUMBER"
            else
              echo "‚ö†Ô∏è  No @claude mention found - skipping workflow"
            fi
          fi

          # Additional validation: Check if issue is closed or has existing PRs
          if [ "$HAS_CONTEXT" = "true" ] && [ -n "$ISSUE_NUMBER" ]; then
            echo ""
            echo "üîç Checking issue state and existing PRs for #$ISSUE_NUMBER..."

            # Check if issue is closed
            ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")

            if [ "$ISSUE_STATE" = "CLOSED" ]; then
              echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER is CLOSED - skipping to prevent duplicate PR"
              echo "   A PR has already been merged or the issue was closed manually"
              HAS_CONTEXT="false"
              ISSUE_NUMBER=""
              ISSUE_BODY=""
            else
              # Check for any existing PR (open or closed) for this issue
              EXISTING_PR_COUNT=$(gh pr list \
                --repo ${{ github.repository }} \
                --search "Closes #$ISSUE_NUMBER in:body" \
                --state all \
                --json number \
                --jq 'length' 2>/dev/null || echo "0")

              if [ "$EXISTING_PR_COUNT" -gt 0 ]; then
                EXISTING_PRS=$(gh pr list \
                  --repo ${{ github.repository }} \
                  --search "Closes #$ISSUE_NUMBER in:body" \
                  --state all \
                  --json number,state \
                  --jq '[.[] | "#\(.number) (\(.state))"] | join(", ")' 2>/dev/null || echo "")

                echo "‚ö†Ô∏è  Found $EXISTING_PR_COUNT existing PR(s) for issue #$ISSUE_NUMBER: $EXISTING_PRS"
                echo "   Skipping to prevent duplicate PR creation"
                echo "   If you need to retry, close/delete the existing PR first"

                # Post comment on issue explaining why we're skipping
                COMMENT_BODY="ü§ñ **Duplicate PR Prevention**

                Skipping Claude Code execution because PR(s) already exist for this issue: $EXISTING_PRS

                **To retry this spec:**
                1. Close or delete the existing PR if it's invalid
                2. Re-open this issue if it was closed
                3. Post a new @claude comment to trigger the workflow

                ---
                *ü§ñ Automated via Claude TDD Workflow*"

                gh issue comment "$ISSUE_NUMBER" --body "$COMMENT_BODY" 2>/dev/null || true

                HAS_CONTEXT="false"
                ISSUE_NUMBER=""
                ISSUE_BODY=""
              else
                echo "‚úÖ Issue is open with no existing PRs - safe to proceed"
              fi
            fi
          fi

          # Output results
          echo "has_context=$HAS_CONTEXT" >> $GITHUB_OUTPUT
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  # Error classification: Determine if error is retriable at infrastructure level
  classify-previous-error:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.retry_attempt > 1
    permissions:
      actions: read
    outputs:
      is_infrastructure_error: ${{ steps.classify.outputs.is_infrastructure_error }}
      error_type: ${{ steps.classify.outputs.error_type }}
      should_retry: ${{ steps.classify.outputs.should_retry }}
    steps:
      - name: Classify previous run error
        id: classify
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
        run: |
          echo "üîç Analyzing previous workflow run for error classification..."

          # Get the most recent failed run for this issue
          RECENT_RUN=$(gh run list \
            --workflow="claude-tdd.yml" \
            --status failure \
            --limit 5 \
            --json databaseId,conclusion,displayTitle \
            --jq ".[] | select(.displayTitle | contains(\"#$ISSUE_NUMBER\")) | .databaseId" \
            | head -1)

          if [ -z "$RECENT_RUN" ]; then
            echo "‚ö†Ô∏è  No recent failed run found - assuming infrastructure error"
            echo "is_infrastructure_error=true" >> $GITHUB_OUTPUT
            echo "error_type=unknown" >> $GITHUB_OUTPUT
            echo "should_retry=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "üìã Analyzing run #$RECENT_RUN..."

          # Get failure logs
          LOGS=$(gh run view "$RECENT_RUN" --log-failed || echo "")

          # Classify error type
          IS_INFRA_ERROR=false
          ERROR_TYPE="unknown"

          # Infrastructure errors (retriable at workflow level)
          if echo "$LOGS" | grep -q "EPERM: Operation not permitted"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="permission_error"
            echo "üîß Detected: Permission error (EPERM)"
          elif echo "$LOGS" | grep -q "ETIMEDOUT\|timeout\|timed out"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="timeout"
            echo "‚è±Ô∏è  Detected: Timeout error"
          elif echo "$LOGS" | grep -q "ECONNRESET\|ENOTFOUND\|socket hang up"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="network_error"
            echo "üåê Detected: Network error"
          elif echo "$LOGS" | grep -q "out of memory\|OOM\|killed"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="resource_exhaustion"
            echo "üíæ Detected: Resource exhaustion"
          elif echo "$LOGS" | grep -q "ENOSPC\|no space left"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="disk_full"
            echo "üíΩ Detected: Disk space error"
          elif echo "$LOGS" | grep -q "cancelled\|canceled"; then
            IS_INFRA_ERROR=true
            ERROR_TYPE="workflow_cancelled"
            echo "üö´ Detected: Workflow cancellation"
          # Code/test errors - NOW RETRIABLE with error context for Claude to self-correct
          elif echo "$LOGS" | grep -q "lint.*error\|ESLint.*error\|functional/immutable-data\|no-restricted-syntax"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="lint_error"
            echo "üîß Detected: Lint error - WILL RETRY with fix instructions"
          elif echo "$LOGS" | grep -q "Test.*failed\|FAIL\|AssertionError"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="test_failure"
            echo "üîß Detected: Test failure - WILL RETRY with fix instructions"
          elif echo "$LOGS" | grep -q "SyntaxError\|TypeError\|ReferenceError"; then
            IS_INFRA_ERROR=true  # Treat as retriable
            ERROR_TYPE="code_error"
            echo "üîß Detected: Code error - WILL RETRY with fix instructions"
          fi

          # Determine if should retry
          SHOULD_RETRY=false
          if [ "$IS_INFRA_ERROR" = true ]; then
            SHOULD_RETRY=true
            echo "‚úÖ Error detected - WILL RETRY (Claude can self-correct)"
          else
            echo "‚ö†Ô∏è  Unknown error - will NOT retry"
          fi

          # Output results
          echo "is_infrastructure_error=$IS_INFRA_ERROR" >> $GITHUB_OUTPUT
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT
          echo "should_retry=$SHOULD_RETRY" >> $GITHUB_OUTPUT

  # Main Claude Code execution with timeout monitoring
  execute-claude:
    runs-on: ubuntu-latest
    timeout-minutes: 65 # Slightly longer than Claude timeout to allow cleanup
    needs: [validate-context, classify-previous-error]
    if: |
      always() &&
      needs.validate-context.outputs.has_context == 'true' &&
      (needs.classify-previous-error.result == 'skipped' ||
       needs.classify-previous-error.outputs.should_retry == 'true') &&
      github.event.sender.login != 'claude[bot]' &&
      (
        github.event_name == 'workflow_dispatch' ||
        (github.event_name != 'workflow_dispatch' && (
          github.event.comment.author_association == 'OWNER' ||
          github.event.comment.author_association == 'MEMBER' ||
          github.event.comment.author_association == 'COLLABORATOR' ||
          github.event.issue.author_association == 'OWNER' ||
          github.event.issue.author_association == 'MEMBER' ||
          github.event.issue.author_association == 'COLLABORATOR' ||
          github.event.review.author_association == 'OWNER' ||
          github.event.review.author_association == 'MEMBER' ||
          github.event.review.author_association == 'COLLABORATOR' ||
          github.event.sender.login == 'github-actions[bot]' ||
          github.event.sender.login == 'github-actions' ||
          github.event.sender.login == 'app/github-actions' ||
          github.event.issue.user.login == 'github-actions[bot]' ||
          github.event.issue.user.login == 'github-actions' ||
          github.event.issue.user.login == 'app/github-actions' ||
          github.event.comment.user.login == 'github-actions[bot]' ||
          github.event.comment.user.login == 'github-actions' ||
          github.event.comment.user.login == 'app/github-actions'
        ))
      )
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read
    outputs:
      claude_success: ${{ steps.claude.outcome == 'success' }}
      claude_exit_code: ${{ steps.claude.outcome }}
      error_type: ${{ steps.detect_error.outputs.error_type }}
      is_infrastructure_error: ${{ steps.detect_error.outputs.is_infrastructure_error }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set issue context
        id: issue
        env:
          # Security: Use env var to prevent code injection from untrusted issue body
          ISSUE_BODY_INPUT: ${{ needs.validate-context.outputs.issue_body }}
        run: |
          echo "issue_number=${{ needs.validate-context.outputs.issue_number }}" >> $GITHUB_OUTPUT
          echo "issue_body<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUE_BODY_INPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@v1
        timeout-minutes: 60
        continue-on-error: true # Capture exit code instead of failing immediately
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          additional_permissions: |
            actions: read
          # NO prompt field - Claude Code will read the @claude comment naturally
          # This allows the queue processor's detailed instructions to be used
          # Agents are auto-discovered from .claude/agents/ directory (no --agents flag needed)
          claude_args: '--dangerously-skip-permissions'

      - name: Detect error type
        id: detect_error
        if: always()
        run: |
          echo "üîç Analyzing Claude Code execution..."

          # Check Claude Code exit behavior
          CLAUDE_OUTCOME="${{ steps.claude.outcome }}"

          IS_INFRA_ERROR=false
          ERROR_TYPE="unknown"

          # Calculate step duration to detect timeout (GitHub marks some timeouts as "success")
          START_TIME="${{ steps.claude.outputs.startedAt || '' }}"
          END_TIME="${{ steps.claude.outputs.completedAt || '' }}"

          # If timestamps are available, calculate duration
          if [ -n "$START_TIME" ] && [ -n "$END_TIME" ]; then
            START_EPOCH=$(date -d "$START_TIME" +%s 2>/dev/null || echo "0")
            END_EPOCH=$(date -d "$END_TIME" +%s 2>/dev/null || echo "0")

            if [ "$START_EPOCH" -ne 0 ] && [ "$END_EPOCH" -ne 0 ]; then
              DURATION=$((END_EPOCH - START_EPOCH))
              echo "üìä Step duration: ${DURATION}s"

              # Timeout detection: anything > 59 minutes (3540 seconds) is likely a timeout
              if [ "$DURATION" -ge 3540 ]; then
                IS_INFRA_ERROR=true
                ERROR_TYPE="timeout_confirmed"
                echo "‚è±Ô∏è TIMEOUT DETECTED: Step ran for ${DURATION}s (>= 3540s threshold)"
              fi
            fi
          fi

          # If not already classified as timeout, check outcome
          if [ "$ERROR_TYPE" = "unknown" ]; then
            if [ "$CLAUDE_OUTCOME" = "cancelled" ]; then
              # Cancelled usually means timeout or manual cancellation
              IS_INFRA_ERROR=true
              ERROR_TYPE="cancelled_timeout"
              echo "‚è±Ô∏è Step was cancelled - treating as timeout"
            elif [ "$CLAUDE_OUTCOME" = "failure" ]; then
              # For failures, check if it's infrastructure or code issue
              # Look for common infrastructure error patterns in logs if available
              ERROR_TYPE="claude_failure"
              echo "‚ùå Claude Code failed - checking for infrastructure issues..."

              # Default to infrastructure error for retries (conservative approach)
              IS_INFRA_ERROR=true
            elif [ "$CLAUDE_OUTCOME" = "success" ]; then
              # Even success might be a timeout if duration is suspicious
              if [ "$ERROR_TYPE" != "timeout_confirmed" ]; then
                ERROR_TYPE="success"
                echo "‚úÖ Claude Code completed successfully"
              fi
            else
              ERROR_TYPE="unknown_outcome"
              echo "‚ùì Unknown outcome: $CLAUDE_OUTCOME"
              IS_INFRA_ERROR=true
            fi
          fi

          echo "is_infrastructure_error=$IS_INFRA_ERROR" >> $GITHUB_OUTPUT
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT

      - name: Update issue on failure
        if: steps.claude.outcome != 'success'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.issue_number }}
          RETRY_ATTEMPT: ${{ github.event.inputs.retry_attempt || 1 }}
          ERROR_TYPE: ${{ steps.detect_error.outputs.error_type }}
        run: |
          echo "üìù Updating issue #$ISSUE_NUMBER with failure information..."

          gh issue comment "$ISSUE_NUMBER" --body "‚ö†Ô∏è **Claude Code Execution Failed (Attempt $RETRY_ATTEMPT)**

          **Error Type**: \`$ERROR_TYPE\`
          **Workflow Run**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          The automation system will analyze this error and retry if appropriate.

          ---
          *ü§ñ Infrastructure Error Handler*"

  # Retry logic: Automatically retry infrastructure errors
  handle-retry:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [execute-claude]
    if: |
      always() &&
      needs.execute-claude.outputs.claude_success != 'true' &&
      needs.execute-claude.outputs.is_infrastructure_error == 'true'
    permissions:
      actions: write
      issues: write
    steps:
      - name: Determine retry action
        id: retry
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          CURRENT_RETRY: ${{ github.event.inputs.retry_attempt || 1 }}
          MAX_RETRIES: ${{ env.MAX_INFRASTRUCTURE_RETRIES }}
          ERROR_TYPE: ${{ needs.execute-claude.outputs.error_type }}
        run: |
          echo "üîÑ Error detected: $ERROR_TYPE"
          echo "üìä Current retry attempt: $CURRENT_RETRY of $MAX_RETRIES"

          NEXT_RETRY=$((CURRENT_RETRY + 1))

          if [ "$NEXT_RETRY" -le "$MAX_RETRIES" ]; then
            echo "‚úÖ Will retry (attempt $NEXT_RETRY)"
            echo "should_retry=true" >> $GITHUB_OUTPUT
            echo "next_retry=$NEXT_RETRY" >> $GITHUB_OUTPUT

            # Add retry label based on error type
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" --add-label "code-retry:$CURRENT_RETRY" 2>/dev/null || true
            else
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" --add-label "infrastructure-retry:$CURRENT_RETRY" 2>/dev/null || true
            fi

            # Build retry comment with error-specific instructions
            if [ "$ERROR_TYPE" = "lint_error" ]; then
              RETRY_COMMENT="üîß **Automatic Code Fix Retry**

**Error Type**: \`$ERROR_TYPE\` (ESLint violation)
**Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

**‚ö†Ô∏è CRITICAL FIX INSTRUCTIONS FOR CLAUDE:**
1. Run \`bun run lint\` to see the exact ESLint errors
2. **Common FP violations to fix:**
   - ‚ùå \`array.push()\` ‚Üí ‚úÖ Use \`[...array, item]\`
   - ‚ùå \`for/while\` loops ‚Üí ‚úÖ Use \`map/filter/reduce\`
   - ‚ùå Mutable \`const arr = []\` ‚Üí ‚úÖ Use immutable patterns
3. Fix ALL lint errors before committing
4. Run \`bun run quality\` to verify

Retrying with fix instructions...

---
*ü§ñ TDD Error Handler*"
            elif [ "$ERROR_TYPE" = "test_failure" ]; then
              RETRY_COMMENT="üîß **Automatic Test Fix Retry**

**Error Type**: \`$ERROR_TYPE\`
**Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

**‚ö†Ô∏è FIX INSTRUCTIONS FOR CLAUDE:**
1. Run \`bun test:e2e -- <test-file>\` to see failing tests
2. Analyze the error output and fix the implementation
3. Ensure ALL tests in the file pass before committing
4. Run \`bun run quality\` to verify

Retrying with fix instructions...

---
*ü§ñ TDD Error Handler*"
            elif [ "$ERROR_TYPE" = "code_error" ]; then
              RETRY_COMMENT="üîß **Automatic Code Fix Retry**

**Error Type**: \`$ERROR_TYPE\` (Syntax/Type error)
**Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES

**‚ö†Ô∏è FIX INSTRUCTIONS FOR CLAUDE:**
1. Run \`bun run typecheck\` to see TypeScript errors
2. Fix all type errors before committing
3. Run \`bun run quality\` to verify

Retrying with fix instructions...

---
*ü§ñ TDD Error Handler*"
            else
              RETRY_COMMENT="üîÑ **Automatic Infrastructure Retry**

**Error Type**: \`$ERROR_TYPE\`
**Retry Attempt**: $NEXT_RETRY of $MAX_RETRIES
**Reason**: Infrastructure/environment error (not code-related)

Retrying workflow automatically with exponential backoff...

---
*ü§ñ Infrastructure Error Handler*"
            fi

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$RETRY_COMMENT"

            # Exponential backoff with jitter to avoid thundering herd
            # Delays: 60s (retry 1‚Üí2), 120s (retry 2‚Üí3), 240s (retry 3‚Üí4)
            BASE_DELAY=$((60 * (1 << (CURRENT_RETRY - 1))))

            # Add jitter (¬±25% randomness)
            JITTER_RANGE=$((BASE_DELAY / 4))
            JITTER=$((RANDOM % (JITTER_RANGE * 2 + 1) - JITTER_RANGE))
            ACTUAL_DELAY=$((BASE_DELAY + JITTER))

            # Ensure minimum 30s delay
            if [ "$ACTUAL_DELAY" -lt 30 ]; then
              ACTUAL_DELAY=30
            fi

            echo "‚è±Ô∏è  Waiting ${ACTUAL_DELAY}s before retry (base: ${BASE_DELAY}s, jitter: ${JITTER}s)"
            sleep "$ACTUAL_DELAY"
          else
            echo "‚ùå Max retries exhausted ($MAX_RETRIES)"
            echo "should_retry=false" >> $GITHUB_OUTPUT

            # Mark as failed with appropriate label
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:failed" \
                --add-label "code-error" 2>/dev/null || true
            else
              gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
                --remove-label "tdd-spec:in-progress" \
                --add-label "tdd-spec:failed" \
                --add-label "infrastructure-error" 2>/dev/null || true
            fi

            # Build failure message based on error type
            if [ "$ERROR_TYPE" = "lint_error" ] || [ "$ERROR_TYPE" = "test_failure" ] || [ "$ERROR_TYPE" = "code_error" ]; then
              FAILURE_COMMENT="‚ùå **Code Error - Max Retries Exhausted**

**Error Type**: \`$ERROR_TYPE\`
**Total Attempts**: $MAX_RETRIES
**Status**: Marked as \`tdd-spec:failed\`

Claude was unable to fix the code errors after $MAX_RETRIES attempts. Manual intervention required.

**Possible Solutions**:
1. Check the PR for specific error details
2. Manually fix the code and push
3. Review the agent instructions for missing patterns
4. Skip automation and implement manually

The queue processor will continue with the next spec.

---
*ü§ñ TDD Error Handler*"
            else
              FAILURE_COMMENT="‚ùå **Infrastructure Error - Max Retries Exhausted**

**Error Type**: \`$ERROR_TYPE\`
**Total Attempts**: $MAX_RETRIES
**Status**: Marked as \`tdd-spec:failed\`

This spec failed due to infrastructure/environment errors, not code issues. Manual intervention required.

**Possible Solutions**:
1. Check GitHub Actions runner status
2. Check if Claude Code API is experiencing issues
3. Manually retry via workflow_dispatch
4. Skip automation and implement manually

The queue processor will continue with the next spec.

---
*ü§ñ Infrastructure Error Handler*"
            fi

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" --body "$FAILURE_COMMENT"
          fi

      - name: Alert on high failure rate
        if: steps.retry.outputs.should_retry != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
        run: |
          echo "üìä Checking for high failure rate..."

          # Count failed specs in last 24 hours
          CUTOFF_DATE=$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-24H +%Y-%m-%dT%H:%M:%SZ)

          FAILED_COUNT=$(gh issue list \
            --repo "$REPO" \
            --label "tdd-spec:failed" \
            --state all \
            --json number,createdAt,labels \
            --jq "[.[] | select(.createdAt > \"$CUTOFF_DATE\")] | length")

          echo "Failed specs in last 24h: $FAILED_COUNT"

          # Create incident if >= 5 failures
          if [ "$FAILED_COUNT" -ge 5 ]; then
            echo "üö® High failure rate detected - creating incident..."

            # Check if incident already exists
            EXISTING_INCIDENT=$(gh issue list \
              --repo "$REPO" \
              --label "incident,high-failure-rate" \
              --state open \
              --json number \
              --jq 'length')

            if [ "$EXISTING_INCIDENT" -eq 0 ]; then
              # Get list of failed spec IDs
              FAILED_SPECS=$(gh issue list \
                --repo "$REPO" \
                --label "tdd-spec:failed" \
                --state all \
                --limit 10 \
                --json number,createdAt,title \
                --jq "[.[] | select(.createdAt > \"$CUTOFF_DATE\")] | map(\"- #\(.number): \(.title)\") | join(\"\n\")")

              gh issue create \
                --repo "$REPO" \
                --title "üö® TDD Automation: High Failure Rate ($FAILED_COUNT specs failed in 24h)" \
                --label "incident,high-failure-rate,tdd-automation,priority:high" \
                --body "## üö® High TDD Spec Failure Rate"$'\n\n'"Failed Specs (24h): $FAILED_COUNT"$'\n'"Threshold: 5"$'\n\n'"### Recent Failures"$'\n'"$FAILED_SPECS"$'\n\n'"### Investigation Steps"$'\n'"1. Check for common error patterns: \`gh issue list --label tdd-spec:failed --limit 20\`"$'\n'"2. Review claude-tdd.yml runs: [Workflow History](https://github.com/$REPO/actions/workflows/claude-tdd.yml)"$'\n'"3. Check infrastructure health: \`gh run list --workflow tdd-monitor-unified.yml\`"$'\n\n'"### Possible Causes"$'\n'"- Systemic test issues (flaky tests, environment problems)"$'\n'"- Infrastructure instability (runner timeouts, permission errors)"$'\n'"- Schema/API changes breaking multiple specs"$'\n'"- Claude Code regression (instruction following issues)"$'\n\n'"### Resolution"$'\n'"Once root cause identified and fixed:"$'\n'"1. Re-queue failed specs: \`gh issue edit ISSUE_NUMBER --remove-label tdd-spec:failed --add-label tdd-spec:queued\`"$'\n'"2. Close this incident"$'\n'"3. Document in TDD-TROUBLESHOOTING.md"$'\n\n'"---"$'\n'"ü§ñ Automated via [TDD Monitor](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"

              echo "‚úÖ Incident issue created"
            else
              echo "‚ÑπÔ∏è  Incident already exists, skipping creation"
            fi
          else
            echo "‚úÖ Failure rate acceptable ($FAILED_COUNT < 5)"
          fi

      - name: Trigger retry workflow
        if: steps.retry.outputs.should_retry == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
          NEXT_RETRY: ${{ steps.retry.outputs.next_retry }}
        run: |
          echo "üöÄ Triggering retry workflow (attempt $NEXT_RETRY)..."

          # Trigger the workflow
          gh workflow run claude-tdd.yml --repo "$REPO" \
            --field issue_number="$ISSUE_NUMBER" \
            --field retry_attempt="$NEXT_RETRY"

          # Wait for workflow to start
          echo "‚è≥ Verifying retry workflow started..."
          sleep 15

          # Check if workflow started in the last 20 seconds
          NOW=$(date +%s)
          RETRY_STARTED=false

          # Get recent runs with error handling
          RECENT_RUNS=$(gh run list \
            --workflow claude-tdd.yml \
            --repo "$REPO" \
            --limit 5 \
            --json event,createdAt,status 2>&1) || true

          # Validate JSON before parsing
          if echo "$RECENT_RUNS" | jq empty 2>/dev/null; then
            # Check for a workflow_dispatch run created in the last 20 seconds
            echo "$RECENT_RUNS" | jq -r '.[] | select(.event == "workflow_dispatch")' 2>/dev/null | while read -r run; do
              if [ -n "$run" ]; then
                CREATED_AT=$(echo "$run" | jq -r '.createdAt' 2>/dev/null || echo "")
                if [ -n "$CREATED_AT" ]; then
                  CREATED_EPOCH=$(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s 2>/dev/null || echo 0)
                  AGE=$((NOW - CREATED_EPOCH))

                  if [ "$AGE" -lt 20 ]; then
                    RETRY_STARTED=true
                    echo "‚úÖ Retry workflow started successfully"
                    break
                  fi
                fi
              fi
            done
          else
            echo "‚ö†Ô∏è Failed to parse workflow runs (JSON error) - will use fallback method"
          fi

          # If workflow didn't start, use issue comment as fallback
          if [ "$RETRY_STARTED" != "true" ]; then
            echo "‚ö†Ô∏è Workflow dispatch may have failed, triggering via issue comment as fallback..."

            # Get spec details from issue for context
            SPEC_ID=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json title --jq '.title' | grep -oP '[A-Z]+-[A-Z]+-[0-9]+' || echo "unknown")
            TEST_FILE=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json body --jq '.body' | grep -oP 'Test File.*`\K[^`]+' || echo "unknown")

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "@claude retry implementation (automated retry $NEXT_RETRY of 3 - workflow dispatch fallback)

            ## üìã Context
            - **Spec ID**: \`$SPEC_ID\`
            - **Test File**: \`$TEST_FILE\`
            - **Issue**: #$ISSUE_NUMBER
            - **Retry Attempt**: $NEXT_RETRY of 3
            - **Trigger**: Workflow dispatch failed, using comment fallback
            - **Previous Failure**: Infrastructure error (not code issue)

            ## ü§ñ Automation Mode
            - ‚úÖ Make autonomous decisions - proceed with best judgment
            - ‚ùå DO NOT ask questions

            ## ‚úÖ Instructions

            1. **Check current state**: Run \`git status\` to see if previous work exists on branch
            2. **If branch has uncommitted changes**: Continue from where it left off
            3. **If clean state**: Start fresh using e2e-test-fixer agent (\`Task\` tool with \`subagent_type='e2e-test-fixer'\`)
            4. **Run codebase-refactor-auditor**: Use \`Task\` tool with \`subagent_type='codebase-refactor-auditor'\` (MANDATORY - never skip)
            5. **Verify quality**: Run \`bun run quality\` - ALL checks must pass
            6. **Commit changes**: Run \`bun run license\`, then \`git commit -m \"fix: implement $SPEC_ID\"\`
            7. **Push to branch**: \`git push\`
            8. **Create PR**: \`gh pr create --title \"fix: implement $SPEC_ID\" --body \"Closes #$ISSUE_NUMBER\" --label \"tdd-automation\"\`
            9. **Enable auto-merge**: \`gh pr merge \$PR_NUMBER --auto --squash\`
            10. **Verify auto-merge**: \`gh pr view \$PR_NUMBER --json autoMergeRequest\` - must NOT be null

            ## ‚ö†Ô∏è Error Handling
            - **If tests fail**: Fix the code until \`bun run quality\` passes
            - **If PR already exists**: Update existing PR instead of creating new one
            - **If auto-merge fails**: Comment the failure reason on the PR

            **Reference**: \`@docs/development/tdd-automation-pipeline.md\`

            ---
            *ü§ñ Infrastructure Retry Handler (Fallback)*"

            echo "‚úÖ Fallback retry triggered via issue comment with full context"
          fi

  # Success path: Verify PR was created (same as original workflow)
  verify-success:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [execute-claude]
    if: needs.execute-claude.outputs.claude_success == 'true'
    permissions:
      issues: write
      pull-requests: read
    steps:
      - name: Verify PR was created
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number || github.event.issue.number || github.event.pull_request.number }}
        run: |
          echo "üîç Verifying PR was created for issue #$ISSUE_NUMBER..."

          # Wait up to 2 minutes for PR to appear
          PR_FOUND=false
          for i in {1..12}; do
            PR_COUNT=$(gh pr list --repo "$REPO" --json number,headRefName --jq "[.[] | select(.headRefName | test(\"^claude/issue-.*$ISSUE_NUMBER.*\"))] | length")

            if [ "$PR_COUNT" -gt 0 ]; then
              PR_NUMBER=$(gh pr list --repo "$REPO" --json number,headRefName --jq "[.[] | select(.headRefName | test(\"^claude/issue-.*$ISSUE_NUMBER.*\"))][0].number")
              echo "‚úÖ PR #$PR_NUMBER found!"
              PR_FOUND=true
              break
            fi

            echo "Attempt $i/12: PR not found yet, waiting 10 seconds..."
            sleep 10
          done

          # PR Recovery: Check if branch exists with commits before marking as failed
          if [ "$PR_FOUND" = false ]; then
            echo "üîç PR not found - checking if branch exists with commits..."

            BRANCH_PATTERN="claude/issue-${ISSUE_NUMBER}-"
            BRANCH_EXISTS=$(gh api "/repos/$REPO/branches" --jq "[.[] | select(.name | startswith(\"$BRANCH_PATTERN\"))] | length")

            if [ "$BRANCH_EXISTS" -gt 0 ]; then
              BRANCH_FULL_NAME=$(gh api "/repos/$REPO/branches" --jq "[.[] | select(.name | startswith(\"$BRANCH_PATTERN\"))][0].name")

              echo "üîß Branch found: $BRANCH_FULL_NAME - attempting PR creation from existing branch..."

              # Get spec ID from issue body
              SPEC_ID=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json body --jq '.body' | grep -oP 'SPEC-[A-Z0-9-]+' | head -1 || echo "unknown-spec")

              # Create PR from existing branch
              PR_CREATE_OUTPUT=$(gh pr create \
                --repo "$REPO" \
                --head "$BRANCH_FULL_NAME" \
                --base main \
                --title "fix: implement $SPEC_ID" \
                --body "Closes #${ISSUE_NUMBER}"$'\n\n'"Automated PR creation from existing branch (Claude Code forgot to create PR)."$'\n\n'"---"$'\n'"ü§ñ Automated recovery via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
                --label "tdd-automation" \
                --json number --jq '.number' 2>&1)

              if [[ "$PR_CREATE_OUTPUT" =~ ^[0-9]+$ ]]; then
                PR_NUMBER="$PR_CREATE_OUTPUT"
                echo "‚úÖ Recovery successful - PR #$PR_NUMBER created from branch $BRANCH_FULL_NAME"
                PR_FOUND=true

                # Enable auto-merge
                gh pr merge "$PR_NUMBER" --auto --squash --repo "$REPO" || echo "‚ö†Ô∏è  Auto-merge failed, but PR created successfully"

                gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
                  --body "‚úÖ **Automatic Recovery**: PR #$PR_NUMBER created from existing branch"$'\n\n'"Claude Code forgot to create PR, but changes were committed to branch \`$BRANCH_FULL_NAME\`. PR created automatically."$'\n\n'"Auto-merge enabled - PR will merge when CI passes."$'\n\n'"---"$'\n'"ü§ñ Automated recovery via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
              else
                echo "‚ö†Ô∏è  PR creation failed: $PR_CREATE_OUTPUT"
              fi
            else
              echo "‚ÑπÔ∏è  No branch found with pattern: $BRANCH_PATTERN"
            fi
          fi

          if [ "$PR_FOUND" = false ]; then
            echo "‚ùå No PR found after 2 minutes and recovery failed - marking issue as failed"

            gh issue edit "$ISSUE_NUMBER" --repo "$REPO" \
              --remove-label "tdd-spec:in-progress" \
              --add-label "tdd-spec:failed"

            gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
              --body "‚ùå **TDD Automation Failed: PR Not Created**

            Claude Code finished successfully but did not create a pull request. This is required for the TDD automation workflow to complete.

            **Next Steps**:
            1. Review Claude Code's work in the branch (if created)
            2. Manually create PR if changes exist
            3. Or re-run this spec if needed

            **Issue Status**: Marked as \`tdd-spec:failed\` - requires manual intervention.
            **Pipeline Status**: Queue processor will continue with next spec (this issue does not block the pipeline).

            ---
            *ü§ñ Automated via [TDD Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

            exit 1
          fi
