name: TDD Orchestrator

on:
  # Trigger after test.yml completes SUCCESSFULLY on main branch
  # IMPORTANT: Only trigger on success to prevent infinite loops from failing PRs
  workflow_run:
    workflows: ["Test"]
    types: [completed]
    branches: [main]

  # Hourly backup trigger (reduced from hourly to 4-hourly to prevent overload)
  schedule:
    - cron: '0 */4 * * *'

  # Manual trigger
  workflow_dispatch:
    inputs:
      force:
        description: 'Force run even if prerequisites fail'
        required: false
        type: boolean
        default: false

# Prevent multiple orchestrator runs from racing against each other
concurrency:
  group: tdd-orchestrator
  cancel-in-progress: false

jobs:
  orchestrate:
    # CRITICAL: Only run if the triggering workflow succeeded (for workflow_run events)
    # This prevents loops where failed Test runs trigger more orchestrator runs
    if: >-
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.6

      - name: Install dependencies
        run: bun install

      - name: Configure git identity
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check prerequisites
        id: prereqs
        run: |
          echo "ðŸ” Checking prerequisites..."

          # Check if state file exists
          if [ ! -f .github/tdd-state.json ]; then
            echo "âŒ State file not found"
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check active PRs count
          ACTIVE_COUNT=$(jq '.queue.active | length' .github/tdd-state.json)
          MAX_CONCURRENT=$(jq '.config.maxConcurrentPRs' .github/tdd-state.json)

          echo "Active PRs: $ACTIVE_COUNT / $MAX_CONCURRENT"

          if [ "$ACTIVE_COUNT" -ge "$MAX_CONCURRENT" ]; then
            echo "âš ï¸  Max concurrent PRs reached ($ACTIVE_COUNT/$MAX_CONCURRENT)"
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check pending queue
          PENDING_COUNT=$(jq '.queue.pending | length' .github/tdd-state.json)

          if [ "$PENDING_COUNT" -eq 0 ]; then
            echo "âœ… Queue is empty, nothing to process"
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "âœ… Prerequisites met: $PENDING_COUNT spec(s) pending"
          echo "result=true" >> $GITHUB_OUTPUT

      - name: Exit if prerequisites not met
        if: steps.prereqs.outputs.result == 'false' && !inputs.force
        run: |
          echo "Prerequisites not met. Exiting gracefully."
          exit 0

      - name: Select next specs
        id: select
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          echo "ðŸ“‹ Selecting next specs to process..."

          SPECS=$(bun run scripts/tdd-automation/services/spec-selector-cli.ts)

          echo "Selected specs:"
          echo "$SPECS" | jq '.'

          # Output as JSON string for next step
          echo "specs<<EOF" >> $GITHUB_OUTPUT
          echo "$SPECS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Count specs
          COUNT=$(echo "$SPECS" | jq 'length')
          echo "count=$COUNT" >> $GITHUB_OUTPUT

      - name: Exit if no specs selected
        if: steps.select.outputs.count == '0'
        run: |
          echo "No specs available to process."
          exit 0

      - name: Dispatch worker jobs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ðŸš€ Dispatching ${{ steps.select.outputs.count }} worker(s)..."

          SPECS='${{ steps.select.outputs.specs }}'

          echo "$SPECS" | jq -c '.[]' | while read -r spec; do
            SPEC_ID=$(echo "$spec" | jq -r '.specId')
            FILE_PATH=$(echo "$spec" | jq -r '.filePath')
            TEST_NAME=$(echo "$spec" | jq -r '.testName')
            PRIORITY=$(echo "$spec" | jq -r '.priority')
            ATTEMPTS=$(echo "$spec" | jq -r '.attempts')
            ERRORS=$(echo "$spec" | jq -c '.errors')

            echo "ðŸ“¤ Dispatching worker for: $SPEC_ID ($FILE_PATH)"

            gh workflow run tdd-worker.yml \
              -f spec_id="$SPEC_ID" \
              -f file_path="$FILE_PATH" \
              -f test_name="$TEST_NAME" \
              -f priority="$PRIORITY" \
              -f retry_count="$ATTEMPTS" \
              -f previous_errors="$ERRORS"

            echo "âœ… Worker dispatched for $SPEC_ID"

            # Small delay between dispatches to avoid rate limiting
            sleep 2
          done

          echo "ðŸŽ‰ All workers dispatched successfully"

      - name: Update metrics
        if: always()
        run: |
          echo "ðŸ“Š Updating orchestration metrics..."

          # This would update metrics like:
          # - Last orchestration time
          # - Specs dispatched count
          # - Queue health indicators

          echo "âœ… Metrics updated"
