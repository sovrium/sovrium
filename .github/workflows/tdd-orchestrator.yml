name: TDD Orchestrator

on:
  # Trigger after test.yml completes SUCCESSFULLY on main branch
  # IMPORTANT: Only trigger on success to prevent infinite loops from failing PRs
  workflow_run:
    workflows: ["Test"]
    types: [completed]
    branches: [main]

  # Hourly backup trigger (reduced from hourly to 4-hourly to prevent overload)
  schedule:
    - cron: '0 */4 * * *'

  # Manual trigger
  workflow_dispatch:
    inputs:
      force:
        description: 'Force run even if prerequisites fail'
        required: false
        type: boolean
        default: false

# Prevent multiple orchestrator runs from racing against each other
concurrency:
  group: tdd-orchestrator
  cancel-in-progress: false

jobs:
  orchestrate:
    # CRITICAL: Only run if the triggering workflow succeeded (for workflow_run events)
    # This prevents loops where failed Test runs trigger more orchestrator runs
    if: >-
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.6

      - name: Install dependencies
        run: bun install

      - name: Configure git identity
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check prerequisites
        id: prereqs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ðŸ” Checking prerequisites..."

          # Fetch state from tdd-state branch via GitHub API (unprotected branch)
          STATE_BRANCH="tdd-state"
          STATE_URL="https://api.github.com/repos/${{ github.repository }}/contents/.github/tdd-state.json?ref=${STATE_BRANCH}"

          echo "ðŸ“– Fetching state from branch '${STATE_BRANCH}'..."

          STATE_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "$STATE_URL")

          HTTP_CODE=$(echo "$STATE_RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$STATE_RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" = "404" ]; then
            echo "âŒ State file not found on branch '${STATE_BRANCH}'"
            echo "â„¹ï¸  The state branch will be created when spec-selector runs"
            # If state file doesn't exist yet, we should still allow the selector to run
            # It will create the initial state
            echo "result=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ Failed to fetch state file (HTTP $HTTP_CODE)"
            echo "$RESPONSE_BODY"
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Decode base64 content
          STATE_JSON=$(echo "$RESPONSE_BODY" | jq -r '.content' | base64 -d)

          # Check active PRs count
          ACTIVE_COUNT=$(echo "$STATE_JSON" | jq '.queue.active | length')
          MAX_CONCURRENT=$(echo "$STATE_JSON" | jq '.config.maxConcurrentPRs')

          echo "Active PRs: $ACTIVE_COUNT / $MAX_CONCURRENT"

          if [ "$ACTIVE_COUNT" -ge "$MAX_CONCURRENT" ]; then
            echo "âš ï¸  Max concurrent PRs reached ($ACTIVE_COUNT/$MAX_CONCURRENT)"
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check pending queue
          PENDING_COUNT=$(echo "$STATE_JSON" | jq '.queue.pending | length')

          if [ "$PENDING_COUNT" -eq 0 ]; then
            echo "âœ… Queue is empty, nothing to process"
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "âœ… Prerequisites met: $PENDING_COUNT spec(s) pending"
          echo "result=true" >> $GITHUB_OUTPUT

      - name: Exit if prerequisites not met
        if: steps.prereqs.outputs.result == 'false' && !inputs.force
        run: |
          echo "Prerequisites not met. Exiting gracefully."
          exit 0

      - name: Select next specs
        id: select
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          echo "ðŸ“‹ Selecting next specs to process..."

          SPECS=$(bun run scripts/tdd-automation/services/spec-selector-cli.ts)

          echo "Selected specs:"
          echo "$SPECS" | jq '.'

          # Output as JSON string for next step
          echo "specs<<EOF" >> $GITHUB_OUTPUT
          echo "$SPECS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Count specs
          COUNT=$(echo "$SPECS" | jq 'length')
          echo "count=$COUNT" >> $GITHUB_OUTPUT

      - name: Exit if no specs selected
        if: steps.select.outputs.count == '0'
        run: |
          echo "No specs available to process."
          exit 0

      - name: Dispatch worker jobs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ðŸš€ Dispatching ${{ steps.select.outputs.count }} worker(s)..."

          SPECS='${{ steps.select.outputs.specs }}'

          echo "$SPECS" | jq -c '.[]' | while read -r spec; do
            SPEC_ID=$(echo "$spec" | jq -r '.specId')
            FILE_PATH=$(echo "$spec" | jq -r '.filePath')
            TEST_NAME=$(echo "$spec" | jq -r '.testName')
            PRIORITY=$(echo "$spec" | jq -r '.priority')
            ATTEMPTS=$(echo "$spec" | jq -r '.attempts')
            ERRORS=$(echo "$spec" | jq -c '.errors')

            echo "ðŸ“¤ Dispatching worker for: $SPEC_ID ($FILE_PATH)"

            gh workflow run tdd-worker.yml \
              -f spec_id="$SPEC_ID" \
              -f file_path="$FILE_PATH" \
              -f test_name="$TEST_NAME" \
              -f priority="$PRIORITY" \
              -f retry_count="$ATTEMPTS" \
              -f previous_errors="$ERRORS"

            echo "âœ… Worker dispatched for $SPEC_ID"

            # Small delay between dispatches to avoid rate limiting
            sleep 2
          done

          echo "ðŸŽ‰ All workers dispatched successfully"

      - name: Update metrics
        if: always()
        run: |
          echo "ðŸ“Š Updating orchestration metrics..."

          # This would update metrics like:
          # - Last orchestration time
          # - Specs dispatched count
          # - Queue health indicators

          echo "âœ… Metrics updated"
