name: TDD Orchestrator

on:
  # Trigger after test.yml completes SUCCESSFULLY on main branch
  # IMPORTANT: Only trigger on success to prevent infinite loops from failing PRs
  workflow_run:
    workflows: ["Test"]
    types: [completed]
    branches: [main]

  # Hourly backup trigger (reduced from hourly to 4-hourly to prevent overload)
  schedule:
    - cron: '0 */4 * * *'

  # Manual trigger
  workflow_dispatch:
    inputs:
      force:
        description: 'Force run even if prerequisites fail'
        required: false
        type: boolean
        default: false

# Prevent multiple orchestrator runs from racing against each other
concurrency:
  group: tdd-orchestrator
  cancel-in-progress: false

jobs:
  orchestrate:
    # CRITICAL: Only run if the triggering workflow succeeded (for workflow_run events)
    # This prevents loops where failed Test runs trigger more orchestrator runs
    if: >-
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.3.6

      - name: Install dependencies
        run: bun install

      - name: Configure git identity
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # ============================================================
      # STATE SYNCHRONIZATION: Sync state with actual PR status
      # ============================================================
      # This step is CRITICAL to prevent the orchestrator from being blocked
      # by stale state entries that no longer correspond to actual open PRs.
      #
      # It checks all active specs and:
      # 1. Moves merged PRs to completed queue
      # 2. Re-queues closed (but not merged) PRs for retry
      # 3. Releases file/spec locks for finished PRs
      # 4. Handles abandoned activations (active > 60min without PR)
      - name: Sync state with PR status
        id: sync
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          echo "ðŸ”„ Synchronizing TDD state with actual PR status..."
          echo ""

          # Run the sync script (outputs JSON result to stdout)
          SYNC_RESULT=$(bun run scripts/tdd-automation/core/sync-state-with-prs.ts 2>&1 | tee /dev/stderr | tail -n 1)

          # Check if sync succeeded (last line should be valid JSON)
          if echo "$SYNC_RESULT" | jq -e '.' > /dev/null 2>&1; then
            COMPLETED=$(echo "$SYNC_RESULT" | jq '.specsMoved.toCompleted | length')
            PENDING=$(echo "$SYNC_RESULT" | jq '.specsMoved.toPending | length')
            FAILED=$(echo "$SYNC_RESULT" | jq '.specsMoved.toFailed | length')
            UNLOCKED=$(echo "$SYNC_RESULT" | jq '.filesUnlocked | length')

            echo ""
            echo "âœ… State sync complete:"
            echo "   - Moved to completed: $COMPLETED"
            echo "   - Re-queued to pending: $PENDING"
            echo "   - Moved to failed: $FAILED"
            echo "   - Files unlocked: $UNLOCKED"
          else
            echo "âš ï¸  State sync returned unexpected output, continuing anyway..."
          fi

      - name: Check prerequisites
        id: prereqs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Checking prerequisites..."

          # Fetch state from tdd-state branch via GitHub API (unprotected branch)
          STATE_BRANCH="tdd-state"
          STATE_URL="https://api.github.com/repos/${{ github.repository }}/contents/.github/tdd-state.json?ref=${STATE_BRANCH}"

          echo "Fetching state from branch '${STATE_BRANCH}'..."

          STATE_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "$STATE_URL")

          HTTP_CODE=$(echo "$STATE_RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$STATE_RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" = "404" ]; then
            echo "State file not found on branch '${STATE_BRANCH}'"
            echo "The state branch will be created when spec-selector runs"
            echo "result=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$HTTP_CODE" != "200" ]; then
            echo "Failed to fetch state file (HTTP $HTTP_CODE)"
            echo "$RESPONSE_BODY"
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Decode base64 content
          STATE_JSON=$(echo "$RESPONSE_BODY" | jq -r '.content' | base64 -d)

          # Check active PRs count
          ACTIVE_COUNT=$(echo "$STATE_JSON" | jq '.queue.active | length')
          MAX_CONCURRENT=$(echo "$STATE_JSON" | jq '.config.maxConcurrentPRs')

          echo "Active PRs: $ACTIVE_COUNT / $MAX_CONCURRENT"

          if [ "$ACTIVE_COUNT" -ge "$MAX_CONCURRENT" ]; then
            echo "Max concurrent PRs reached ($ACTIVE_COUNT/$MAX_CONCURRENT)"
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check pending queue
          PENDING_COUNT=$(echo "$STATE_JSON" | jq '.queue.pending | length')

          if [ "$PENDING_COUNT" -eq 0 ]; then
            echo "Queue is empty, nothing to process"
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Prerequisites met: $PENDING_COUNT spec(s) pending"
          echo "result=true" >> $GITHUB_OUTPUT

      - name: Exit if prerequisites not met
        if: steps.prereqs.outputs.result == 'false' && !inputs.force
        run: |
          echo "Prerequisites not met. Exiting gracefully."
          exit 0

      - name: Select next specs
        id: select
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          echo "Selecting next specs to process..."

          SPECS=$(bun run scripts/tdd-automation/services/spec-selector-cli.ts)

          echo "Selected specs:"
          echo "$SPECS" | jq '.'

          # Output as JSON string for next step
          echo "specs<<EOF" >> $GITHUB_OUTPUT
          echo "$SPECS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Count specs
          COUNT=$(echo "$SPECS" | jq 'length')
          echo "count=$COUNT" >> $GITHUB_OUTPUT

      - name: Exit if no specs selected
        if: steps.select.outputs.count == '0'
        run: |
          echo "No specs available to process."
          exit 0

      # ============================================================
      # NEW ARCHITECTURE: Create PRs directly to enable track_progress
      # ============================================================
      # Instead of dispatching workflow_dispatch workers, we now:
      # 1. Create branch for each spec
      # 2. Run pre-validation (remove .fixme())
      # 3. Commit and push changes
      # 4. Create PR with tdd-automation label
      # 5. Worker triggers via pull_request:opened event with track_progress enabled

      - name: Process specs and create PRs
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          GITHUB_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          echo "Creating PRs for ${{ steps.select.outputs.count }} spec(s)..."

          SPECS='${{ steps.select.outputs.specs }}'

          echo "$SPECS" | jq -c '.[]' | while read -r spec; do
            SPEC_ID=$(echo "$spec" | jq -r '.specId')
            FILE_PATH=$(echo "$spec" | jq -r '.filePath')
            TEST_NAME=$(echo "$spec" | jq -r '.testName')
            PRIORITY=$(echo "$spec" | jq -r '.priority')
            ATTEMPTS=$(echo "$spec" | jq -r '.attempts')
            ERRORS=$(echo "$spec" | jq -c '.errors')

            echo ""
            echo "=========================================="
            echo "Processing: $SPEC_ID"
            echo "=========================================="

            # Create unique branch name
            TIMESTAMP=$(date +%s)
            BRANCH_NAME="tdd/${SPEC_ID}-${TIMESTAMP}"

            echo "Creating branch: $BRANCH_NAME"

            # Checkout fresh main and create branch
            git checkout main
            git pull origin main
            git checkout -b "$BRANCH_NAME"

            # Run pre-validation to remove .fixme()
            # Output to /tmp/ to avoid committing temp files
            echo "Running pre-validation..."
            bun run scripts/tdd-automation/core/pre-validate.ts \
              --file "$FILE_PATH" \
              --spec-id "$SPEC_ID" \
              --test-name "$TEST_NAME" \
              --output /tmp/prevalidation-result.json || true

            # Parse pre-validation results
            if [ -f /tmp/prevalidation-result.json ]; then
              PASSED=$(cat /tmp/prevalidation-result.json | jq -r '.passed // 0')
              FAILED=$(cat /tmp/prevalidation-result.json | jq -r '.failed // 0')
              echo "Pre-validation: $PASSED passed, $FAILED failed"
            else
              PASSED=0
              FAILED=1
              echo "Pre-validation result file not found"
            fi

            # Only stage the spec file changes (not bun.lock or other files)
            git add "$FILE_PATH"

            # Check if spec file was actually modified
            if git diff --staged --quiet; then
              echo "âš ï¸ No changes to spec file (test may already be implemented)"

              # If test passes and no changes needed, spec is already complete
              if [ "$FAILED" -eq 0 ] && [ "$PASSED" -gt 0 ]; then
                echo "âœ… Test already passing without .fixme() - marking as complete"

                # Clean up the branch
                git checkout main
                git branch -D "$BRANCH_NAME" 2>/dev/null || true

                # Mark spec as completed in state (already passing, no work needed)
                bun run scripts/tdd-automation/core/mark-spec-complete.ts \
                  --spec-id "$SPEC_ID" \
                  --reason "Test already implemented and passing" || {
                  echo "Warning: Failed to mark spec as complete, continuing anyway..."
                }

                echo "Skipping PR creation for $SPEC_ID (already complete)"
                continue
              fi

              # Test failed but no changes - this shouldn't happen, but handle it
              echo "âŒ Test failing but no .fixme() found - creating PR anyway for investigation"
            fi

            # Commit changes
            git commit -m "test: remove .fixme() from ${SPEC_ID}" \
              -m "Pre-validation: $PASSED passed, $FAILED failed" \
              -m "Spec file: $FILE_PATH" || {
              echo "Nothing to commit - spec needs investigation"
              git checkout main
              git branch -D "$BRANCH_NAME" 2>/dev/null || true
              continue
            }

            # Push branch
            echo "Pushing branch..."
            git push origin "$BRANCH_NAME"

            # Build TDD metadata for PR body (used by worker to extract spec details)
            # Note: Using printf to avoid YAML heredoc issues with colons in JSON
            METADATA=$(printf '{"specId":"%s","filePath":"%s","testName":"%s","priority":%s,"retryCount":%s,"previousErrors":%s}' \
              "$SPEC_ID" "$FILE_PATH" "$TEST_NAME" "$PRIORITY" "$ATTEMPTS" "$ERRORS")

            # Create PR with tdd-automation label
            # The label triggers the TDD Worker via pull_request:opened event
            echo "Creating PR..."

            PR_TITLE="feat: implement ${SPEC_ID}"

            # Build PR body using echo to a temp file (avoids YAML parsing issues with special chars)
            {
              echo "## TDD Automation"
              echo ""
              echo "Implements test: \\\`${TEST_NAME}\\\`"
              echo ""
              echo "Spec File: \\\`${FILE_PATH}\\\`"
              echo "Attempt: $((ATTEMPTS + 1))/3"
              echo ""
              echo "### Pre-validation Results"
              echo "Passed: ${PASSED}"
              echo "Failed: ${FAILED}"
              echo ""
              echo "### Progress"
              echo ""
              echo "Claude Code will show real-time progress in this PR once the worker starts."
              echo ""
              echo "---"
              echo ""
              echo "<!-- TDD_METADATA: ${METADATA} -->"
              echo ""
              echo "Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
            } > /tmp/pr-body.txt
            PR_BODY=$(cat /tmp/pr-body.txt)

            # Create PR with label
            PR_URL=$(gh pr create \
              --title "$PR_TITLE" \
              --body "$PR_BODY" \
              --label "tdd-automation" \
              --head "$BRANCH_NAME" \
              --base main 2>&1)

            if echo "$PR_URL" | grep -q "https://github.com"; then
              PR_NUMBER=$(echo "$PR_URL" | grep -oP 'pull/\K\d+')
              echo "PR #${PR_NUMBER} created: $PR_URL"
              echo "Worker will be triggered by pull_request:opened event with track_progress enabled"

              # Update state file with PR info (critical for sync to work)
              echo "Updating state with PR info..."
              bun run scripts/tdd-automation/core/update-active-pr.ts \
                --spec-id "$SPEC_ID" \
                --pr-number "$PR_NUMBER" \
                --pr-url "$PR_URL" \
                --branch "$BRANCH_NAME" || {
                echo "Warning: Failed to update state with PR info, continuing anyway..."
              }
            else
              echo "Failed to create PR: $PR_URL"
              # Cleanup branch on failure
              git checkout main
              git push origin --delete "$BRANCH_NAME" 2>/dev/null || true
            fi

            # Small delay between PRs to avoid rate limiting
            sleep 3

          done

          echo ""
          echo "All PRs created successfully"

      - name: Update metrics
        if: always()
        run: |
          echo "Updating orchestration metrics..."

          # This would update metrics like:
          # - Last orchestration time
          # - Specs dispatched count
          # - Queue health indicators

          echo "Metrics updated"
