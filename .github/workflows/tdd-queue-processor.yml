name: TDD Queue - Processor

on:
  # Event-driven triggers (immediate response when work is available)
  workflow_run:
    workflows:
      - 'TDD Queue - Populate' # New specs added to queue
      - 'Claude Code TDD' # Spec completed, pick next one
      - 'TDD Monitor (Unified)' # Stuck specs re-queued
    types: [completed]
    branches: [main]

  # Scheduled backup (hourly safety net, reduced from every 15 min)
  schedule:
    - cron: '0 * * * *' # Every hour (Phase 3: event-driven architecture)

  # Manual trigger
  workflow_dispatch:

# Security: Define minimal required permissions
# NOTE: Requires GH_PAT_WORKFLOW secret with 'repo' scope to post @claude mentions
# Comments posted with PAT appear from token owner's account (not github-actions bot)
# This triggers Claude Code workflow via issue_comment event
permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

# Prevent concurrent processing (strict serial: one spec at a time)
# IMPORTANT: Shares concurrency group with tdd-daily-refactor.yml
# This ensures queue processor waits when daily refactor is running
concurrency:
  group: tdd-queue
  cancel-in-progress: false

jobs:
  process-queue:
    name: üîÑ Process TDD Queue
    runs-on: ubuntu-latest
    timeout-minutes: 5 # Quick operation: fetch queue, update labels, post @claude comment
    # Only process queue if:
    # 1. Triggered by schedule or manual (always run)
    # 2. Triggered by workflow_run AND the workflow succeeded
    if: |
      github.event_name != 'workflow_run' ||
      github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Log trigger source
        run: |
          echo "üîç Queue Processor Triggered"
          echo "=========================="
          echo "Event: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "Triggered by: ${{ github.event.workflow_run.name }}"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Trigger type: Event-driven (Phase 3)"
          elif [ "${{ github.event_name }}" = "schedule" ]; then
            echo "Trigger type: Scheduled backup (hourly safety net)"
          else
            echo "Trigger type: Manual"
          fi
          echo ""

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for git operations

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Configure git with token user
        run: |
          USER_NAME=$(gh api user --jq '.login')
          USER_EMAIL=$(gh api user --jq '.email')
          git config user.name "$USER_NAME"
          git config user.email "$USER_EMAIL"
          echo "‚úÖ Git configured as $USER_NAME <$USER_EMAIL>"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Get next spec from queue
        id: next
        run: |
          echo "üîç Looking for next spec to process..."
          bun run scripts/tdd-automation/queue-manager.ts next
        env:
          GITHUB_OUTPUT: ${{ github.output }}
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Check if spec available
        id: check
        run: |
          if [ "${{ steps.next.outputs.has_next }}" != "true" ]; then
            echo "üì≠ No specs available to process"
            echo "should_process=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found spec to process: ${{ steps.next.outputs.spec_id }}"
            echo "should_process=true" >> $GITHUB_OUTPUT
          fi

      - name: Validate issue state and check for duplicates
        if: steps.check.outputs.should_process == 'true'
        id: validate
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"

          echo "üîç Validating issue #$ISSUE_NUMBER before processing..."

          # Check if issue is still open
          ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state')

          if [ "$ISSUE_STATE" = "CLOSED" ]; then
            echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER is already CLOSED"
            echo "   Skipping processing (likely already completed by another PR)"

            # Update the issue to remove in-progress label if present
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress" || true

            echo "should_process=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for existing open PRs for this issue
          EXISTING_PRS=$(gh pr list \
            --label tdd-automation \
            --state open \
            --json number,body \
            --jq ".[] | select(.body | contains(\"Closes #$ISSUE_NUMBER\")) | .number")

          if [ -n "$EXISTING_PRS" ]; then
            echo "‚ö†Ô∏è  Found existing open PR(s) for issue #$ISSUE_NUMBER: $EXISTING_PRS"
            echo "   Skipping processing to avoid duplicate PRs"

            # CRITICAL: Change label to in-progress to prevent loop
            # Without this, the issue stays queued and gets picked up again every trigger
            echo "   Updating label to in-progress to prevent reprocessing..."
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:queued" || true
            gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:in-progress" || true

            # Check if we already posted a duplicate PR comment recently (within 1 hour)
            RECENT_COMMENT=$(gh api \
              "/repos/${{ github.repository }}/issues/${ISSUE_NUMBER}/comments" \
              --jq "[.[] | select(.body | contains(\"Duplicate PR Prevention\")) | select(.created_at > \"$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)\")] | length" 2>/dev/null || echo "0")

            if [ "$RECENT_COMMENT" -eq 0 ]; then
              gh issue comment "$ISSUE_NUMBER" --body "ü§ñ Duplicate PR Prevention - Skipping processing because an open PR already exists for this issue (#$EXISTING_PRS). The existing PR will be processed to completion. If the PR is stuck or invalid, please close it manually and the queue will retry this spec."
            else
              echo "   Skipping comment - already posted within last hour"
            fi

            echo "should_process=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Issue is open and no duplicate PRs found"
          echo "should_process=true" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}

      - name: Mark spec as in-progress and trigger Claude Code workflow
        if: steps.check.outputs.should_process == 'true' && steps.validate.outputs.should_process == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.next.outputs.issue_number }}"
          SPEC_ID="${{ steps.next.outputs.spec_id }}"
          TEST_FILE="${{ steps.next.outputs.test_file }}"

          echo "üèÉ Marking issue #$ISSUE_NUMBER as in-progress..."

          # Update labels
          gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:queued"
          gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:in-progress"

          # NOTE: We only post @claude comment (not workflow_dispatch) to avoid double trigger
          # The @claude comment triggers claude-tdd.yml via issue_comment event
          echo "ü§ñ Posting @claude comment to trigger Claude Code workflow..."

          # Add comment with workflow instructions (triggers claude-tdd.yml)
          gh issue comment "$ISSUE_NUMBER" --body "@claude implement this spec using the TDD automation workflow.

          ## üìã Spec Details

          - **Test File**: \`$TEST_FILE\`
          - **Spec ID**: \`$SPEC_ID\`
          - **Issue**: #$ISSUE_NUMBER

          ## ü§ñ Automation Mode

          **You are in pipeline/automation mode**:
          - ‚úÖ Make autonomous decisions following Sovrium patterns
          - ‚úÖ Implement minimal code to pass the test
          - ‚ùå DO NOT ask questions - proceed with best judgment
          - ‚ùå DO NOT skip any steps - all are MANDATORY

          ## ‚úÖ Critical Steps (ALL REQUIRED)

          1. **Run e2e-test-fixer agent** - Use \`Task\` tool with \`subagent_type='e2e-test-fixer'\` to remove \`.fixme()\` from \`$SPEC_ID\` and implement minimal code to pass the test
          2. **Run codebase-refactor-auditor agent** - Use \`Task\` tool with \`subagent_type='codebase-refactor-auditor'\` to review implementation, verify layer architecture compliance, and ensure \`bun run quality\` passes (MANDATORY - never skip)
          3. **‚ö†Ô∏è GATE: Verify quality BEFORE PR** - Run \`bun run quality\` and confirm ALL checks pass:
             - ‚úÖ ESLint: 0 errors
             - ‚úÖ TypeScript: No type errors
             - ‚úÖ Unit tests: All passing
             - ‚úÖ Coverage check: Domain layer has tests
             - ‚úÖ **Smart E2E detection**: Runs affected @regression specs automatically
             - **üö´ DO NOT proceed to step 4 if ANY check fails** - fix ALL issues first
             - **Note**: \`bun run quality\` uses smart detection to run only @regression specs related to your changes
          4. **Commit changes** - Run \`bun run license\`, then commit as \`fix: implement $SPEC_ID\`, push to branch
          5. **‚ö†Ô∏è CREATE PR** - \`gh pr create --title \"fix: implement $SPEC_ID\" --body \"Closes #$ISSUE_NUMBER\" --label \"tdd-automation\"\`
          6. **‚ö†Ô∏è ENABLE AUTO-MERGE** - \`gh pr merge \$PR_NUMBER --auto --squash\`
          7. **‚ö†Ô∏è VERIFY AUTO-MERGE** - Run \`gh pr view \$PR_NUMBER --json autoMergeRequest\` and confirm autoMergeRequest is NOT null

          ## ‚ö†Ô∏è Error Handling

          - **If \`bun run quality\` fails**:
            1. Read the FULL error output carefully
            2. Fix ALL failing checks (ESLint, TypeScript, unit tests, E2E)
            3. Re-run \`bun run quality\` until it passes completely
            4. Only THEN proceed to commit and PR creation
          - **If layer architecture violations**: Fix cross-layer imports before proceeding - domain must be pure
          - **If PR creation fails**: Retry once, then report error in issue comment
          - **If auto-merge fails**: Comment the failure reason on the PR and retry

          ## üö® MOST COMMON FAILURES (Learn from history)

          - Missing PR creation (issue #1319) ‚Üí spec marked failed after 2 minutes
          - Missing auto-merge (PRs #1541, #1546) ‚Üí pipeline blocked for hours
          - Auto-merge not verified ‚Üí may silently fail, always check with \`gh pr view\`
          - Skipping codebase-refactor-auditor ‚Üí technical debt accumulates
          - **Creating PR with failing regression tests** (PR #4846) ‚Üí CI fails, PR blocked - ALWAYS run \`bun run quality\` and fix ALL failures before PR

          **Complete workflow documentation**: \`@docs/development/tdd-automation-pipeline.md\`

          ---
          *ü§ñ Automated via [Queue Processor](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

          echo "‚úÖ Issue updated and @claude mentioned - Claude Code will trigger automatically"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
