name: TDD Claude Code

on:
  issue_comment:
    types: [created]

# Concurrency control: Only one Claude Code run per PR at a time
# - Prevents duplicate API costs when multiple @claude comments posted
# - Uses PR number as group key (different PRs can run in parallel)
# - cancel-in-progress: false = complete current run, queue next (don't waste credits)
concurrency:
  group: claude-code-${{ github.event.issue.number }}
  cancel-in-progress: false

# Required permissions for Claude Code Action
permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read
  id-token: write  # Required for OIDC authentication

jobs:
  # ============================================================================
  # JOB 1: VALIDATE TRIGGER
  #
  # Pre-conditions:
  # 1. Comment author is thomas-jeanneau (TDD bot account)
  # 2. PR has tdd-automation label
  # 3. Credit limits not exceeded
  # ============================================================================
  validate:
    name: Validate Trigger
    if: |
      github.event.issue.pull_request &&
      startsWith(github.event.comment.body, '@claude') &&
      github.event.comment.user.login == 'thomas-jeanneau'
    runs-on: ubuntu-latest
    outputs:
      is-valid: ${{ steps.validate.outputs.is-valid }}
      pr-number: ${{ github.event.issue.number }}
      pr-branch: ${{ steps.pr-info.outputs.branch }}
      pr-title: ${{ steps.pr-info.outputs.title }}
      agent-type: ${{ steps.parse.outputs.agent-type }}
      spec-file: ${{ steps.parse.outputs.spec-file }}
      spec-id: ${{ steps.parse.outputs.spec-id }}
      timeout: ${{ steps.config.outputs.timeout }}
      job-timeout: ${{ steps.config.outputs.job-timeout }}
    steps:
      - name: Get PR info
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          PR_DATA=$(gh pr view "${{ github.event.issue.number }}" --repo "${{ github.repository }}" --json headRefName,labels,title)
          BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
          TITLE=$(echo "$PR_DATA" | jq -r '.title')
          HAS_LABEL=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "tdd-automation" || echo "0")
          IS_TDD_BRANCH=$(echo "$BRANCH" | grep -c "^tdd/" || echo "0")

          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"
          echo "title=$TITLE" >> "$GITHUB_OUTPUT"

          if [ "$HAS_LABEL" -gt 0 ] || [ "$IS_TDD_BRANCH" -gt 0 ]; then
            echo "is-tdd=true" >> "$GITHUB_OUTPUT"
          else
            echo "is-tdd=false" >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è Not a TDD PR - skipping"
          fi

      - name: Parse @claude comment
        id: parse
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          # Extract agent type from comment
          if echo "$COMMENT_BODY" | grep -q "e2e-test-fixer"; then
            echo "agent-type=e2e-test-fixer" >> "$GITHUB_OUTPUT"
          elif echo "$COMMENT_BODY" | grep -q "codebase-refactor-auditor"; then
            echo "agent-type=codebase-refactor-auditor" >> "$GITHUB_OUTPUT"
          else
            echo "agent-type=e2e-test-fixer" >> "$GITHUB_OUTPUT"  # Default
          fi

          # Extract spec file if mentioned (format: `specs/...`)
          # shellcheck disable=SC2016
          SPEC_FILE=$(echo "$COMMENT_BODY" | grep -oP 'File: `\K[^`]+' | head -1 || echo "")
          if [ -z "$SPEC_FILE" ]; then
            # shellcheck disable=SC2016
            SPEC_FILE=$(echo "$COMMENT_BODY" | grep -oP '`specs/[^`]+`' | tr -d '`' | head -1 || echo "")
          fi
          echo "spec-file=$SPEC_FILE" >> "$GITHUB_OUTPUT"

          # Extract spec ID (format: Spec: `SPEC-ID`)
          # shellcheck disable=SC2016
          SPEC_ID=$(echo "$COMMENT_BODY" | grep -oP 'Spec: `\K[^`]+' | head -1 || echo "")
          echo "spec-id=$SPEC_ID" >> "$GITHUB_OUTPUT"

          # Validate parsed values
          echo "üìã Parsed values:"
          echo "   Agent type: ${AGENT_TYPE:-e2e-test-fixer}"
          echo "   Spec ID: ${SPEC_ID:-(empty)}"
          echo "   Spec file: ${SPEC_FILE:-(empty)}"

          if [ -z "$SPEC_ID" ]; then
            echo "‚ö†Ô∏è Warning: spec-id is empty - comment may not match expected format"
          fi

          if [ -z "$SPEC_FILE" ]; then
            echo "‚ö†Ô∏è Warning: spec-file is empty - comment may not match expected format"
          fi

      # Setup for TypeScript-based credit check and comment scripts
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Checkout TDD automation scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            scripts/tdd-automation/
            package.json
            bun.lock
          sparse-checkout-cone-mode: false

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Check credit limits
        id: credits
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          # Configure limits (override defaults in TDD_CONFIG)
          TDD_DAILY_LIMIT: "200"
          TDD_WEEKLY_LIMIT: "1000"
        run: |
          # Run TypeScript credit check (replaces ~130 lines of bash)
          RESULT=$(bun run scripts/tdd-automation/workflows/claude-code/check-credits.ts 2>&1 | tail -1)

          # Parse JSON output and set workflow outputs
          {
            echo "credits-ok=$(echo "$RESULT" | jq -r '.creditsOk')"
            echo "limit-type=$(echo "$RESULT" | jq -r '.limitType')"
            echo "daily-runs=0"
            echo "weekly-runs=0"
            echo "actual-daily=$(echo "$RESULT" | jq -r '.dailySpend')"
            echo "actual-weekly=$(echo "$RESULT" | jq -r '.weeklySpend')"
            echo "daily-limit=$(echo "$RESULT" | jq -r '.dailyLimit')"
            echo "weekly-limit=$(echo "$RESULT" | jq -r '.weeklyLimit')"
            echo "daily-remaining=$(echo "$RESULT" | jq -r '.dailyRemaining')"
            echo "weekly-remaining=$(echo "$RESULT" | jq -r '.weeklyRemaining')"
            echo "daily-percent=$(echo "$RESULT" | jq -r '.dailyPercent')"
            echo "weekly-percent=$(echo "$RESULT" | jq -r '.weeklyPercent')"
            echo "hours-until-daily-reset=$(echo "$RESULT" | jq -r '.hoursUntilDailyReset')"
            echo "days-until-weekly-reset=$(echo "$RESULT" | jq -r '.daysUntilWeeklyReset')"
          } >> "$GITHUB_OUTPUT"

      - name: Post credit usage comment (always)
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          # Pass credit metrics as environment variables
          credits-ok: ${{ steps.credits.outputs.credits-ok }}
          limit-type: ${{ steps.credits.outputs.limit-type }}
          daily-runs: ${{ steps.credits.outputs.daily-runs }}
          weekly-runs: ${{ steps.credits.outputs.weekly-runs }}
          actual-daily: ${{ steps.credits.outputs.actual-daily }}
          actual-weekly: ${{ steps.credits.outputs.actual-weekly }}
          daily-limit: ${{ steps.credits.outputs.daily-limit }}
          weekly-limit: ${{ steps.credits.outputs.weekly-limit }}
          daily-remaining: ${{ steps.credits.outputs.daily-remaining }}
          weekly-remaining: ${{ steps.credits.outputs.weekly-remaining }}
          daily-percent: ${{ steps.credits.outputs.daily-percent }}
          weekly-percent: ${{ steps.credits.outputs.weekly-percent }}
          hours-until-daily-reset: ${{ steps.credits.outputs.hours-until-daily-reset }}
          days-until-weekly-reset: ${{ steps.credits.outputs.days-until-weekly-reset }}
        run: |
          # Generate credit usage comment using TypeScript (replaces 60 lines of bash)
          bun run scripts/tdd-automation/workflows/claude-code/generate-credit-comment.ts > /tmp/credit_usage.md

          # Post comment (always) with timeout and retry logic
          for attempt in {1..3}; do
            echo "üìù Posting credit usage comment (attempt $attempt/3)..."
            if timeout 60 gh pr comment "${{ github.event.issue.number }}" --repo "${{ github.repository }}" --body-file /tmp/credit_usage.md; then
              echo "‚úÖ Credit usage comment posted successfully"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Comment posting failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::warning::Failed to post credit comment after 3 attempts"
            fi
          done

      - name: Validate all conditions
        id: validate
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
        run: |
          IS_TDD="${{ steps.pr-info.outputs.is-tdd }}"
          CREDITS_OK="${{ steps.credits.outputs.credits-ok }}"

          if [ "$IS_TDD" != "true" ]; then
            echo "is-valid=false" >> "$GITHUB_OUTPUT"
            echo "‚ùå Validation failed: Not a TDD PR"
            exit 0
          fi

          if [ "$CREDITS_OK" != "true" ]; then
            echo "is-valid=false" >> "$GITHUB_OUTPUT"
            echo "‚õî Credit limit reached - execution blocked (comment already posted)"
            exit 0
          fi

          echo "is-valid=true" >> "$GITHUB_OUTPUT"
          echo "‚úÖ All validation checks passed"

      - uses: actions/checkout@v4
        if: steps.validate.outputs.is-valid == 'true'
        with:
          ref: ${{ steps.pr-info.outputs.branch }}

      - name: Extract per-spec timeout
        id: config
        if: steps.validate.outputs.is-valid == 'true'
        run: |
          SPEC_FILE="${{ steps.parse.outputs.spec-file }}"
          DEFAULT_TIMEOUT=90

          if [ -n "$SPEC_FILE" ] && [ -f "$SPEC_FILE" ]; then
            # Extract @tdd-timeout annotation if present
            TIMEOUT=$(grep -oP '@tdd-timeout \K[0-9]+' "$SPEC_FILE" 2>/dev/null || echo "$DEFAULT_TIMEOUT")
          else
            TIMEOUT=$DEFAULT_TIMEOUT
          fi

          # Job-level timeout adds 15-minute buffer for error handling steps
          # This ensures error handlers can run even if Claude Code step times out
          JOB_TIMEOUT=$((TIMEOUT + 15))

          echo "timeout=$TIMEOUT" >> "$GITHUB_OUTPUT"
          echo "job-timeout=$JOB_TIMEOUT" >> "$GITHUB_OUTPUT"
          echo "‚è±Ô∏è Timeout: ${TIMEOUT} minutes (job timeout: ${JOB_TIMEOUT} minutes)"

  # ============================================================================
  # JOB 2: EXECUTE CLAUDE CODE
  #
  # Steps:
  # 1. Checkout PR branch
  # 2. Sync with main (detect conflicts)
  # 3. Configure agent based on failure type
  # 4. Run anthropics/claude-code-action@v1
  # 5. Push changes (handled by action)
  # ============================================================================
  execute:
    name: Execute Claude Code
    needs: validate
    if: needs.validate.outputs.is-valid == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: ${{ fromJSON(needs.validate.outputs.job-timeout) || 105 }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate.outputs.pr-branch }}
          token: ${{ secrets.GH_PAT_WORKFLOW }}
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: package.json

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Sync with main branch
        id: sync
        run: |
          git fetch origin main

          BEHIND=$(git rev-list --count HEAD..origin/main)
          echo "behind=$BEHIND" >> "$GITHUB_OUTPUT"

          if [ "$BEHIND" -gt 0 ]; then
            echo "üì• Main branch has $BEHIND new commits, merging..."

            if ! git merge origin/main --no-edit 2>&1 | tee /tmp/merge_output.txt; then
              echo "‚ö†Ô∏è Merge failed. Analyzing failure type..."

              # Check for actual merge conflicts using git status
              # Conflict markers: UU (both modified), AA (both added), DD (both deleted),
              # AU (added by us), UA (added by them), DU (deleted by us), UD (deleted by them)
              if git status --porcelain | grep -q '^UU\|^AA\|^DD\|^AU\|^UA\|^DU\|^UD'; then
                # Actual conflicts detected
                echo "has-conflict=true" >> "$GITHUB_OUTPUT"
                git diff --name-only --diff-filter=U > /tmp/conflicted_files.txt
                CONFLICT_FILES=$(cat /tmp/conflicted_files.txt | tr '\n' ', ' | sed 's/,$//')
                echo "conflict-files=$CONFLICT_FILES" >> "$GITHUB_OUTPUT"

                # Abort merge if in progress
                if [ -f .git/MERGE_HEAD ]; then
                  git merge --abort
                fi

                echo "‚ö†Ô∏è Merge conflict detected in: $CONFLICT_FILES"
                echo "üìù Conflict markers found in git status - requires manual resolution"
              else
                # No conflicts - merge failed for other reasons
                echo "has-conflict=false" >> "$GITHUB_OUTPUT"

                # Abort merge if in progress
                if [ -f .git/MERGE_HEAD ]; then
                  git merge --abort
                fi

                # Log error details
                echo "‚ùå Merge failed but no conflicts detected"
                echo "Merge output:"
                cat /tmp/merge_output.txt

                echo "Git status:"
                git status --porcelain

                # Fail the workflow - this is not a conflict, it's an error
                echo "::error::Merge with origin/main failed without conflicts. This may indicate a git error, network issue, or other problem. See logs for details."
                exit 1
              fi
            else
              echo "has-conflict=false" >> "$GITHUB_OUTPUT"
              git push origin HEAD
              echo "‚úÖ Successfully merged and pushed"
            fi
          else
            echo "has-conflict=false" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Already up to date with main"
          fi

      - name: Handle merge conflict
        if: steps.sync.outputs.has-conflict == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ needs.validate.outputs.pr-number }}
          CONFLICT_FILES: ${{ steps.sync.outputs.conflict-files }}
        run: |
          echo "‚ö†Ô∏è Merge conflict detected - exiting workflow early"
          echo "Conflict files: $CONFLICT_FILES"

          # Add manual-intervention label with timeout
          for attempt in {1..3}; do
            echo "üè∑Ô∏è Adding manual-intervention label (attempt $attempt/3)..."
            if timeout 60 gh pr edit "$PR_NUMBER" \
              --repo "${{ github.repository }}" \
              --add-label "tdd-automation:manual-intervention"; then
              echo "‚úÖ Label added successfully"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Label add failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::error::Failed to add label after 3 attempts"
            fi
          done

          # Disable auto-merge with timeout
          for attempt in {1..3}; do
            echo "üîí Disabling auto-merge (attempt $attempt/3)..."
            if timeout 60 gh pr merge "$PR_NUMBER" \
              --repo "${{ github.repository }}" \
              --disable-auto; then
              echo "‚úÖ Auto-merge disabled successfully"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Disable auto-merge failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::warning::Failed to disable auto-merge after 3 attempts"
            fi
          done

          # Post comment with conflict resolution instructions
          {
            echo "## ‚ö†Ô∏è Merge Conflict Detected"
            echo ""
            echo "**Affected Files:**"
            echo "\`\`\`"
            echo "$CONFLICT_FILES"
            echo "\`\`\`"
            echo ""
            echo "**Resolution Required:**"
            echo "This PR has merge conflicts with the \`main\` branch that must be resolved manually."
            echo ""
            echo "Auto-merge has been disabled. The \`tdd-automation:manual-intervention\` label will remain until you manually remove it after resolving conflicts."
          } > /tmp/merge_conflict.md

          # Post comment with timeout and retry logic
          for attempt in {1..3}; do
            echo "üìù Posting merge conflict comment (attempt $attempt/3)..."
            if timeout 60 gh pr comment "$PR_NUMBER" \
              --repo "${{ github.repository }}" \
              --body-file /tmp/merge_conflict.md; then
              echo "‚úÖ Comment posted successfully"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Comment posting failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::error::Failed to post comment after 3 attempts"
            fi
          done

          # Exit workflow early (don't run Claude Code on conflicts)
          exit 1

      - name: Determine model and budget
        id: model-config
        env:
          PR_TITLE: ${{ needs.validate.outputs.pr-title }}
        run: |
          # Parse PR title to extract attempt number
          # Title format: [TDD] Implement <spec-id> | Attempt X/Y
          if [[ "$PR_TITLE" =~ Attempt\ ([0-9]+)/([0-9]+) ]]; then
            ATTEMPT="${BASH_REMATCH[1]}"
            MAX_ATTEMPTS="${BASH_REMATCH[2]}"
            echo "üìä Attempt $ATTEMPT of $MAX_ATTEMPTS"
          else
            # Default to attempt 1 if title format is not recognized
            ATTEMPT=1
            MAX_ATTEMPTS=5
            echo "‚ö†Ô∏è Could not parse attempt number from PR title, defaulting to attempt 1"
          fi

          # Model escalation: Sonnet for attempts 1-3, Opus for attempts 4-5
          if [ "$ATTEMPT" -le 3 ]; then
            MODEL="claude-sonnet-4-5"
            BUDGET="10.00"
            echo "üß† Using Claude Sonnet 4.5 (attempt $ATTEMPT/3, \$10 budget)"
          else
            # Opus 4.6 supported by pinned action v1.0.47 (SDK 0.2.38 >= 0.2.32 minimum)
            MODEL="claude-opus-4-6"
            BUDGET="15.00"
            echo "üöÄ Using Claude Opus 4.6 (attempt $ATTEMPT, \$15 budget) - escalated for hard spec"
          fi

          {
            echo "model=$MODEL"
            echo "budget=$BUDGET"
            echo "attempt=$ATTEMPT"
          } >> "$GITHUB_OUTPUT"

      - name: Configure agent
        id: agent-config
        env:
          AGENT_TYPE: ${{ needs.validate.outputs.agent-type }}
          SPEC_ID: ${{ needs.validate.outputs.spec-id }}
          SPEC_FILE: ${{ needs.validate.outputs.spec-file }}
          ORIGINAL_COMMENT: ${{ github.event.comment.body }}
        run: |
          # Configure claude_args based on agent type
          # See: docs/development/tdd-automation-pipeline.md#agent-configurations

          if [ "$AGENT_TYPE" = "codebase-refactor-auditor" ]; then
            ALLOWED_TOOLS="Bash,Read,Write,Edit,Glob,Grep,Task,TodoWrite,LSP"
            DISALLOWED_TOOLS="WebFetch,WebSearch,Skill,AskUserQuestion,NotebookEdit"
            MAX_TURNS=40
          else
            # Default: e2e-test-fixer
            ALLOWED_TOOLS="Bash,Read,Write,Edit,Glob,Grep,Task,TodoWrite,LSP,Skill"
            DISALLOWED_TOOLS="WebFetch,WebSearch,AskUserQuestion,NotebookEdit"
            MAX_TURNS=60
          fi

          # Build claude_args for the action
          # NOTE: --mode was REMOVED in GA v1.0 (auto-detected by the action)
          # Previously used --mode execute to prevent plan-mode no-ops (PR #7211)
          # GA v1.0 handles mode detection internally ‚Äî do NOT pass --mode
          CLAUDE_ARGS="--max-turns $MAX_TURNS --allowedTools \"$ALLOWED_TOOLS\" --disallowedTools \"$DISALLOWED_TOOLS\""
          echo "claude-args=$CLAUDE_ARGS" >> "$GITHUB_OUTPUT"

          # Generate prompt using TypeScript (replaces 85+ lines of bash template logic)
          # CRITICAL: Must explicitly instruct Claude Code to invoke Task tool with subagent_type
          # Why: Agents are not activated by text instructions alone. They must be explicitly
          # invoked via the Task tool for their specialized system prompts and behaviors to activate.
          # Tool restrictions (--allowedTools) apply to the base assistant, not automatically to agents.

          # Export environment variables (TypeScript script supports both naming conventions)
          export agentType="$AGENT_TYPE"
          export specId="$SPEC_ID"
          export specFile="$SPEC_FILE"

          bun run scripts/tdd-automation/workflows/claude-code/generate-prompt.ts > /tmp/claude_prompt.txt

          # Store prompt for action
          PROMPT=$(cat /tmp/claude_prompt.txt)
          {
            echo "prompt<<EOF"
            echo "$PROMPT"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Detach HEAD before Claude Code
        run: |
          # CRITICAL: Detach HEAD so claude-code-action can fetch the PR branch
          # Without this, git refuses: "fatal: refusing to fetch into branch checked out at..."
          # The action handles its own checkout internally via git fetch pull/N/head:branch
          # See: https://github.com/sovrium/sovrium/actions/runs/21898811482/job/63221500705
          git checkout --detach HEAD
          echo "‚úÖ HEAD detached - claude-code-action can now fetch the PR branch"

      # Pinned to v1.0.47 (SDK 0.2.38) ‚Äî last known working version before AJV crash in SDK 0.2.39+
      # SDK 0.2.9 (our previous pin) crashes with "exit code 1" ‚Äî too old for current runtime
      # See: https://github.com/anthropics/claude-code-action/issues/892
      # TODO: Unpin to @v1 when SDK fix ships beyond 0.2.39
      - name: Run Claude Code Action
        id: claude-code
        continue-on-error: true
        uses: anthropics/claude-code-action@b433f16b30d54063fd3bab6b12f46f3da00e41b6
        timeout-minutes: ${{ fromJSON(needs.validate.outputs.timeout) || 90 }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: ${{ steps.agent-config.outputs.prompt }}
          claude_args: ${{ steps.agent-config.outputs.claude-args }} --model ${{ steps.model-config.outputs.model }} --max-budget-usd ${{ steps.model-config.outputs.budget }}
          track_progress: true
          use_sticky_comment: true

      # Pinned to v1.0.47 (SDK 0.2.38) ‚Äî same pin as primary step above
      # See: https://github.com/anthropics/claude-code-action/issues/892
      # TODO: Unpin to @v1 when SDK fix ships beyond 0.2.39
      - name: Retry Claude Code on SDK Crash
        id: claude-code-retry
        if: steps.claude-code.outcome == 'failure' && steps.claude-code.outputs.execution_file == ''
        continue-on-error: true
        uses: anthropics/claude-code-action@b433f16b30d54063fd3bab6b12f46f3da00e41b6
        timeout-minutes: ${{ fromJSON(needs.validate.outputs.timeout) || 90 }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: ${{ steps.agent-config.outputs.prompt }}
          claude_args: ${{ steps.agent-config.outputs.claude-args }} --model ${{ steps.model-config.outputs.model }} --max-budget-usd ${{ steps.model-config.outputs.budget }}
          track_progress: true
          use_sticky_comment: true

      - name: Determine Final Outcome
        id: final-outcome
        if: always()
        run: |
          # Determine which attempt's result to use
          # If retry actually ran (outcome != skipped), use retry outputs; otherwise use original outputs

          RETRY_OUTCOME="${{ steps.claude-code-retry.outcome }}"

          if [ -n "$RETRY_OUTCOME" ] && [ "$RETRY_OUTCOME" != "skipped" ]; then
            # Retry actually ran - use retry outputs
            EXECUTION_FILE="${{ steps.claude-code-retry.outputs.execution_file }}"
            # CRITICAL: Use 'outcome' not 'conclusion' for continue-on-error steps
            # 'conclusion' is always 'success' when continue-on-error: true
            # 'outcome' reflects the actual result (success/failure/cancelled)
            CONCLUSION="${{ steps.claude-code-retry.outcome }}"
            echo "üìä Using retry attempt result (original attempt had SDK crash)"
          else
            # Retry didn't run - use original outputs
            EXECUTION_FILE="${{ steps.claude-code.outputs.execution_file }}"
            CONCLUSION="${{ steps.claude-code.outcome }}"
            echo "üìä Using original attempt result"
          fi

          # Write outputs for subsequent steps
          echo "execution_file=$EXECUTION_FILE" >> "$GITHUB_OUTPUT"
          echo "conclusion=$CONCLUSION" >> "$GITHUB_OUTPUT"

          echo "   Execution file: ${EXECUTION_FILE:-(empty)}"
          echo "   Conclusion: $CONCLUSION"

      - name: Parse Claude Code Result
        id: parse-result
        if: always()
        env:
          EXECUTION_FILE: ${{ steps.final-outcome.outputs.execution_file }}
          CONCLUSION: ${{ steps.final-outcome.outputs.conclusion }}
          CLAUDE_CODE_OUTCOME: ${{ steps.claude-code.outcome }}
          CLAUDE_CODE_RETRY_OUTCOME: ${{ steps.claude-code-retry.outcome }}
          CONFIGURED_TIMEOUT: ${{ needs.validate.outputs.timeout }}
        run: |
          # Parse Claude Code execution result
          # Output structure: { type: "result", subtype: "success" | "error_max_turns" | "error_max_budget_usd" | "error_during_execution" | "error_max_structured_output_retries" }

          RESULT_SUBTYPE=""
          ERROR_MESSAGE=""

          # Detect timeout: both attempts failed/cancelled AND no execution file
          # When a step hits timeout-minutes, GitHub Actions cancels it
          if [ "$CLAUDE_CODE_OUTCOME" = "cancelled" ] || [ "$CLAUDE_CODE_RETRY_OUTCOME" = "cancelled" ]; then
            echo "result-subtype=timeout" >> "$GITHUB_OUTPUT"
            echo "error-message=Claude Code execution exceeded the configured timeout of ${CONFIGURED_TIMEOUT:-90} minutes" >> "$GITHUB_OUTPUT"
            echo "‚è±Ô∏è Claude Code execution timed out (${CONFIGURED_TIMEOUT:-90} minutes)"
            exit 1
          fi

          if [ "$CONCLUSION" = "success" ]; then
            RESULT_SUBTYPE="success"
            echo "result-subtype=success" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Claude Code execution succeeded"
            exit 0
          fi

          if [ -f "$EXECUTION_FILE" ]; then
            # Extract result message from execution file
            RESULT_JSON=$(jq -r '.[] | select(.type == "result")' "$EXECUTION_FILE" 2>/dev/null || echo "{}")
            RESULT_SUBTYPE=$(echo "$RESULT_JSON" | jq -r '.subtype // "unknown"')
            ERROR_MESSAGE=$(echo "$RESULT_JSON" | jq -r '.errors // [] | join(", ")' 2>/dev/null || echo "")

            echo "result-subtype=$RESULT_SUBTYPE" >> "$GITHUB_OUTPUT"
            echo "error-message=$ERROR_MESSAGE" >> "$GITHUB_OUTPUT"
            echo "üìä Result subtype: $RESULT_SUBTYPE"
            [ -n "$ERROR_MESSAGE" ] && echo "‚ö†Ô∏è Error message: $ERROR_MESSAGE"

            # Exit with appropriate code based on result subtype
            if [ "$RESULT_SUBTYPE" = "success" ]; then
              echo "‚úÖ Claude Code execution succeeded"
              exit 0
            else
              echo "‚ùå Claude Code execution failed: $RESULT_SUBTYPE"
              exit 1
            fi
          else
            # No execution file and step failed ‚Üí likely timeout or crash
            # Check if failure happened without producing any output (timeout signature)
            if [ "$CLAUDE_CODE_OUTCOME" = "failure" ] && [ -z "$EXECUTION_FILE" ]; then
              echo "result-subtype=timeout" >> "$GITHUB_OUTPUT"
              echo "error-message=Claude Code execution likely timed out (no execution file produced, timeout: ${CONFIGURED_TIMEOUT:-90} min)" >> "$GITHUB_OUTPUT"
              echo "‚è±Ô∏è Likely timeout: no execution file produced"
            else
              echo "result-subtype=unknown" >> "$GITHUB_OUTPUT"
              echo "error-message=Execution file not found" >> "$GITHUB_OUTPUT"
              echo "‚ùå No execution file found"
            fi
            exit 1
          fi

      - name: Extract Execution Metrics
        id: extract-metrics
        if: always()
        env:
          EXECUTION_FILE: ${{ steps.final-outcome.outputs.execution_file }}
        run: |
          # Extract execution metrics from Claude Code result JSON
          # Metrics: duration_ms, num_turns, total_cost_usd

          if [ -f "$EXECUTION_FILE" ]; then
            RESULT_JSON=$(jq -r '.[] | select(.type == "result")' "$EXECUTION_FILE" 2>/dev/null || echo "{}")

            # Extract metrics with fallbacks
            DURATION_MS=$(echo "$RESULT_JSON" | jq -r '.duration_ms // 0')
            NUM_TURNS=$(echo "$RESULT_JSON" | jq -r '.num_turns // 0')
            TOTAL_COST=$(echo "$RESULT_JSON" | jq -r '.total_cost_usd // 0')

            # Convert duration to human-readable format (e.g., "10m 26s")
            DURATION_SECONDS=$((DURATION_MS / 1000))
            DURATION_MINUTES=$((DURATION_SECONDS / 60))
            DURATION_REMAINDER=$((DURATION_SECONDS % 60))
            DURATION_FORMATTED="${DURATION_MINUTES}m ${DURATION_REMAINDER}s"

            # Format cost to 2 decimal places
            COST_FORMATTED=$(printf "%.2f" "$TOTAL_COST")

            {
              echo "duration-ms=$DURATION_MS"
              echo "duration-formatted=$DURATION_FORMATTED"
              echo "num-turns=$NUM_TURNS"
              echo "total-cost=$COST_FORMATTED"
            } >> "$GITHUB_OUTPUT"

            echo "üìä Execution Metrics:"
            echo "   Duration: $DURATION_FORMATTED ($DURATION_MS ms)"
            echo "   Turns: $NUM_TURNS"
            echo "   Total Cost: \$$COST_FORMATTED"
          else
            {
              echo "duration-ms=0"
              echo "duration-formatted=N/A"
              echo "num-turns=0"
              echo "total-cost=0.00"
            } >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è No execution file found - metrics unavailable"
          fi

      - name: Detect Zero-Turn Execution (No-Op)
        id: zero-turn-check
        if: always() && steps.parse-result.outputs.result-subtype == 'success'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ needs.validate.outputs.pr-number }}
          NUM_TURNS: ${{ steps.extract-metrics.outputs.num-turns }}
          TOTAL_COST: ${{ steps.extract-metrics.outputs.total-cost }}
          SPEC_ID: ${{ needs.validate.outputs.spec-id }}
        run: |
          # Detect zero-turn executions where Claude Code exits without doing work
          # Common cause: .claude/settings.json defaultMode=plan overriding --mode execute
          # This step acts as a safety net to catch future misconfigurations

          if [ "$NUM_TURNS" = "0" ] && [ "$TOTAL_COST" = "0.00" ]; then
            echo "is-zero-turn=true" >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è Zero-turn execution detected (0 turns, \$0.00 cost)"
            echo "Claude Code started but exited without performing any work."

            # Post diagnostic comment
            {
              echo "## ‚ö†Ô∏è Zero-Turn Execution Detected"
              echo ""
              echo "**Spec ID**: \`$SPEC_ID\`"
              echo ""
              echo "Claude Code reported success but completed **0 turns** with **\$0.00 cost**."
              echo "This means the agent started but exited without performing any work."
              echo ""
              echo "**Common Causes**:"
              echo "- \`.claude/settings.json\` has \`defaultMode: plan\` (overrides \`--mode execute\`)"
              echo "- Prompt parsing failure (agent didn't understand the task)"
              echo "- Tool permission restrictions preventing the agent from working"
              echo ""
              echo "**Diagnostic Info**:"
              echo "- Configured mode: \`--mode execute\`"
              echo "- Turns: $NUM_TURNS"
              echo "- Cost: \$$TOTAL_COST"
              echo ""
              echo "**Next Steps**:"
              echo "1. Check \`.claude/settings.json\` for \`defaultMode\` override"
              echo "2. Review Claude Code action logs for early exit reasons"
              echo "3. Post \`@claude e2e-test-fixer\` to retry"
            } > /tmp/zero_turn.md

            # Post comment and add label
            gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/zero_turn.md
            gh pr edit "$PR_NUMBER" --repo "${{ github.repository }}" --add-label "tdd-automation:manual-intervention"

            echo "üìù Zero-turn diagnostic comment posted, manual-intervention label added"
          else
            echo "is-zero-turn=false" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Execution had $NUM_TURNS turn(s) - not a zero-turn no-op"
          fi

      - name: Post Success Comment with Metrics
        if: steps.parse-result.outputs.result-subtype == 'success' && steps.zero-turn-check.outputs.is-zero-turn != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ needs.validate.outputs.pr-number }}
          DURATION: ${{ steps.extract-metrics.outputs.duration-formatted }}
          TURNS: ${{ steps.extract-metrics.outputs.num-turns }}
          COST: ${{ steps.extract-metrics.outputs.total-cost }}
        run: |
          # Post success comment with execution metrics
          {
            echo "‚úÖ **Claude Code Execution Succeeded**"
            echo ""
            echo "**Execution Metrics**:"
            echo "- **Duration**: $DURATION"
            echo "- **Turns**: $TURNS"
            echo "- **Total Cost**: \$$COST"
            echo ""
            echo "Changes pushed successfully. Tests will run next."
          } > /tmp/success_comment.md

          # Post comment with timeout and retry logic
          for attempt in {1..3}; do
            echo "üìù Posting success comment (attempt $attempt/3)..."
            if timeout 60 gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/success_comment.md; then
              echo "‚úÖ Success comment with metrics posted"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Comment posting failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::warning::Failed to post success comment after 3 attempts"
            fi
          done

      - name: Detect No Commits Pushed (Silent Failure)
        id: check-commits
        if: always() && (steps.parse-result.outputs.result-subtype == 'success' || steps.parse-result.outputs.result-subtype == 'unknown')
        run: |
          # Safety check: Verify commits were actually pushed
          # Uses SHA comparison instead of commit counting to avoid backwards comparison bug
          #
          # Expected scenarios:
          # 1. Local HEAD = Remote ‚Üí Successful push ‚Üí has-commits=true
          # 2. Local ahead of Remote ‚Üí Push failed ‚Üí has-commits=false (diagnostic info)
          # 3. Remote ahead of Local ‚Üí Unexpected state ‚Üí has-commits=unknown (warning)
          # 4. Fetch failure ‚Üí Error handling ‚Üí has-commits=unknown

          # Fetch remote branch to get latest SHA
          if ! git fetch origin ${{ needs.validate.outputs.pr-branch }} 2>/dev/null; then
            echo "has-commits=unknown" >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è Warning: Cannot fetch remote branch for commit verification"
            echo "This may indicate network issues or branch deletion."
            exit 0
          fi

          # Get SHAs for comparison
          LOCAL_SHA=$(git rev-parse HEAD)
          REMOTE_SHA=$(git rev-parse origin/${{ needs.validate.outputs.pr-branch }})

          echo "üîç Commit Verification:"
          echo "  Local HEAD:  $LOCAL_SHA"
          echo "  Remote HEAD: $REMOTE_SHA"

          if [ "$LOCAL_SHA" = "$REMOTE_SHA" ]; then
            # SUCCESS: Local and remote are in sync (push succeeded)
            echo "has-commits=true" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Commits pushed successfully - local and remote are in sync"
          else
            # Determine which is ahead to provide actionable diagnostics
            LOCAL_AHEAD=$(git rev-list --count origin/${{ needs.validate.outputs.pr-branch }}..HEAD 2>/dev/null || echo "0")
            REMOTE_AHEAD=$(git rev-list --count HEAD..origin/${{ needs.validate.outputs.pr-branch }} 2>/dev/null || echo "0")

            echo "  Local ahead:  $LOCAL_AHEAD commits"
            echo "  Remote ahead: $REMOTE_AHEAD commits"

            if [ "$LOCAL_AHEAD" -gt 0 ] && [ "$REMOTE_AHEAD" -eq 0 ]; then
              # FAILURE: Local has commits that weren't pushed
              echo "has-commits=false" >> "$GITHUB_OUTPUT"
              echo "‚ö†Ô∏è Push failure detected - local has $LOCAL_AHEAD unpushed commit(s)"
              echo "This indicates Claude Code succeeded but git push failed silently."
            elif [ "$REMOTE_AHEAD" -gt 0 ]; then
              # UNEXPECTED: Remote is ahead (should not happen in normal flow)
              echo "has-commits=unknown" >> "$GITHUB_OUTPUT"
              echo "‚ö†Ô∏è Unexpected state - remote is $REMOTE_AHEAD commit(s) ahead of local"
              echo "This may indicate concurrent modifications or workflow timing issues."
            else
              # DIVERGED: Both ahead (conflict state)
              echo "has-commits=unknown" >> "$GITHUB_OUTPUT"
              echo "‚ö†Ô∏è Branches have diverged - local: +$LOCAL_AHEAD, remote: +$REMOTE_AHEAD"
              echo "This indicates a merge conflict or concurrent workflow execution."
            fi
          fi

      - name: Handle Claude Code Error
        if: (steps.parse-result.outputs.result-subtype != 'success' || steps.check-commits.outputs.has-commits == 'false') && steps.zero-turn-check.outputs.is-zero-turn != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ needs.validate.outputs.pr-number }}
          RESULT_SUBTYPE: ${{ steps.parse-result.outputs.result-subtype }}
          ERROR_MESSAGE: ${{ steps.parse-result.outputs.error-message }}
          SPEC_ID: ${{ needs.validate.outputs.spec-id }}
          NO_COMMITS: ${{ steps.check-commits.outputs.has-commits == 'false' }}
        run: |
          # Simplified error handling: ALL errors ‚Üí post comment ‚Üí add label ‚Üí trigger PR Creator
          # PR stays open for manual review - other specs continue processing automatically

          if [ "$NO_COMMITS" = "true" ]; then
            echo "‚ùå Claude Code execution succeeded but no commits were pushed (silent failure)"
            ACTUAL_ERROR="no_commits_pushed"
          else
            echo "‚ùå Claude Code execution failed: $RESULT_SUBTYPE"
            ACTUAL_ERROR="$RESULT_SUBTYPE"
          fi

          # Add manual-intervention label
          gh pr edit "$PR_NUMBER" --repo "${{ github.repository }}" --add-label "tdd-automation:manual-intervention"

          # Post error comment with execution metrics
          if [ "$NO_COMMITS" = "true" ]; then
            {
              echo "‚ùå **Claude Code Silent Failure Detected**"
              echo ""
              echo "**Issue**: Claude Code reported success but no commits were pushed."
              echo "**Spec ID**: \`$SPEC_ID\`"
              echo ""
              echo "**Possible Causes**:"
              echo "- Agent completed execution without making changes"
              echo "- Git push failed silently"
              echo "- Workflow timeout during push"
              echo ""
              echo "**Execution Metrics**:"
              echo "- **Duration**: ${{ steps.extract-metrics.outputs.duration-formatted }}"
              echo "- **Turns**: ${{ steps.extract-metrics.outputs.num-turns }}"
              echo "- **Total Cost**: \$${{ steps.extract-metrics.outputs.total-cost }}"
              echo ""
              echo "**Next Steps**:"
              echo "1. Review Claude Code execution logs"
              echo "2. Check if implementation was attempted"
              echo "3. Remove \`tdd-automation:manual-intervention\` label after investigation"
              echo "4. Post \`@claude\` comment to retry if needed"
              echo ""
              echo "---"
              echo "_TDD Automation paused for this spec - pipeline continues with next spec_"
            } > /tmp/error_comment.md
          else
            {
              echo "‚ùå **Claude Code Execution Failed**"
              echo ""
              echo "**Error Type**: \`$ACTUAL_ERROR\`"
              echo "**Spec ID**: \`$SPEC_ID\`"
              echo ""
              echo "**Error Details**:"
              echo "\`\`\`"
              echo "$ERROR_MESSAGE"
              echo "\`\`\`"
              echo ""
              echo "**Execution Metrics**:"
              echo "- **Duration**: ${{ steps.extract-metrics.outputs.duration-formatted }}"
              echo "- **Turns**: ${{ steps.extract-metrics.outputs.num-turns }}"
              echo "- **Total Cost**: \$${{ steps.extract-metrics.outputs.total-cost }}"
              echo ""
              echo "**Next Steps**:"
              echo "1. Review error details above"
              echo "2. Check execution logs for root cause"
              echo "3. Remove \`tdd-automation:manual-intervention\` label after fixing"
              echo "4. Post \`@claude\` comment to retry"
              echo ""
              echo "---"
              echo "_TDD Automation paused for this spec - pipeline continues with next spec_"
            } > /tmp/error_comment.md
          fi

          # Add manual-intervention label with timeout
          for attempt in {1..3}; do
            echo "üè∑Ô∏è Adding manual-intervention label (attempt $attempt/3)..."
            if timeout 60 gh pr edit "$PR_NUMBER" --repo "${{ github.repository }}" --add-label "tdd-automation:manual-intervention"; then
              echo "‚úÖ Label added successfully"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Label add failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::error::Failed to add label after 3 attempts"
            fi
          done

          # Post error comment with timeout and retry logic
          for attempt in {1..3}; do
            echo "üìù Posting error comment (attempt $attempt/3)..."
            if timeout 60 gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/error_comment.md; then
              echo "‚úÖ Error comment posted successfully"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Comment posting failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::error::Failed to post error comment after 3 attempts"
            fi
          done

          # Trigger PR Creator to pick up next spec with timeout
          for attempt in {1..3}; do
            echo "üîÑ Triggering PR Creator workflow (attempt $attempt/3)..."
            if timeout 60 gh workflow run tdd-pr-creator.yml --repo "${{ github.repository }}"; then
              echo "‚úÖ PR Creator triggered successfully"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Workflow trigger failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::warning::Failed to trigger PR Creator after 3 attempts"
            fi
          done

          echo "‚úÖ Error handled - PR kept open with manual-intervention label, PR Creator triggered for next spec"

      - name: Catch-All Error Handler (Workflow Failures)
        id: catch-all-error
        if: failure() || cancelled() # Runs on step failure OR job cancellation (e.g., timeout)
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ needs.validate.outputs.pr-number }}
          SPEC_ID: ${{ needs.validate.outputs.spec-id }}
          CONFIGURED_TIMEOUT: ${{ needs.validate.outputs.timeout }}
        run: |
          # Catch-all safety net for unexpected workflow failures and timeouts
          # Adds manual-intervention label if not already added

          echo "‚ö†Ô∏è Workflow failure/cancellation detected - checking if manual-intervention label exists"

          # Check if label already added by previous step
          LABELS=$(gh pr view "$PR_NUMBER" --repo "${{ github.repository }}" --json labels --jq '.labels[].name' 2>/dev/null || echo "")
          if echo "$LABELS" | grep -q "tdd-automation:manual-intervention"; then
            echo "‚úÖ manual-intervention label already present - skipping"
            exit 0
          fi

          echo "üè∑Ô∏è Adding manual-intervention label (catch-all handler)"

          # Add manual-intervention label with timeout
          for attempt in {1..3}; do
            echo "üè∑Ô∏è Adding manual-intervention label (attempt $attempt/3)..."
            if timeout 60 gh pr edit "$PR_NUMBER" --repo "${{ github.repository }}" --add-label "tdd-automation:manual-intervention"; then
              echo "‚úÖ Label added successfully"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Label add failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::error::Failed to add label after 3 attempts"
            fi
          done

          # Post error comment with timeout-specific guidance
          {
            echo "‚ùå **Workflow Execution Error**"
            echo ""
            echo "**Spec ID**: \`$SPEC_ID\`"
            echo ""
            echo "**Issue**: The workflow encountered an unexpected error during execution."
            echo ""
            echo "**Possible Causes**:"
            echo "- Workflow timeout (exceeded ${CONFIGURED_TIMEOUT:-90} minutes)"
            echo "- Claude Code action crash"
            echo "- Git operation failure"
            echo "- GitHub API error"
            echo ""
            echo "**Next Steps**:"
            echo "1. Review workflow logs for detailed error messages"
            echo "2. Check GitHub Actions run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            echo "3. If timeout: consider adding \`@tdd-timeout <minutes>\` annotation to the spec file"
            echo "4. Remove \`tdd-automation:manual-intervention\` label after investigation"
            echo "5. Post \`@claude\` comment to retry if issue is resolved"
            echo ""
            echo "---"
            echo "_TDD Automation paused for this spec - pipeline continues with next spec_"
          } > /tmp/catch_all_error.md

          # Post comment with timeout and retry logic
          for attempt in {1..3}; do
            echo "üìù Posting catch-all error comment (attempt $attempt/3)..."
            if timeout 60 gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/catch_all_error.md; then
              echo "‚úÖ Comment posted successfully"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Comment posting failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::warning::Failed to post catch-all error comment after 3 attempts"
            fi
          done

          # Trigger PR Creator to pick up next spec with timeout
          for attempt in {1..3}; do
            echo "üîÑ Triggering PR Creator workflow (attempt $attempt/3)..."
            if timeout 60 gh workflow run tdd-pr-creator.yml --repo "${{ github.repository }}"; then
              echo "‚úÖ PR Creator triggered successfully"
              break
            fi

            if [ "$attempt" -lt 3 ]; then
              echo "::warning::Workflow trigger failed (attempt $attempt/3), retrying in 10s..."
              sleep 10
            else
              echo "::warning::Failed to trigger PR Creator after 3 attempts"
            fi
          done

          echo "‚úÖ Catch-all error handled - manual-intervention label added"

      - name: Final sync with main branch
        id: final-sync
        if: always() # Run even if Claude Code failed
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_WORKFLOW }}
          PR_NUMBER: ${{ needs.validate.outputs.pr-number }}
        run: |
          echo "üîÑ Performing final sync with main branch..."
          git fetch origin main

          BEHIND=$(git rev-list --count HEAD..origin/main)

          if [ "$BEHIND" -gt 0 ]; then
            echo "üì• Main branch has $BEHIND new commits since execution started, merging..."

            if ! git merge origin/main --no-edit 2>&1 | tee /tmp/final_merge_output.txt; then
              echo "‚ö†Ô∏è Post-execution merge conflict detected"

              # Check for actual merge conflicts
              if git status --porcelain | grep -q '^UU\|^AA\|^DD\|^AU\|^UA\|^DU\|^UD'; then
                # Get conflicted files
                git diff --name-only --diff-filter=U > /tmp/final_conflicted_files.txt
                CONFLICT_FILES=$(cat /tmp/final_conflicted_files.txt | tr '\n' ', ' | sed 's/,$//')

                # Add manual-intervention label with timeout
                for attempt in {1..3}; do
                  echo "üè∑Ô∏è Adding manual-intervention label (attempt $attempt/3)..."
                  if timeout 60 gh pr edit "$PR_NUMBER" \
                    --repo "${{ github.repository }}" \
                    --add-label "tdd-automation:manual-intervention"; then
                    echo "‚úÖ Label added successfully"
                    break
                  fi

                  if [ "$attempt" -lt 3 ]; then
                    echo "::warning::Label add failed (attempt $attempt/3), retrying in 10s..."
                    sleep 10
                  else
                    echo "::error::Failed to add label after 3 attempts"
                  fi
                done

                # Post comment about post-execution conflict
                {
                  echo "## ‚ö†Ô∏è Post-Execution Merge Conflict"
                  echo ""
                  echo "Main branch was updated during Claude Code execution."
                  echo ""
                  echo "**Affected Files:**"
                  echo "\`\`\`"
                  echo "$CONFLICT_FILES"
                  echo "\`\`\`"
                  echo ""
                  echo "**Resolution Required:**"
                  echo "1. Resolve conflicts manually in the files above"
                  echo "2. Push changes to update the PR"
                  echo "3. Tests will run automatically after push"
                  echo ""
                  echo "**Note**: Claude Code execution completed successfully, but main branch conflicts prevent auto-merge."
                } > /tmp/final_conflict.md

                # Post comment with timeout and retry logic
                for attempt in {1..3}; do
                  echo "üìù Posting post-execution conflict comment (attempt $attempt/3)..."
                  if timeout 60 gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body-file /tmp/final_conflict.md; then
                    echo "‚úÖ Comment posted successfully"
                    break
                  fi

                  if [ "$attempt" -lt 3 ]; then
                    echo "::warning::Comment posting failed (attempt $attempt/3), retrying in 10s..."
                    sleep 10
                  else
                    echo "::warning::Failed to post post-execution conflict comment after 3 attempts"
                  fi
                done

                # Abort merge
                git merge --abort

                echo "‚ùå Post-execution merge conflict - manual intervention required"
                exit 1
              else
                # Merge failed for other reasons
                echo "‚ùå Merge failed but no conflicts detected"
                echo "Merge output:"
                cat /tmp/final_merge_output.txt

                git merge --abort 2>/dev/null || true

                echo "::error::Final merge with origin/main failed without conflicts. This may indicate a git error or network issue."
                exit 1
              fi
            else
              git push origin HEAD
              echo "‚úÖ Successfully synced with main after execution ($BEHIND commits merged)"
            fi
          else
            echo "‚úÖ Already up to date with main - no sync needed"
          fi
