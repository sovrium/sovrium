{
  "title": "Modify Indexes Migration",
  "description": "Runtime SQL migration scenarios for adding, removing, and modifying database indexes via CREATE INDEX and DROP INDEX",
  "x-specs": [
    {
      "id": "MIG-MODIFY-INDEX-001",
      "given": "table 'products' with no custom indexes",
      "when": "new single-column index added to 'indexes' property",
      "then": "CREATE INDEX creates btree index on specified field",
      "validation": {
        "setup": {
          "previousSchema": {
            "id": "tbl_products",
            "name": "products",
            "fields": [
              {
                "id": 1,
                "name": "sku",
                "type": "single-line-text",
                "required": true
              },
              {
                "id": 2,
                "name": "name",
                "type": "single-line-text",
                "required": true
              },
              {
                "id": 3,
                "name": "category",
                "type": "single-select"
              }
            ],
            "indexes": []
          },
          "newSchema": {
            "id": "tbl_products",
            "name": "products",
            "fields": [
              {
                "id": 1,
                "name": "sku",
                "type": "single-line-text",
                "required": true
              },
              {
                "id": 2,
                "name": "name",
                "type": "single-line-text",
                "required": true
              },
              {
                "id": 3,
                "name": "category",
                "type": "single-select"
              }
            ],
            "indexes": [
              {
                "name": "idx_products_category",
                "fields": ["category"]
              }
            ]
          },
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, sku VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, category VARCHAR(50))",
            "INSERT INTO products (sku, name, category) VALUES ('SKU-001', 'Product 1', 'Electronics'), ('SKU-002', 'Product 2', 'Clothing')"
          ]
        },
        "assertions": [
          {
            "description": "SQL migration contains CREATE INDEX",
            "sqlGeneration": {
              "contains": ["CREATE INDEX idx_products_category ON \"products\"(category)"]
            }
          },
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_products_category'",
            "expected": {
              "indexname": "idx_products_category",
              "tablename": "products"
            }
          },
          {
            "description": "Index uses btree access method",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_products_category'",
            "expected": {
              "indexdef": "CREATE INDEX idx_products_category ON public.products USING btree (category)"
            }
          },
          {
            "description": "Query uses index for lookups",
            "executeQuery": "SELECT COUNT(*) as count FROM products WHERE category = 'Electronics'",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "MIG-MODIFY-INDEX-002",
      "given": "table 'contacts' with no indexes",
      "when": "composite index on (last_name, first_name) added",
      "then": "CREATE INDEX creates multi-column btree index",
      "validation": {
        "setup": {
          "previousSchema": {
            "id": "tbl_contacts",
            "name": "contacts",
            "fields": [
              {
                "id": 1,
                "name": "first_name",
                "type": "single-line-text"
              },
              {
                "id": 2,
                "name": "last_name",
                "type": "single-line-text"
              },
              {
                "id": 3,
                "name": "email",
                "type": "email"
              }
            ],
            "indexes": []
          },
          "newSchema": {
            "id": "tbl_contacts",
            "name": "contacts",
            "fields": [
              {
                "id": 1,
                "name": "first_name",
                "type": "single-line-text"
              },
              {
                "id": 2,
                "name": "last_name",
                "type": "single-line-text"
              },
              {
                "id": 3,
                "name": "email",
                "type": "email"
              }
            ],
            "indexes": [
              {
                "name": "idx_contacts_name",
                "fields": ["last_name", "first_name"]
              }
            ]
          },
          "executeQuery": [
            "CREATE TABLE contacts (id SERIAL PRIMARY KEY, first_name VARCHAR(255), last_name VARCHAR(255), email VARCHAR(255))",
            "INSERT INTO contacts (first_name, last_name, email) VALUES ('Alice', 'Smith', 'alice@example.com'), ('Bob', 'Smith', 'bob@example.com')"
          ]
        },
        "assertions": [
          {
            "description": "CREATE composite INDEX",
            "sqlGeneration": {
              "contains": ["CREATE INDEX idx_contacts_name ON \"contacts\"(last_name, first_name)"]
            }
          },
          {
            "description": "Composite index exists",
            "executeQuery": "SELECT indexname FROM pg_indexes WHERE indexname = 'idx_contacts_name'",
            "expected": {
              "indexname": "idx_contacts_name"
            }
          },
          {
            "description": "Index includes both columns in order",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_contacts_name'",
            "expected": {
              "indexdef": "CREATE INDEX idx_contacts_name ON public.contacts USING btree (last_name, first_name)"
            }
          },
          {
            "description": "Query by last_name uses index",
            "executeQuery": "SELECT COUNT(*) as count FROM contacts WHERE last_name = 'Smith'",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    },
    {
      "id": "MIG-MODIFY-INDEX-003",
      "given": "table 'users' with existing index idx_users_email",
      "when": "index removed from 'indexes' property",
      "then": "DROP INDEX removes index from table",
      "validation": {
        "setup": {
          "previousSchema": {
            "id": "tbl_users",
            "name": "users",
            "fields": [
              {
                "id": 1,
                "name": "email",
                "type": "email"
              },
              {
                "id": 2,
                "name": "name",
                "type": "single-line-text"
              }
            ],
            "indexes": [
              {
                "name": "idx_users_email",
                "fields": ["email"]
              }
            ]
          },
          "newSchema": {
            "id": "tbl_users",
            "name": "users",
            "fields": [
              {
                "id": 1,
                "name": "email",
                "type": "email"
              },
              {
                "id": 2,
                "name": "name",
                "type": "single-line-text"
              }
            ],
            "indexes": []
          },
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, email VARCHAR(255), name VARCHAR(255))",
            "CREATE INDEX idx_users_email ON users(email)",
            "INSERT INTO users (email, name) VALUES ('alice@example.com', 'Alice')"
          ]
        },
        "assertions": [
          {
            "description": "SQL migration contains DROP INDEX",
            "sqlGeneration": {
              "contains": ["DROP INDEX idx_users_email"]
            }
          },
          {
            "description": "Index no longer exists",
            "executeQuery": "SELECT COUNT(*) as count FROM pg_indexes WHERE indexname = 'idx_users_email'",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Table still has primary key index",
            "executeQuery": "SELECT COUNT(*) as count FROM pg_indexes WHERE tablename = 'users'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Data preserved after DROP INDEX",
            "executeQuery": "SELECT COUNT(*) as count FROM users",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "MIG-MODIFY-INDEX-004",
      "given": "table 'orders' with index on single field 'customer_id'",
      "when": "index modified to be composite (customer_id, created_at)",
      "then": "DROP old index and CREATE new composite index",
      "validation": {
        "setup": {
          "previousSchema": {
            "id": "tbl_orders",
            "name": "orders",
            "fields": [
              {
                "id": 1,
                "name": "customer_id",
                "type": "integer"
              },
              {
                "id": 2,
                "name": "created_at",
                "type": "datetime"
              },
              {
                "id": 3,
                "name": "total",
                "type": "decimal"
              }
            ],
            "indexes": [
              {
                "name": "idx_orders_customer",
                "fields": ["customer_id"]
              }
            ]
          },
          "newSchema": {
            "id": "tbl_orders",
            "name": "orders",
            "fields": [
              {
                "id": 1,
                "name": "customer_id",
                "type": "integer"
              },
              {
                "id": 2,
                "name": "created_at",
                "type": "datetime"
              },
              {
                "id": 3,
                "name": "total",
                "type": "decimal"
              }
            ],
            "indexes": [
              {
                "name": "idx_orders_customer_date",
                "fields": ["customer_id", "created_at"]
              }
            ]
          },
          "executeQuery": [
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, customer_id INTEGER, created_at TIMESTAMPTZ, total NUMERIC(10,2))",
            "CREATE INDEX idx_orders_customer ON orders(customer_id)",
            "INSERT INTO orders (customer_id, created_at, total) VALUES (1, NOW(), 99.99)"
          ]
        },
        "assertions": [
          {
            "description": "DROP old index and CREATE new",
            "sqlGeneration": {
              "contains": [
                "DROP INDEX idx_orders_customer",
                "CREATE INDEX idx_orders_customer_date ON \"orders\"(customer_id, created_at)"
              ]
            }
          },
          {
            "description": "Old index removed",
            "executeQuery": "SELECT COUNT(*) as count FROM pg_indexes WHERE indexname = 'idx_orders_customer'",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "New composite index exists",
            "executeQuery": "SELECT indexname FROM pg_indexes WHERE indexname = 'idx_orders_customer_date'",
            "expected": {
              "indexname": "idx_orders_customer_date"
            }
          },
          {
            "description": "Composite index definition correct",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_orders_customer_date'",
            "expected": {
              "indexdef": "CREATE INDEX idx_orders_customer_date ON public.orders USING btree (customer_id, created_at)"
            }
          }
        ]
      }
    },
    {
      "id": "MIG-MODIFY-INDEX-005",
      "given": "table 'accounts' with regular index on username",
      "when": "index modified to UNIQUE",
      "then": "DROP regular index and CREATE UNIQUE INDEX",
      "validation": {
        "setup": {
          "previousSchema": {
            "id": "tbl_accounts",
            "name": "accounts",
            "fields": [
              {
                "id": 1,
                "name": "username",
                "type": "single-line-text"
              },
              {
                "id": 2,
                "name": "email",
                "type": "email"
              }
            ],
            "indexes": [
              {
                "name": "idx_accounts_username",
                "fields": ["username"],
                "unique": false
              }
            ]
          },
          "newSchema": {
            "id": "tbl_accounts",
            "name": "accounts",
            "fields": [
              {
                "id": 1,
                "name": "username",
                "type": "single-line-text"
              },
              {
                "id": 2,
                "name": "email",
                "type": "email"
              }
            ],
            "indexes": [
              {
                "name": "idx_accounts_username",
                "fields": ["username"],
                "unique": true
              }
            ]
          },
          "executeQuery": [
            "CREATE TABLE accounts (id SERIAL PRIMARY KEY, username VARCHAR(255), email VARCHAR(255))",
            "CREATE INDEX idx_accounts_username ON accounts(username)",
            "INSERT INTO accounts (username, email) VALUES ('alice', 'alice@example.com')"
          ]
        },
        "assertions": [
          {
            "description": "DROP and CREATE UNIQUE INDEX",
            "sqlGeneration": {
              "contains": [
                "DROP INDEX idx_accounts_username",
                "CREATE UNIQUE INDEX idx_accounts_username ON \"accounts\"(username)"
              ]
            }
          },
          {
            "description": "Index is now unique",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_accounts_username'",
            "expected": {
              "indexdef": "CREATE UNIQUE INDEX idx_accounts_username ON public.accounts USING btree (username)"
            }
          },
          {
            "description": "Duplicate username now rejected",
            "executeQuery": "INSERT INTO accounts (username, email) VALUES ('alice', 'duplicate@example.com')",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "Unique username succeeds",
            "executeQuery": "INSERT INTO accounts (username, email) VALUES ('bob', 'bob@example.com') RETURNING username",
            "expected": {
              "username": "bob"
            }
          }
        ]
      }
    },
    {
      "id": "MIG-MODIFY-INDEX-006",
      "given": "large table 'events' requiring non-blocking index creation",
      "when": "new index added with concurrent option",
      "then": "CREATE INDEX CONCURRENTLY allows reads/writes during creation",
      "validation": {
        "setup": {
          "previousSchema": {
            "id": "tbl_events",
            "name": "events",
            "fields": [
              {
                "id": 1,
                "name": "user_id",
                "type": "integer"
              },
              {
                "id": 2,
                "name": "event_type",
                "type": "single-line-text"
              },
              {
                "id": 3,
                "name": "created_at",
                "type": "datetime"
              }
            ],
            "indexes": []
          },
          "newSchema": {
            "id": "tbl_events",
            "name": "events",
            "fields": [
              {
                "id": 1,
                "name": "user_id",
                "type": "integer"
              },
              {
                "id": 2,
                "name": "event_type",
                "type": "single-line-text"
              },
              {
                "id": 3,
                "name": "created_at",
                "type": "datetime"
              }
            ],
            "indexes": [
              {
                "name": "idx_events_user",
                "fields": ["user_id"],
                "concurrent": true
              }
            ]
          },
          "executeQuery": [
            "CREATE TABLE events (id SERIAL PRIMARY KEY, user_id INTEGER, event_type VARCHAR(50), created_at TIMESTAMPTZ)",
            "INSERT INTO events (user_id, event_type, created_at) VALUES (1, 'login', NOW()), (2, 'logout', NOW()), (1, 'view', NOW())"
          ]
        },
        "assertions": [
          {
            "description": "CREATE INDEX CONCURRENTLY for non-blocking creation",
            "sqlGeneration": {
              "contains": ["CREATE INDEX CONCURRENTLY idx_events_user ON \"events\"(user_id)"]
            }
          },
          {
            "description": "Index exists after creation",
            "executeQuery": "SELECT indexname FROM pg_indexes WHERE indexname = 'idx_events_user'",
            "expected": {
              "indexname": "idx_events_user"
            }
          },
          {
            "description": "Table accessible during index creation (data intact)",
            "executeQuery": "SELECT COUNT(*) as count FROM events",
            "expected": {
              "count": 3
            }
          },
          {
            "description": "Index functional for queries",
            "executeQuery": "SELECT COUNT(*) as count FROM events WHERE user_id = 1",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    }
  ]
}
