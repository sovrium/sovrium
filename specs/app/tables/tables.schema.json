{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Data Tables",
  "description": "Collection of database tables that define the data structure of your application. Each table represents an entity (e.g., users, products, orders) with fields that define the schema. Tables support relationships, indexes, constraints, and various field types. Tables are the foundation of your application's data model and determine what information can be stored and how it relates.",
  "default": [],
  "type": "array",
  "items": {
    "title": "Data Table",
    "description": "A database table definition with its fields and structure",
    "version": "0.81.0",
    "type": "object",
    "properties": {
      "id": {
        "$ref": "./id/id.schema.json"
      },
      "name": {
        "$ref": "./name/name.schema.json"
      },
      "fields": {
        "$ref": "./fields/fields.schema.json"
      },
      "primaryKey": {
        "$ref": "./primary-key/primary-key.schema.json"
      },
      "uniqueConstraints": {
        "$ref": "./unique-constraints/unique-constraints.schema.json"
      },
      "indexes": {
        "$ref": "./indexes/indexes.schema.json"
      },
      "views": {
        "$ref": "./views/views.schema.json"
      },
      "permissions": {
        "$ref": "./permissions/permissions.schema.json"
      }
    },
    "required": ["id", "name", "fields"],
    "additionalProperties": false
  },
  "x-specs": [
    {
      "id": "APP-TABLES-SCHEMA-CREATE-001",
      "given": "empty PostgreSQL database",
      "when": "table configuration {id: 'tbl_products', name: 'products', fields: [{id: 1, name: 'title', type: 'single-line-text', required: true}]} is applied",
      "then": "PostgreSQL table 'products' is created with columns: id (SERIAL PRIMARY KEY), title (VARCHAR(255) NOT NULL)",
      "validation": {
        "setup": {
          "tableConfig": {
            "id": "tbl_products",
            "name": "products",
            "fields": [
              {
                "id": 1,
                "name": "title",
                "type": "single-line-text",
                "required": true
              }
            ]
          }
        },
        "assertions": [
          {
            "description": "Table exists in PostgreSQL",
            "executeQuery": "SELECT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename = 'products')",
            "expected": {
              "exists": true
            }
          },
          {
            "description": "Table has correct columns with correct types",
            "executeQuery": "SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name = 'products' ORDER BY ordinal_position",
            "expected": [
              {
                "column_name": "id",
                "data_type": "integer",
                "is_nullable": "NO"
              },
              {
                "column_name": "title",
                "data_type": "character varying",
                "is_nullable": "NO"
              }
            ]
          },
          {
            "description": "Primary key constraint exists",
            "executeQuery": "SELECT constraint_name, constraint_type FROM information_schema.table_constraints WHERE table_name = 'products' AND constraint_type = 'PRIMARY KEY'",
            "expected": {
              "constraint_type": "PRIMARY KEY"
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-SCHEMA-FIELDS-001",
      "given": "table configuration with 5 different field types (text, email, integer, decimal, boolean)",
      "when": "table 'customers' is created with these fields",
      "then": "PostgreSQL table has correct column types: VARCHAR(255) for text/email, INTEGER, NUMERIC(10,2), BOOLEAN",
      "validation": {
        "setup": {
          "tableConfig": {
            "id": "tbl_customers",
            "name": "customers",
            "fields": [
              {
                "id": 1,
                "name": "name",
                "type": "single-line-text",
                "required": true
              },
              {
                "id": 2,
                "name": "email",
                "type": "email",
                "required": true,
                "unique": true
              },
              {
                "id": 3,
                "name": "age",
                "type": "integer"
              },
              {
                "id": 4,
                "name": "balance",
                "type": "decimal",
                "precision": 10,
                "scale": 2
              },
              {
                "id": 5,
                "name": "is_active",
                "type": "checkbox"
              }
            ]
          }
        },
        "assertions": [
          {
            "description": "All columns created with correct types",
            "executeQuery": "SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'customers' ORDER BY ordinal_position",
            "expected": [
              {
                "column_name": "id",
                "data_type": "integer"
              },
              {
                "column_name": "name",
                "data_type": "character varying"
              },
              {
                "column_name": "email",
                "data_type": "character varying"
              },
              {
                "column_name": "age",
                "data_type": "integer"
              },
              {
                "column_name": "balance",
                "data_type": "numeric"
              },
              {
                "column_name": "is_active",
                "data_type": "boolean"
              }
            ]
          },
          {
            "description": "Email field has UNIQUE constraint",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='customers' AND constraint_type='UNIQUE'",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-SCHEMA-PK-001",
      "given": "table configuration with explicit primary key field",
      "when": "table 'orders' is created with custom primary key 'order_id'",
      "then": "PostgreSQL table has PRIMARY KEY constraint on 'order_id' column",
      "validation": {
        "setup": {
          "tableConfig": {
            "id": "tbl_orders",
            "name": "orders",
            "fields": [
              {
                "id": 1,
                "name": "order_id",
                "type": "integer",
                "required": true
              }
            ],
            "primaryKey": {
              "fields": ["order_id"]
            }
          }
        },
        "assertions": [
          {
            "description": "Primary key constraint exists on order_id",
            "executeQuery": "SELECT c.column_name, tc.constraint_type FROM information_schema.table_constraints tc JOIN information_schema.constraint_column_usage c ON tc.constraint_name = c.constraint_name WHERE tc.table_name = 'orders' AND tc.constraint_type = 'PRIMARY KEY'",
            "expected": {
              "column_name": "order_id",
              "constraint_type": "PRIMARY KEY"
            }
          },
          {
            "description": "Column is NOT NULL",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name = 'orders' AND column_name = 'order_id'",
            "expected": {
              "is_nullable": "NO"
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-SCHEMA-CONSTRAINTS-001",
      "given": "table configuration with multiple constraints (UNIQUE, NOT NULL, CHECK)",
      "when": "table 'products' is created with constrained fields",
      "then": "PostgreSQL enforces all constraints: UNIQUE on sku, NOT NULL on required fields, CHECK on price > 0",
      "validation": {
        "setup": {
          "tableConfig": {
            "id": "tbl_products",
            "name": "products",
            "fields": [
              {
                "id": 1,
                "name": "sku",
                "type": "single-line-text",
                "required": true,
                "unique": true
              },
              {
                "id": 2,
                "name": "title",
                "type": "single-line-text",
                "required": true
              },
              {
                "id": 3,
                "name": "price",
                "type": "decimal",
                "required": true,
                "min": 0.01
              }
            ]
          }
        },
        "assertions": [
          {
            "description": "UNIQUE constraint exists on sku",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='products' AND constraint_type='UNIQUE' AND constraint_name LIKE '%sku%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "NOT NULL enforced on required fields",
            "executeQuery": "SELECT column_name, is_nullable FROM information_schema.columns WHERE table_name='products' AND column_name IN ('sku', 'title', 'price') ORDER BY column_name",
            "expected": [
              {
                "column_name": "price",
                "is_nullable": "NO"
              },
              {
                "column_name": "sku",
                "is_nullable": "NO"
              },
              {
                "column_name": "title",
                "is_nullable": "NO"
              }
            ]
          },
          {
            "description": "CHECK constraint enforces price > 0",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%price%'",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-SCHEMA-INTROSPECT-001",
      "given": "existing table 'customers' in PostgreSQL with 3 columns",
      "when": "schema introspection queries are executed",
      "then": "queries return complete table metadata: columns, types, constraints, indexes",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, email VARCHAR(255) UNIQUE NOT NULL, name VARCHAR(255) NOT NULL)",
            "CREATE INDEX idx_customers_email ON customers(email)"
          ]
        },
        "assertions": [
          {
            "description": "pg_tables shows table existence",
            "executeQuery": "SELECT tablename, schemaname FROM pg_tables WHERE tablename = 'customers'",
            "expected": {
              "tablename": "customers",
              "schemaname": "public"
            }
          },
          {
            "description": "information_schema.columns shows all columns",
            "executeQuery": "SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name = 'customers' ORDER BY ordinal_position",
            "expected": [
              {
                "column_name": "id",
                "data_type": "integer",
                "is_nullable": "NO"
              },
              {
                "column_name": "email",
                "data_type": "character varying",
                "is_nullable": "NO"
              },
              {
                "column_name": "name",
                "data_type": "character varying",
                "is_nullable": "NO"
              }
            ]
          },
          {
            "description": "pg_indexes shows index details",
            "executeQuery": "SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'customers' AND indexname = 'idx_customers_email'",
            "expected": {
              "indexname": "idx_customers_email"
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-FIELD-TEXT-001",
      "given": "table configuration with single-line-text field",
      "when": "field migration creates column",
      "then": "PostgreSQL VARCHAR(255) column is created",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE items (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "title",
            "type": "single-line-text"
          }
        },
        "assertions": [
          {
            "description": "Column created as VARCHAR(255)",
            "executeQuery": "SELECT column_name, data_type, character_maximum_length FROM information_schema.columns WHERE table_name='items' AND column_name='title'",
            "expected": {
              "column_name": "title",
              "data_type": "character varying",
              "character_maximum_length": 255
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-FIELD-EMAIL-001",
      "given": "table configuration with email field (required, unique)",
      "when": "field migration creates column",
      "then": "PostgreSQL VARCHAR(255) column with UNIQUE and NOT NULL constraints",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE users (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "email",
            "type": "email",
            "required": true,
            "unique": true
          }
        },
        "assertions": [
          {
            "description": "Email column created with correct type",
            "executeQuery": "SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name='users' AND column_name='email'",
            "expected": {
              "column_name": "email",
              "data_type": "character varying",
              "is_nullable": "NO"
            }
          },
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='users' AND constraint_type='UNIQUE'",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-FIELD-INTEGER-001",
      "given": "table configuration with integer field with min/max constraints",
      "when": "field migration creates column",
      "then": "PostgreSQL INTEGER column with CHECK constraint for range",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE products (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "quantity",
            "type": "integer",
            "min": 0,
            "max": 10000
          }
        },
        "assertions": [
          {
            "description": "Column created as INTEGER",
            "executeQuery": "SELECT column_name, data_type FROM information_schema.columns WHERE table_name='products' AND column_name='quantity'",
            "expected": {
              "column_name": "quantity",
              "data_type": "integer"
            }
          },
          {
            "description": "CHECK constraint exists for range validation",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%quantity%'",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-FIELD-DECIMAL-001",
      "given": "table configuration with decimal field (precision 10, scale 2)",
      "when": "field migration creates column",
      "then": "PostgreSQL NUMERIC(10,2) column is created",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE transactions (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "amount",
            "type": "decimal",
            "precision": 10,
            "scale": 2
          }
        },
        "assertions": [
          {
            "description": "Column created as NUMERIC with correct precision",
            "executeQuery": "SELECT column_name, data_type, numeric_precision, numeric_scale FROM information_schema.columns WHERE table_name='transactions' AND column_name='amount'",
            "expected": {
              "column_name": "amount",
              "data_type": "numeric",
              "numeric_precision": 10,
              "numeric_scale": 2
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-FIELD-BOOLEAN-001",
      "given": "table configuration with checkbox field",
      "when": "field migration creates column",
      "then": "PostgreSQL BOOLEAN column is created with DEFAULT false",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE settings (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "is_active",
            "type": "checkbox",
            "default": false
          }
        },
        "assertions": [
          {
            "description": "Column created as BOOLEAN",
            "executeQuery": "SELECT column_name, data_type, column_default FROM information_schema.columns WHERE table_name='settings' AND column_name='is_active'",
            "expected": {
              "column_name": "is_active",
              "data_type": "boolean",
              "column_default": "false"
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-CONSTRAINT-UNIQUE-001",
      "given": "table 'users' with UNIQUE constraint on email column, existing row email='john@example.com'",
      "when": "attempt to insert duplicate email='john@example.com'",
      "then": "PostgreSQL rejects insertion with unique constraint violation error",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, email VARCHAR(255) UNIQUE NOT NULL)",
            "INSERT INTO users (email) VALUES ('john@example.com')"
          ]
        },
        "assertions": [
          {
            "description": "First insertion succeeds",
            "executeQuery": "SELECT COUNT(*) as count FROM users WHERE email = 'john@example.com'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Duplicate insertion fails with unique constraint violation",
            "executeQuery": "INSERT INTO users (email) VALUES ('john@example.com')",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "Database still contains only 1 row",
            "executeQuery": "SELECT COUNT(*) as count FROM users",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-CONSTRAINT-NOT-NULL-001",
      "given": "table 'products' with NOT NULL constraint on required field 'title'",
      "when": "attempt to insert NULL value for title",
      "then": "PostgreSQL rejects insertion with NOT NULL constraint violation",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE products (id SERIAL PRIMARY KEY, title VARCHAR(255) NOT NULL, price NUMERIC)"
        },
        "assertions": [
          {
            "description": "Valid insertion with title succeeds",
            "executeQuery": "INSERT INTO products (title, price) VALUES ('MacBook Pro', 2499.99) RETURNING id, title",
            "expected": {
              "title": "MacBook Pro"
            }
          },
          {
            "description": "Insertion with NULL title fails",
            "executeQuery": "INSERT INTO products (title, price) VALUES (NULL, 999.99)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-CONSTRAINT-CHECK-001",
      "given": "table 'inventory' with CHECK constraint (quantity >= 0 AND quantity <= 10000)",
      "when": "attempt to insert values outside allowed range",
      "then": "PostgreSQL enforces CHECK constraint, rejects invalid values",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE inventory (id SERIAL PRIMARY KEY, item_name VARCHAR(255), quantity INTEGER CHECK (quantity >= 0 AND quantity <= 10000))"
        },
        "assertions": [
          {
            "description": "Valid quantity within range succeeds",
            "executeQuery": "INSERT INTO inventory (item_name, quantity) VALUES ('Widget', 5000) RETURNING quantity",
            "expected": {
              "quantity": 5000
            }
          },
          {
            "description": "Negative quantity rejected",
            "executeQuery": "INSERT INTO inventory (item_name, quantity) VALUES ('Invalid', -1)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Quantity above max rejected",
            "executeQuery": "INSERT INTO inventory (item_name, quantity) VALUES ('Invalid', 10001)",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-INDEX-CREATE-001",
      "given": "table 'users' with email field needing fast lookups",
      "when": "index is created on email column",
      "then": "PostgreSQL index exists and can be queried via pg_indexes",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, email VARCHAR(255) UNIQUE NOT NULL)",
            "CREATE INDEX idx_users_email ON users(email)"
          ]
        },
        "assertions": [
          {
            "description": "Index appears in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_users_email'",
            "expected": {
              "indexname": "idx_users_email",
              "tablename": "users"
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-MIGRATION-ALTER-001",
      "given": "existing table 'customers' with 2 columns",
      "when": "migration adds new column 'phone' as VARCHAR(20)",
      "then": "PostgreSQL table is altered, new column exists with correct type",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL)",
            "ALTER TABLE customers ADD COLUMN phone VARCHAR(20)"
          ]
        },
        "assertions": [
          {
            "description": "New column exists",
            "executeQuery": "SELECT column_name, data_type, character_maximum_length FROM information_schema.columns WHERE table_name = 'customers' AND column_name = 'phone'",
            "expected": {
              "column_name": "phone",
              "data_type": "character varying",
              "character_maximum_length": 20
            }
          },
          {
            "description": "Table has 3 columns total",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.columns WHERE table_name = 'customers'",
            "expected": {
              "count": 3
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-MIGRATION-DROP-001",
      "given": "existing table 'temp_data' with columns id, data, status",
      "when": "migration drops column 'status'",
      "then": "PostgreSQL column is removed, table has 2 remaining columns",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE temp_data (id SERIAL PRIMARY KEY, data TEXT, status VARCHAR(50))",
            "ALTER TABLE temp_data DROP COLUMN status"
          ]
        },
        "assertions": [
          {
            "description": "Status column no longer exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.columns WHERE table_name = 'temp_data' AND column_name = 'status'",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Table has 2 remaining columns",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.columns WHERE table_name = 'temp_data'",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-DATA-INSERT-001",
      "given": "table 'customers' with email and name fields",
      "when": "valid data is inserted",
      "then": "PostgreSQL returns inserted row with generated ID",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE customers (id SERIAL PRIMARY KEY, email VARCHAR(255) UNIQUE NOT NULL, name VARCHAR(255) NOT NULL)"
        },
        "assertions": [
          {
            "description": "INSERT with RETURNING clause succeeds",
            "executeQuery": "INSERT INTO customers (email, name) VALUES ('john@example.com', 'John Doe') RETURNING id, email, name",
            "expected": {
              "email": "john@example.com",
              "name": "John Doe"
            }
          },
          {
            "description": "Row count is 1",
            "executeQuery": "SELECT COUNT(*) as count FROM customers",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-DATA-UPDATE-001",
      "given": "table 'customers' with existing row (id=1, name='John Doe')",
      "when": "UPDATE statement changes name to 'John Smith'",
      "then": "PostgreSQL updates row, SELECT returns new value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, email VARCHAR(255), name VARCHAR(255))",
            "INSERT INTO customers (email, name) VALUES ('john@example.com', 'John Doe')"
          ]
        },
        "assertions": [
          {
            "description": "UPDATE statement succeeds",
            "executeQuery": "UPDATE customers SET name = 'John Smith' WHERE email = 'john@example.com' RETURNING name",
            "expected": {
              "name": "John Smith"
            }
          },
          {
            "description": "SELECT confirms update",
            "executeQuery": "SELECT name FROM customers WHERE email = 'john@example.com'",
            "expected": {
              "name": "John Smith"
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-DATA-DELETE-001",
      "given": "table 'customers' with 3 rows",
      "when": "DELETE statement removes 1 row",
      "then": "PostgreSQL removes row, row count decreases to 2",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, email VARCHAR(255))",
            "INSERT INTO customers (email) VALUES ('john@example.com'), ('jane@example.com'), ('bob@example.com')"
          ]
        },
        "assertions": [
          {
            "description": "Initial row count is 3",
            "executeQuery": "SELECT COUNT(*) as count FROM customers",
            "expected": {
              "count": 3
            }
          },
          {
            "description": "DELETE removes 1 row",
            "executeQuery": "DELETE FROM customers WHERE email = 'john@example.com' RETURNING email",
            "expected": {
              "email": "john@example.com"
            }
          },
          {
            "description": "Row count is now 2",
            "executeQuery": "SELECT COUNT(*) as count FROM customers",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-FIELD-TIMESTAMP-001",
      "given": "table configuration with created_at field (auto-timestamp)",
      "when": "field migration creates column",
      "then": "PostgreSQL TIMESTAMP column with DEFAULT NOW()",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE orders (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "created_at",
            "type": "created-at"
          }
        },
        "assertions": [
          {
            "description": "Column created as TIMESTAMP",
            "executeQuery": "SELECT column_name, data_type FROM information_schema.columns WHERE table_name='orders' AND column_name='created_at'",
            "expected": {
              "column_name": "created_at",
              "data_type": "timestamp without time zone"
            }
          },
          {
            "description": "Column has DEFAULT NOW()",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='orders' AND column_name='created_at'",
            "expected": {
              "column_default": "CURRENT_TIMESTAMP"
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-FIELD-SELECT-001",
      "given": "table configuration with single-select field with options ['active', 'inactive']",
      "when": "field migration creates column",
      "then": "PostgreSQL VARCHAR column with CHECK constraint for enum values",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE items (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "status",
            "type": "single-select",
            "options": ["active", "inactive"]
          }
        },
        "assertions": [
          {
            "description": "Column created as VARCHAR",
            "executeQuery": "SELECT column_name, data_type FROM information_schema.columns WHERE table_name='items' AND column_name='status'",
            "expected": {
              "column_name": "status",
              "data_type": "character varying"
            }
          },
          {
            "description": "CHECK constraint exists for enum values",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%status%'",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-DROP-001",
      "given": "existing table 'obsolete_data' in database",
      "when": "DROP TABLE statement is executed",
      "then": "PostgreSQL removes table completely, pg_tables no longer shows it",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE obsolete_data (id SERIAL PRIMARY KEY, data TEXT)"
        },
        "assertions": [
          {
            "description": "Table exists before drop",
            "executeQuery": "SELECT EXISTS (SELECT FROM pg_tables WHERE tablename = 'obsolete_data')",
            "expected": {
              "exists": true
            }
          },
          {
            "description": "DROP TABLE succeeds",
            "executeQuery": "DROP TABLE obsolete_data",
            "expectError": "validation error"
          },
          {
            "description": "Table no longer exists",
            "executeQuery": "SELECT EXISTS (SELECT FROM pg_tables WHERE tablename = 'obsolete_data')",
            "expected": {
              "exists": false
            }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-COMPOSITE-PK-001",
      "given": "table configuration with composite primary key on (tenant_id, user_id)",
      "when": "table 'user_tenants' is created",
      "then": "PostgreSQL PRIMARY KEY constraint spans both columns",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE user_tenants (tenant_id INTEGER NOT NULL, user_id INTEGER NOT NULL, PRIMARY KEY (tenant_id, user_id))",
          "tableConfig": {
            "id": "tbl_user_tenants",
            "name": "user_tenants",
            "fields": [
              {
                "id": 1,
                "name": "tenant_id",
                "type": "integer",
                "required": true
              },
              {
                "id": 2,
                "name": "user_id",
                "type": "integer",
                "required": true
              }
            ],
            "primaryKey": {
              "fields": ["tenant_id", "user_id"]
            }
          }
        },
        "assertions": [
          {
            "description": "Composite primary key exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='user_tenants' AND constraint_type='PRIMARY KEY'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Primary key includes both columns",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.key_column_usage WHERE table_name='user_tenants' AND constraint_name LIKE '%_pkey'",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    }
  ]
}
