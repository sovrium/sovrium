{
  "$id": "permissions.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Table Permissions",
  "description": "Access control rules for tables integrated with Better Auth. Defines who can perform operations at table, field, and record levels. Permissions are evaluated hierarchically: Table → Field → Record. If no permission is specified, access is denied by default.",
  "type": "object",
  "properties": {
    "table": {
      "$ref": "./table-permissions/table-permissions.schema.json",
      "description": "Table-level permissions (read, create, update, delete). Evaluated first - if denied here, request is rejected."
    },
    "fields": {
      "$ref": "./field-permissions/field-permissions.schema.json",
      "description": "Field-level permissions (per-field read/write access). Filters which fields are visible/editable."
    },
    "records": {
      "$ref": "./record-permissions/record-permissions.schema.json",
      "description": "Record-level permissions (row-level security). Filters which records are accessible based on user and record properties."
    }
  },
  "required": [],
  "additionalProperties": false,
  "examples": [
    {
      "table": {
        "read": { "type": "authenticated" },
        "create": { "type": "authenticated" },
        "update": { "type": "authenticated" },
        "delete": { "type": "roles", "roles": ["admin"] }
      },
      "fields": [
        {
          "field": "email",
          "read": { "type": "authenticated" },
          "write": { "type": "custom", "condition": "{userId} = id" }
        }
      ],
      "records": [
        {
          "action": "read",
          "condition": "{userId} = created_by"
        }
      ]
    },
    {
      "table": {
        "read": { "type": "public" },
        "create": { "type": "roles", "roles": ["admin", "editor"] }
      }
    }
  ],
  "x-specs": [
    {
      "id": "APP-TABLES-PERMISSIONS-001",
      "given": "user without table-level read permission",
      "when": "user attempts to list records",
      "then": "PostgreSQL RLS denies access before field/record checks",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE admin_data (id SERIAL PRIMARY KEY, secret TEXT, owner_id INTEGER)",
            "ALTER TABLE admin_data ENABLE ROW LEVEL SECURITY",
            "CREATE POLICY admin_only ON admin_data FOR SELECT USING (auth.user_has_role('admin'))",
            "INSERT INTO admin_data (secret, owner_id) VALUES ('Secret 1', 1)"
          ],
          "permissionConfig": {
            "table": {
              "read": { "type": "roles", "roles": ["admin"] }
            }
          }
        },
        "assertions": [
          {
            "description": "Table-level RLS policy exists",
            "executeQuery": "SELECT COUNT(*) as count FROM pg_policies WHERE tablename='admin_data'",
            "expected": { "count": 1 }
          },
          {
            "description": "Admin user can SELECT records",
            "executeQuery": "SET ROLE admin_user; SELECT COUNT(*) as count FROM admin_data",
            "expected": { "count": 1 }
          },
          {
            "description": "Member user cannot SELECT records (table-level denied)",
            "executeQuery": "SET ROLE member_user; SELECT COUNT(*) as count FROM admin_data",
            "expected": { "count": 0 }
          },
          {
            "description": "Field/record permissions not evaluated when table-level denies",
            "executeQuery": "SELECT COUNT(*) as field_policies FROM pg_policies WHERE tablename='admin_data' AND policyname LIKE '%field%'",
            "expected": { "field_policies": 0 }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-PERMISSIONS-002",
      "given": "user with table read permission but restricted field access",
      "when": "user queries records",
      "then": "PostgreSQL allows table access but filters sensitive fields",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255), salary DECIMAL(10,2))",
            "INSERT INTO users (name, email, salary) VALUES ('Alice', 'alice@example.com', 75000.00)"
          ],
          "permissionConfig": {
            "table": {
              "read": { "type": "authenticated" }
            },
            "fields": [
              {
                "field": "salary",
                "read": { "type": "roles", "roles": ["admin"] }
              }
            ]
          }
        },
        "assertions": [
          {
            "description": "Authenticated user can access table",
            "executeQuery": "SET ROLE authenticated_user; SELECT COUNT(*) as count FROM users",
            "expected": { "count": 1 }
          },
          {
            "description": "Authenticated user can SELECT allowed fields",
            "executeQuery": "SET ROLE authenticated_user; SELECT name, email FROM users WHERE id = 1",
            "expected": { "name": "Alice", "email": "alice@example.com" }
          },
          {
            "description": "Authenticated user cannot SELECT salary field",
            "executeQuery": "SET ROLE authenticated_user; SELECT salary FROM users WHERE id = 1",
            "expectError": "permission denied for column salary"
          },
          {
            "description": "Admin user can SELECT all fields including salary",
            "executeQuery": "SET ROLE admin_user; SELECT name, email, salary FROM users WHERE id = 1",
            "expected": { "name": "Alice", "email": "alice@example.com", "salary": 75000.00 }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-PERMISSIONS-003",
      "given": "permissions configured at all three levels (table + field + record)",
      "when": "user accesses table",
      "then": "PostgreSQL applies hierarchical checks: table → field → record filtering",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), notes TEXT, owner_id INTEGER, status VARCHAR(50))",
            "ALTER TABLE tasks ENABLE ROW LEVEL SECURITY",
            "CREATE POLICY authenticated_read ON tasks FOR SELECT USING (auth.is_authenticated())",
            "CREATE POLICY owner_records ON tasks FOR SELECT USING (owner_id = current_setting('app.user_id')::INTEGER)",
            "INSERT INTO tasks (title, notes, owner_id, status) VALUES ('Task 1', 'Private notes 1', 1, 'open'), ('Task 2', 'Private notes 2', 2, 'open')"
          ],
          "permissionConfig": {
            "table": {
              "read": { "type": "authenticated" }
            },
            "fields": [
              {
                "field": "notes",
                "read": { "type": "custom", "condition": "{userId} = owner_id" }
              }
            ],
            "records": [
              {
                "action": "read",
                "condition": "{userId} = owner_id"
              }
            ]
          }
        },
        "assertions": [
          {
            "description": "Unauthenticated user denied at table level",
            "executeQuery": "RESET ROLE; SELECT COUNT(*) as count FROM tasks",
            "expectError": "permission denied for table tasks"
          },
          {
            "description": "Authenticated user passes table level, filtered by record level",
            "executeQuery": "SET LOCAL app.user_id = 1; SELECT COUNT(*) as count FROM tasks",
            "expected": { "count": 1 }
          },
          {
            "description": "User 1 sees only their task (record-level filter)",
            "executeQuery": "SET LOCAL app.user_id = 1; SELECT title FROM tasks",
            "expected": { "title": "Task 1" }
          },
          {
            "description": "User 1 can read notes on their own task (field-level allows)",
            "executeQuery": "SET LOCAL app.user_id = 1; SELECT title, notes FROM tasks WHERE id = 1",
            "expected": { "title": "Task 1", "notes": "Private notes 1" }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-PERMISSIONS-004",
      "given": "table with no permissions configured (default deny)",
      "when": "any user attempts to access table",
      "then": "PostgreSQL RLS blocks all access by default",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE confidential (id SERIAL PRIMARY KEY, data TEXT)",
            "ALTER TABLE confidential ENABLE ROW LEVEL SECURITY",
            "INSERT INTO confidential (data) VALUES ('Confidential 1')"
          ],
          "permissionConfig": {}
        },
        "assertions": [
          {
            "description": "RLS is enabled",
            "executeQuery": "SELECT relrowsecurity FROM pg_class WHERE relname='confidential'",
            "expected": { "relrowsecurity": true }
          },
          {
            "description": "No policies exist (default deny)",
            "executeQuery": "SELECT COUNT(*) as count FROM pg_policies WHERE tablename='confidential'",
            "expected": { "count": 0 }
          },
          {
            "description": "Admin user gets empty result (RLS blocks)",
            "executeQuery": "SET ROLE admin_user; SELECT COUNT(*) as count FROM confidential",
            "expected": { "count": 0 }
          },
          {
            "description": "Any user gets empty result (default deny)",
            "executeQuery": "SET ROLE authenticated_user; SELECT COUNT(*) as count FROM confidential",
            "expected": { "count": 0 }
          }
        ]
      }
    },
    {
      "id": "APP-TABLES-PERMISSIONS-005",
      "given": "complete permission hierarchy with table=public, field=restricted, record=owner-only",
      "when": "different users access table",
      "then": "PostgreSQL enforces all layers: public access, field filtering, record filtering",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE posts (id SERIAL PRIMARY KEY, title VARCHAR(255), body TEXT, draft BOOLEAN, author_id INTEGER)",
            "ALTER TABLE posts ENABLE ROW LEVEL SECURITY",
            "CREATE POLICY published_or_owner ON posts FOR SELECT USING (draft = false OR author_id = current_setting('app.user_id')::INTEGER)",
            "INSERT INTO posts (title, body, draft, author_id) VALUES ('Published Post', 'Public content', false, 1), ('Draft Post', 'Private draft', true, 1), ('Other Draft', 'Other private', true, 2)"
          ],
          "permissionConfig": {
            "table": {
              "read": { "type": "public" }
            },
            "fields": [
              {
                "field": "body",
                "read": { "type": "authenticated" }
              }
            ],
            "records": [
              {
                "action": "read",
                "condition": "draft = false OR {userId} = author_id"
              }
            ]
          }
        },
        "assertions": [
          {
            "description": "Unauthenticated user sees published posts only (record filter)",
            "executeQuery": "RESET ROLE; SELECT COUNT(*) as count FROM posts",
            "expected": { "count": 1 }
          },
          {
            "description": "Unauthenticated user can see title but not body (field filter)",
            "executeQuery": "RESET ROLE; SELECT title FROM posts",
            "expected": { "title": "Published Post" }
          },
          {
            "description": "Author sees published + their own drafts (2 records)",
            "executeQuery": "SET LOCAL app.user_id = 1; SELECT COUNT(*) as count FROM posts",
            "expected": { "count": 2 }
          },
          {
            "description": "Author can read body field on their posts",
            "executeQuery": "SET LOCAL app.user_id = 1; SELECT title, body FROM posts WHERE id = 2",
            "expected": { "title": "Draft Post", "body": "Private draft" }
          }
        ]
      }
    }
  ]
}
