{
  "$id": "relationship-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Relationship Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "type": "string",
      "const": "relationship"
    },
    "relatedTable": {
      "$ref": "./relatedTable/relatedTable.schema.json"
    },
    "relationType": {
      "$ref": "./relationType/relationType.schema.json"
    },
    "displayField": {
      "$ref": "./displayField/displayField.schema.json"
    },
    "onDelete": {
      "$ref": "./onDelete/onDelete.schema.json"
    },
    "onUpdate": {
      "$ref": "./onUpdate/onUpdate.schema.json"
    }
  },
  "description": "Foreign key relationship to another table creating associations between entities. Supports three relationship types: one-to-one (single unique reference), one-to-many (single reference to many records), many-to-many (junction table for bidirectional references). Configure onDelete behavior (cascade deletes related, set-null clears reference, restrict prevents deletion, no-action does nothing). Configure onUpdate behavior for key changes. Specify displayField to show human-readable value from related table. Automatically indexed for query performance.",
  "required": [
    "id",
    "name",
    "type",
    "relatedTable",
    "relationType"
  ],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-RELATIONSHIP-FIELD-001",
      "given": "table configuration with relationship field 'author_id' to 'users' table (one-to-many)",
      "when": "field migration creates foreign key column",
      "then": "PostgreSQL INTEGER column with FOREIGN KEY constraint is created",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE posts (id SERIAL PRIMARY KEY)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "author_id",
            "type": "relationship",
            "relatedTable": "users",
            "relationType": "one-to-many"
          }
        },
        "assertions": [
          {
            "description": "Column created as INTEGER",
            "executeQuery": "SELECT column_name, data_type FROM information_schema.columns WHERE table_name='posts' AND column_name='author_id'",
            "expected": {
              "column_name": "author_id",
              "data_type": "integer"
            }
          },
          {
            "description": "FOREIGN KEY constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='posts' AND constraint_type='FOREIGN KEY' AND constraint_name LIKE '%author_id%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Foreign key references users table",
            "executeQuery": "SELECT ccu.table_name as referenced_table FROM information_schema.table_constraints tc JOIN information_schema.constraint_column_usage ccu ON tc.constraint_name = ccu.constraint_name WHERE tc.table_name='posts' AND tc.constraint_type='FOREIGN KEY'",
            "expected": {
              "referenced_table": "users"
            }
          }
        ]
      }
    },
    {
      "id": "APP-RELATIONSHIP-FIELD-002",
      "given": "table 'orders' with relationship field 'customer_id' referencing 'customers'",
      "when": "inserting record with invalid foreign key",
      "then": "PostgreSQL FOREIGN KEY constraint rejects non-existent reference",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "INSERT INTO customers (name) VALUES ('John Doe')",
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, customer_id INTEGER REFERENCES customers(id))"
          ]
        },
        "assertions": [
          {
            "description": "Valid foreign key succeeds",
            "executeQuery": "INSERT INTO orders (customer_id) VALUES (1) RETURNING customer_id",
            "expected": {
              "customer_id": 1
            }
          },
          {
            "description": "Invalid foreign key rejected by constraint",
            "executeQuery": "INSERT INTO orders (customer_id) VALUES (999)",
            "expectError": "violates foreign key constraint"
          },
          {
            "description": "NULL foreign key allowed (optional relationship)",
            "executeQuery": "INSERT INTO orders (customer_id) VALUES (NULL) RETURNING customer_id IS NULL as is_null",
            "expected": {
              "is_null": true
            }
          }
        ]
      }
    },
    {
      "id": "APP-RELATIONSHIP-FIELD-003",
      "given": "table 'comments' with relationship field 'post_id' and onDelete=CASCADE",
      "when": "parent record is deleted",
      "then": "PostgreSQL CASCADE deletes child records automatically",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE posts (id SERIAL PRIMARY KEY, title VARCHAR(255))",
            "INSERT INTO posts (title) VALUES ('First Post'), ('Second Post')",
            "CREATE TABLE comments (id SERIAL PRIMARY KEY, post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE)",
            "INSERT INTO comments (post_id) VALUES (1), (1), (2)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "post_id",
            "type": "relationship",
            "onDelete": "cascade"
          }
        },
        "assertions": [
          {
            "description": "Comments exist for post 1",
            "executeQuery": "SELECT COUNT(*) as count FROM comments WHERE post_id = 1",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Deleting post cascades to comments",
            "executeQuery": "DELETE FROM posts WHERE id = 1",
            "expected": {}
          },
          {
            "description": "Cascaded comments are deleted",
            "executeQuery": "SELECT COUNT(*) as count FROM comments WHERE post_id = 1",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Other comments remain intact",
            "executeQuery": "SELECT COUNT(*) as count FROM comments WHERE post_id = 2",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-RELATIONSHIP-FIELD-004",
      "given": "table 'tasks' with relationship field 'assigned_to' and onDelete=SET NULL",
      "when": "referenced user is deleted",
      "then": "PostgreSQL SET NULL clears foreign key reference",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "INSERT INTO users (name) VALUES ('Alice'), ('Bob')",
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), assigned_to INTEGER REFERENCES users(id) ON DELETE SET NULL)",
            "INSERT INTO tasks (title, assigned_to) VALUES ('Task 1', 1), ('Task 2', 2), ('Task 3', 1)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "assigned_to",
            "type": "relationship",
            "onDelete": "set-null"
          }
        },
        "assertions": [
          {
            "description": "Tasks assigned to user 1",
            "executeQuery": "SELECT COUNT(*) as count FROM tasks WHERE assigned_to = 1",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Deleting user sets foreign key to NULL",
            "executeQuery": "DELETE FROM users WHERE id = 1",
            "expected": {}
          },
          {
            "description": "Previously assigned tasks now NULL",
            "executeQuery": "SELECT COUNT(*) as count FROM tasks WHERE assigned_to IS NULL",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Other assignments remain intact",
            "executeQuery": "SELECT COUNT(*) as count FROM tasks WHERE assigned_to = 2",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-RELATIONSHIP-FIELD-005",
      "given": "table configuration with relationship field 'category_id', indexed=true",
      "when": "index is created on the foreign key field",
      "then": "PostgreSQL btree index exists for fast join performance",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE categories (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE products (id SERIAL PRIMARY KEY, category_id INTEGER REFERENCES categories(id))",
            "CREATE INDEX idx_products_category ON products(category_id)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "category_id",
            "type": "relationship",
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_products_category'",
            "expected": {
              "indexname": "idx_products_category",
              "tablename": "products"
            }
          },
          {
            "description": "Index uses btree for foreign key lookups",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_products_category'",
            "expected": {
              "indexdef": "CREATE INDEX idx_products_category ON public.products USING btree (category_id)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-RELATIONSHIP-FIELD-006",
      "given": "self-referential relationship for hierarchical data (employees with manager_id)",
      "when": "creating foreign key to same table",
      "then": "PostgreSQL allows self-referencing foreign key for tree structures",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE employees (id SERIAL PRIMARY KEY, name VARCHAR(255), manager_id INTEGER REFERENCES employees(id) ON DELETE SET NULL)",
            "INSERT INTO employees (id, name, manager_id) VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'Sales Rep', 2), (4, 'VP Engineering', 1), (5, 'Engineer', 4)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "manager_id",
            "type": "relationship",
            "relatedTable": "employees",
            "relationType": "one-to-many",
            "onDelete": "set-null"
          }
        },
        "assertions": [
          {
            "description": "Self-referential foreign key constraint exists",
            "executeQuery": "SELECT conname, conrelid::regclass, confrelid::regclass FROM pg_constraint WHERE conrelid = 'employees'::regclass AND confrelid = 'employees'::regclass AND contype = 'f'",
            "expected": {
              "conname": "employees_manager_id_fkey",
              "conrelid": "employees",
              "confrelid": "employees"
            }
          },
          {
            "description": "Can query hierarchical structure (get direct reports)",
            "executeQuery": "SELECT COUNT(*) as direct_reports FROM employees WHERE manager_id = 1",
            "expected": {
              "direct_reports": 2
            }
          },
          {
            "description": "Can insert employee with manager in same table",
            "executeQuery": "INSERT INTO employees (name, manager_id) VALUES ('New Hire', 2) RETURNING id, manager_id",
            "expected": {
              "id": 6,
              "manager_id": 2
            }
          },
          {
            "description": "Cannot reference non-existent manager",
            "executeQuery": "INSERT INTO employees (name, manager_id) VALUES ('Invalid', 999)",
            "expectError": "violates foreign key constraint"
          }
        ]
      }
    },
    {
      "id": "APP-RELATIONSHIP-FIELD-007",
      "given": "self-referential relationship for categories with parent_id (nested categories)",
      "when": "querying category tree depth",
      "then": "PostgreSQL recursive CTE traverses parent-child relationships",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE categories (id SERIAL PRIMARY KEY, name VARCHAR(255), parent_id INTEGER REFERENCES categories(id) ON DELETE CASCADE)",
            "INSERT INTO categories (id, name, parent_id) VALUES (1, 'Electronics', NULL), (2, 'Computers', 1), (3, 'Laptops', 2), (4, 'Gaming Laptops', 3), (5, 'Home & Garden', NULL), (6, 'Furniture', 5)"
          ]
        },
        "assertions": [
          {
            "description": "Recursive query finds all descendants of Electronics",
            "executeQuery": "WITH RECURSIVE subcategories AS (SELECT id, name, parent_id, 0 as depth FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id, s.depth + 1 FROM categories c INNER JOIN subcategories s ON c.parent_id = s.id) SELECT COUNT(*) as total_descendants FROM subcategories WHERE id != 1",
            "expected": {
              "total_descendants": 3
            }
          },
          {
            "description": "Query finds maximum depth of category tree",
            "executeQuery": "WITH RECURSIVE subcategories AS (SELECT id, name, parent_id, 0 as depth FROM categories WHERE parent_id IS NULL UNION ALL SELECT c.id, c.name, c.parent_id, s.depth + 1 FROM categories c INNER JOIN subcategories s ON c.parent_id = s.id) SELECT MAX(depth) as max_depth FROM subcategories",
            "expected": {
              "max_depth": 3
            }
          },
          {
            "description": "Deleting parent cascades to all descendants",
            "executeQuery": "DELETE FROM categories WHERE id = 1",
            "expected": {}
          },
          {
            "description": "All descendants deleted via CASCADE",
            "executeQuery": "SELECT COUNT(*) as remaining FROM categories",
            "expected": {
              "remaining": 2
            }
          }
        ]
      }
    },
    {
      "id": "APP-RELATIONSHIP-FIELD-008",
      "given": "bi-directional many-to-many relationship (students â†” courses via enrollments junction table)",
      "when": "creating junction table with dual foreign keys",
      "then": "PostgreSQL junction table links both directions with composite primary key",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE students (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE courses (id SERIAL PRIMARY KEY, title VARCHAR(255))",
            "CREATE TABLE enrollments (student_id INTEGER REFERENCES students(id) ON DELETE CASCADE, course_id INTEGER REFERENCES courses(id) ON DELETE CASCADE, enrolled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (student_id, course_id))",
            "INSERT INTO students (id, name) VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie')",
            "INSERT INTO courses (id, title) VALUES (1, 'Math 101'), (2, 'Physics 201'), (3, 'Chemistry 301')",
            "INSERT INTO enrollments (student_id, course_id) VALUES (1, 1), (1, 2), (2, 1), (2, 3), (3, 2)"
          ]
        },
        "assertions": [
          {
            "description": "Junction table has composite primary key",
            "executeQuery": "SELECT COUNT(*) as pk_columns FROM information_schema.key_column_usage WHERE table_name = 'enrollments' AND constraint_name = 'enrollments_pkey'",
            "expected": {
              "pk_columns": 2
            }
          },
          {
            "description": "Query students enrolled in Math 101",
            "executeQuery": "SELECT COUNT(*) as student_count FROM enrollments WHERE course_id = 1",
            "expected": {
              "student_count": 2
            }
          },
          {
            "description": "Query courses taken by Alice",
            "executeQuery": "SELECT COUNT(*) as course_count FROM enrollments WHERE student_id = 1",
            "expected": {
              "course_count": 2
            }
          },
          {
            "description": "Composite primary key prevents duplicate enrollments",
            "executeQuery": "INSERT INTO enrollments (student_id, course_id) VALUES (1, 1)",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "Deleting student cascades to enrollments",
            "executeQuery": "DELETE FROM students WHERE id = 1",
            "expected": {}
          },
          {
            "description": "Student's enrollments removed",
            "executeQuery": "SELECT COUNT(*) as remaining FROM enrollments WHERE student_id = 1",
            "expected": {
              "remaining": 0
            }
          }
        ]
      }
    },
    {
      "id": "APP-RELATIONSHIP-FIELD-009",
      "given": "bi-directional relationship with inverse field tracking (post has author, author has posts)",
      "when": "creating inverse relationship fields",
      "then": "Both directions queryable without junction table (one-to-many)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE authors (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE posts (id SERIAL PRIMARY KEY, title VARCHAR(255), author_id INTEGER REFERENCES authors(id) ON DELETE CASCADE)",
            "INSERT INTO authors (id, name) VALUES (1, 'John Doe'), (2, 'Jane Smith')",
            "INSERT INTO posts (title, author_id) VALUES ('Post 1', 1), ('Post 2', 1), ('Post 3', 2), ('Post 4', 1)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "author_id",
            "type": "relationship",
            "relatedTable": "authors",
            "relationType": "one-to-many",
            "inverseField": "posts"
          }
        },
        "assertions": [
          {
            "description": "Query from post to author (forward direction)",
            "executeQuery": "SELECT a.name FROM posts p JOIN authors a ON p.author_id = a.id WHERE p.id = 1",
            "expected": {
              "name": "John Doe"
            }
          },
          {
            "description": "Query from author to posts (inverse direction)",
            "executeQuery": "SELECT COUNT(*) as post_count FROM posts WHERE author_id = 1",
            "expected": {
              "post_count": 3
            }
          },
          {
            "description": "Aggregate posts per author",
            "executeQuery": "SELECT author_id, COUNT(*) as count FROM posts GROUP BY author_id ORDER BY author_id",
            "expected": [
              {
                "author_id": 1,
                "count": 3
              },
              {
                "author_id": 2,
                "count": 1
              }
            ]
          },
          {
            "description": "Deleting author cascades to all their posts",
            "executeQuery": "DELETE FROM authors WHERE id = 1",
            "expected": {}
          },
          {
            "description": "Author's posts deleted via CASCADE",
            "executeQuery": "SELECT COUNT(*) as remaining FROM posts",
            "expected": {
              "remaining": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-RELATIONSHIP-FIELD-010",
      "given": "polymorphic relationship pattern (comments can belong to posts OR videos)",
      "when": "using discriminator column to identify parent type",
      "then": "PostgreSQL CHECK constraint validates commentable_type and foreign key logic",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE posts (id SERIAL PRIMARY KEY, title VARCHAR(255))",
            "CREATE TABLE videos (id SERIAL PRIMARY KEY, title VARCHAR(255))",
            "CREATE TABLE comments (id SERIAL PRIMARY KEY, content TEXT, commentable_type VARCHAR(50) CHECK (commentable_type IN ('post', 'video')), commentable_id INTEGER NOT NULL)",
            "INSERT INTO posts (id, title) VALUES (1, 'Blog Post')",
            "INSERT INTO videos (id, title) VALUES (1, 'Tutorial Video')",
            "INSERT INTO comments (content, commentable_type, commentable_id) VALUES ('Nice post!', 'post', 1), ('Great video!', 'video', 1)"
          ]
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces valid commentable_type",
            "executeQuery": "INSERT INTO comments (content, commentable_type, commentable_id) VALUES ('Invalid', 'invalid_type', 1)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Query comments for post",
            "executeQuery": "SELECT COUNT(*) as count FROM comments WHERE commentable_type = 'post' AND commentable_id = 1",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Query comments for video",
            "executeQuery": "SELECT COUNT(*) as count FROM comments WHERE commentable_type = 'video' AND commentable_id = 1",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Can join to posts using discriminator",
            "executeQuery": "SELECT c.content, p.title FROM comments c JOIN posts p ON c.commentable_id = p.id WHERE c.commentable_type = 'post'",
            "expected": {
              "content": "Nice post!",
              "title": "Blog Post"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-DISPLAYFIELD-001",
      "given": "relationship field with displayField: 'name' (customers.name)",
      "when": "application queries relationship data",
      "then": "application JOINs to fetch display field value instead of showing raw ID",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255))",
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number VARCHAR(50), customer_id INTEGER REFERENCES customers(id))",
            "INSERT INTO customers (name, email) VALUES ('Alice Wonder', 'alice@example.com'), ('Bob Builder', 'bob@example.com')",
            "INSERT INTO orders (order_number, customer_id) VALUES ('ORD-001', 1), ('ORD-002', 2)"
          ],
          "fieldConfig": {
            "name": "customer_id",
            "type": "relationship",
            "relatedTable": "customers",
            "displayField": "name"
          }
        },
        "assertions": [
          {
            "description": "Raw foreign key value stored in database",
            "executeQuery": "SELECT customer_id FROM orders WHERE order_number = 'ORD-001'",
            "expected": {
              "customer_id": 1
            }
          },
          {
            "description": "Application JOIN fetches display field (customer name)",
            "executeQuery": "SELECT o.order_number, c.name as customer_name FROM orders o JOIN customers c ON o.customer_id = c.id WHERE o.order_number = 'ORD-001'",
            "expected": {
              "order_number": "ORD-001",
              "customer_name": "Alice Wonder"
            }
          },
          {
            "description": "Application displays name, not ID (UI representation)",
            "displayField": "name",
            "executeQuery": "SELECT o.order_number, c.name as customer_name FROM orders o JOIN customers c ON o.customer_id = c.id WHERE o.order_number = 'ORD-001'",
            "expectedDisplay": "Alice Wonder",
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-DISPLAYFIELD-002",
      "given": "relationship field with displayField: 'email' (customers.email)",
      "when": "application queries relationship data",
      "then": "application JOINs to fetch email as display value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, username VARCHAR(255), email VARCHAR(255))",
            "CREATE TABLE comments (id SERIAL PRIMARY KEY, content TEXT, author_id INTEGER REFERENCES users(id))",
            "INSERT INTO users (username, email) VALUES ('alice_w', 'alice@example.com'), ('bob_b', 'bob@example.com')",
            "INSERT INTO comments (content, author_id) VALUES ('Great article!', 1), ('Thanks for sharing', 2)"
          ],
          "fieldConfig": {
            "name": "author_id",
            "type": "relationship",
            "relatedTable": "users",
            "displayField": "email"
          }
        },
        "assertions": [
          {
            "description": "Raw foreign key stored",
            "executeQuery": "SELECT author_id FROM comments WHERE content = 'Great article!'",
            "expected": {
              "author_id": 1
            }
          },
          {
            "description": "Application JOIN fetches email as display field",
            "executeQuery": "SELECT c.content, u.email as author_email FROM comments c JOIN users u ON c.author_id = u.id WHERE c.content = 'Great article!'",
            "expected": {
              "content": "Great article!",
              "author_email": "alice@example.com"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-DISPLAYFIELD-003",
      "given": "relationship field with displayField referencing non-existent column",
      "when": "application attempts to JOIN and fetch display field",
      "then": "PostgreSQL returns error for undefined column",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE departments (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE employees (id SERIAL PRIMARY KEY, emp_name VARCHAR(255), department_id INTEGER REFERENCES departments(id))",
            "INSERT INTO departments (name) VALUES ('Engineering')",
            "INSERT INTO employees (emp_name, department_id) VALUES ('Alice', 1)"
          ],
          "fieldConfig": {
            "name": "department_id",
            "type": "relationship",
            "relatedTable": "departments",
            "displayField": "nonexistent_column"
          }
        },
        "assertions": [
          {
            "description": "Query with non-existent displayField fails",
            "executeQuery": "SELECT e.emp_name, d.nonexistent_column FROM employees e JOIN departments d ON e.department_id = d.id",
            "expectError": "column \"nonexistent_column\" does not exist"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-DISPLAYFIELD-004",
      "given": "relationship field with empty displayField value",
      "when": "field configuration validation runs",
      "then": "error should require minimum length 1 character",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "customer_id",
            "type": "relationship",
            "relatedTable": "customers",
            "displayField": ""
          }
        },
        "assertions": [
          {
            "description": "Empty displayField rejected",
            "validateConfig": true,
            "expectError": "displayField must have at least 1 character"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-DISPLAYFIELD-005",
      "given": "relationship field without displayField specified",
      "when": "application queries relationship data",
      "then": "application displays raw foreign key ID (no JOIN for display value)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE categories (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE products (id SERIAL PRIMARY KEY, product_name VARCHAR(255), category_id INTEGER REFERENCES categories(id))",
            "INSERT INTO categories (name) VALUES ('Electronics')",
            "INSERT INTO products (product_name, category_id) VALUES ('Laptop', 1)"
          ],
          "fieldConfig": {
            "name": "category_id",
            "type": "relationship",
            "relatedTable": "categories"
          }
        },
        "assertions": [
          {
            "description": "Without displayField: application shows raw ID",
            "executeQuery": "SELECT category_id FROM products WHERE product_name = 'Laptop'",
            "expected": {
              "category_id": 1
            }
          },
          {
            "description": "Application can still manually JOIN if needed",
            "executeQuery": "SELECT p.product_name, c.name as category_name FROM products p JOIN categories c ON p.category_id = c.id WHERE p.product_name = 'Laptop'",
            "expected": {
              "product_name": "Laptop",
              "category_name": "Electronics"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-DISPLAYFIELD-006",
      "given": "relationship field with displayField: composite display (CONCAT)",
      "when": "displayField references computed expression",
      "then": "application uses expression in JOIN to build display value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE contacts (id SERIAL PRIMARY KEY, first_name VARCHAR(255), last_name VARCHAR(255), email VARCHAR(255))",
            "CREATE TABLE meetings (id SERIAL PRIMARY KEY, title VARCHAR(255), organizer_id INTEGER REFERENCES contacts(id))",
            "INSERT INTO contacts (first_name, last_name, email) VALUES ('Alice', 'Wonder', 'alice@example.com'), ('Bob', 'Builder', 'bob@example.com')",
            "INSERT INTO meetings (title, organizer_id) VALUES ('Sprint Planning', 1), ('Retrospective', 2)"
          ],
          "fieldConfig": {
            "name": "organizer_id",
            "type": "relationship",
            "relatedTable": "contacts",
            "displayField": "CONCAT(first_name, ' ', last_name)"
          }
        },
        "assertions": [
          {
            "description": "Raw foreign key stored",
            "executeQuery": "SELECT organizer_id FROM meetings WHERE title = 'Sprint Planning'",
            "expected": {
              "organizer_id": 1
            }
          },
          {
            "description": "Application uses expression to build display value",
            "executeQuery": "SELECT m.title, CONCAT(c.first_name, ' ', c.last_name) as organizer_name FROM meetings m JOIN contacts c ON m.organizer_id = c.id WHERE m.title = 'Sprint Planning'",
            "expected": {
              "title": "Sprint Planning",
              "organizer_name": "Alice Wonder"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONDELETE-001",
      "given": "relationship field with onDelete: 'cascade'",
      "when": "parent record deleted",
      "then": "PostgreSQL automatically deletes all child records (CASCADE)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255))",
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number VARCHAR(50), customer_id INTEGER REFERENCES customers(id) ON DELETE CASCADE)",
            "INSERT INTO customers (name, email) VALUES ('Alice', 'alice@example.com'), ('Bob', 'bob@example.com')",
            "INSERT INTO orders (order_number, customer_id) VALUES ('ORD-001', 1), ('ORD-002', 1), ('ORD-003', 2)"
          ],
          "fieldConfig": {
            "name": "customer_id",
            "type": "relationship",
            "relatedTable": "customers",
            "onDelete": "cascade"
          }
        },
        "assertions": [
          {
            "description": "Foreign key has ON DELETE CASCADE",
            "executeQuery": "SELECT rc.delete_rule FROM information_schema.referential_constraints rc JOIN information_schema.table_constraints tc ON rc.constraint_name = tc.constraint_name WHERE tc.table_name = 'orders' AND tc.constraint_type = 'FOREIGN KEY'",
            "expected": {
              "delete_rule": "CASCADE"
            }
          },
          {
            "description": "Before deletion: customer 1 has 2 orders",
            "executeQuery": "SELECT COUNT(*) as count FROM orders WHERE customer_id = 1",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Delete parent customer",
            "executeQuery": "DELETE FROM customers WHERE id = 1 RETURNING name",
            "expected": {
              "name": "Alice"
            }
          },
          {
            "description": "After deletion: child orders automatically deleted (CASCADE)",
            "executeQuery": "SELECT COUNT(*) as count FROM orders WHERE customer_id = 1",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Other customer's orders unaffected",
            "executeQuery": "SELECT COUNT(*) as count FROM orders WHERE customer_id = 2",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONDELETE-002",
      "given": "relationship field with onDelete: 'set-null'",
      "when": "parent record deleted",
      "then": "PostgreSQL sets child foreign key columns to NULL (SET NULL)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE departments (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE employees (id SERIAL PRIMARY KEY, name VARCHAR(255), department_id INTEGER REFERENCES departments(id) ON DELETE SET NULL)",
            "INSERT INTO departments (name) VALUES ('Engineering'), ('Sales')",
            "INSERT INTO employees (name, department_id) VALUES ('Alice', 1), ('Bob', 1), ('Charlie', 2)"
          ],
          "fieldConfig": {
            "name": "department_id",
            "type": "relationship",
            "relatedTable": "departments",
            "onDelete": "set-null"
          }
        },
        "assertions": [
          {
            "description": "Foreign key has ON DELETE SET NULL",
            "executeQuery": "SELECT rc.delete_rule FROM information_schema.referential_constraints rc JOIN information_schema.table_constraints tc ON rc.constraint_name = tc.constraint_name WHERE tc.table_name = 'employees' AND tc.constraint_type = 'FOREIGN KEY'",
            "expected": {
              "delete_rule": "SET NULL"
            }
          },
          {
            "description": "Before deletion: employees have department_id",
            "executeQuery": "SELECT name FROM employees WHERE department_id = 1 ORDER BY name",
            "expected": [
              {
                "name": "Alice"
              },
              {
                "name": "Bob"
              }
            ]
          },
          {
            "description": "Delete parent department",
            "executeQuery": "DELETE FROM departments WHERE id = 1 RETURNING name",
            "expected": {
              "name": "Engineering"
            }
          },
          {
            "description": "After deletion: employees' department_id set to NULL",
            "executeQuery": "SELECT name FROM employees WHERE department_id IS NULL ORDER BY name",
            "expected": [
              {
                "name": "Alice"
              },
              {
                "name": "Bob"
              }
            ]
          },
          {
            "description": "Employees still exist (not deleted, just orphaned)",
            "executeQuery": "SELECT COUNT(*) as count FROM employees",
            "expected": {
              "count": 3
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONDELETE-003",
      "given": "relationship field with onDelete: 'restrict'",
      "when": "attempting to delete parent record with children",
      "then": "PostgreSQL prevents deletion and returns error (RESTRICT)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE categories (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE products (id SERIAL PRIMARY KEY, name VARCHAR(255), category_id INTEGER REFERENCES categories(id) ON DELETE RESTRICT)",
            "INSERT INTO categories (name) VALUES ('Electronics'), ('Clothing')",
            "INSERT INTO products (name, category_id) VALUES ('Laptop', 1), ('Smartphone', 1), ('T-Shirt', 2)"
          ],
          "fieldConfig": {
            "name": "category_id",
            "type": "relationship",
            "relatedTable": "categories",
            "onDelete": "restrict"
          }
        },
        "assertions": [
          {
            "description": "Foreign key has ON DELETE RESTRICT",
            "executeQuery": "SELECT rc.delete_rule FROM information_schema.referential_constraints rc JOIN information_schema.table_constraints tc ON rc.constraint_name = tc.constraint_name WHERE tc.table_name = 'products' AND tc.constraint_type = 'FOREIGN KEY'",
            "expected": {
              "delete_rule": "RESTRICT"
            }
          },
          {
            "description": "Category 1 has 2 products",
            "executeQuery": "SELECT COUNT(*) as count FROM products WHERE category_id = 1",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Cannot delete category with existing products",
            "executeQuery": "DELETE FROM categories WHERE id = 1",
            "expectError": "violates foreign key constraint"
          },
          {
            "description": "After failed deletion: category still exists",
            "executeQuery": "SELECT name FROM categories WHERE id = 1",
            "expected": {
              "name": "Electronics"
            }
          },
          {
            "description": "After failed deletion: products still exist",
            "executeQuery": "SELECT COUNT(*) as count FROM products WHERE category_id = 1",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONDELETE-004",
      "given": "relationship field with onDelete: 'no-action'",
      "when": "attempting to delete parent record with children",
      "then": "PostgreSQL prevents deletion (NO ACTION, deferred check)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE projects (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), project_id INTEGER REFERENCES projects(id) ON DELETE NO ACTION)",
            "INSERT INTO projects (name) VALUES ('Website Redesign'), ('Mobile App')",
            "INSERT INTO tasks (title, project_id) VALUES ('Design mockups', 1), ('Implement backend', 1)"
          ],
          "fieldConfig": {
            "name": "project_id",
            "type": "relationship",
            "relatedTable": "projects",
            "onDelete": "no-action"
          }
        },
        "assertions": [
          {
            "description": "Foreign key has ON DELETE NO ACTION",
            "executeQuery": "SELECT rc.delete_rule FROM information_schema.referential_constraints rc JOIN information_schema.table_constraints tc ON rc.constraint_name = tc.constraint_name WHERE tc.table_name = 'tasks' AND tc.constraint_type = 'FOREIGN KEY'",
            "expected": {
              "delete_rule": "NO ACTION"
            }
          },
          {
            "description": "Cannot delete project with existing tasks",
            "executeQuery": "DELETE FROM projects WHERE id = 1",
            "expectError": "violates foreign key constraint"
          },
          {
            "description": "After failed deletion: project still exists",
            "executeQuery": "SELECT name FROM projects WHERE id = 1",
            "expected": {
              "name": "Website Redesign"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONDELETE-005",
      "given": "relationship field with invalid onDelete value",
      "when": "field configuration validation runs",
      "then": "error lists valid options: cascade, set-null, restrict, no-action",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "customer_id",
            "type": "relationship",
            "relatedTable": "customers",
            "onDelete": "INVALID-ACTION"
          }
        },
        "assertions": [
          {
            "description": "Invalid onDelete rejected with enum error",
            "validateConfig": true,
            "expectError": "onDelete must be one of: cascade, set-null, restrict, no-action"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONDELETE-006",
      "given": "relationship field without onDelete specified",
      "when": "field configuration uses default",
      "then": "PostgreSQL uses RESTRICT as default action",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE authors (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE books (id SERIAL PRIMARY KEY, title VARCHAR(255), author_id INTEGER REFERENCES authors(id))",
            "INSERT INTO authors (name) VALUES ('Jane Austen')",
            "INSERT INTO books (title, author_id) VALUES ('Pride and Prejudice', 1)"
          ],
          "fieldConfig": {
            "name": "author_id",
            "type": "relationship",
            "relatedTable": "authors"
          }
        },
        "assertions": [
          {
            "description": "Default onDelete is RESTRICT (or NO ACTION depending on PostgreSQL version)",
            "executeQuery": "SELECT rc.delete_rule FROM information_schema.referential_constraints rc JOIN information_schema.table_constraints tc ON rc.constraint_name = tc.constraint_name WHERE tc.table_name = 'books' AND tc.constraint_type = 'FOREIGN KEY'",
            "expected": {
              "delete_rule": "NO ACTION"
            }
          },
          {
            "description": "Cannot delete author with existing books (default behavior)",
            "executeQuery": "DELETE FROM authors WHERE id = 1",
            "expectError": "violates foreign key constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONUPDATE-001",
      "given": "relationship field with onUpdate: 'cascade'",
      "when": "parent record's primary key updated",
      "then": "PostgreSQL automatically updates all child foreign keys (CASCADE)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id INTEGER PRIMARY KEY, name VARCHAR(255), email VARCHAR(255))",
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number VARCHAR(50), customer_id INTEGER REFERENCES customers(id) ON UPDATE CASCADE)",
            "INSERT INTO customers (id, name, email) VALUES (1, 'Alice', 'alice@example.com'), (2, 'Bob', 'bob@example.com')",
            "INSERT INTO orders (order_number, customer_id) VALUES ('ORD-001', 1), ('ORD-002', 1), ('ORD-003', 2)"
          ],
          "fieldConfig": {
            "name": "customer_id",
            "type": "relationship",
            "relatedTable": "customers",
            "onUpdate": "cascade"
          }
        },
        "assertions": [
          {
            "description": "Foreign key has ON UPDATE CASCADE",
            "executeQuery": "SELECT rc.update_rule FROM information_schema.referential_constraints rc JOIN information_schema.table_constraints tc ON rc.constraint_name = tc.constraint_name WHERE tc.table_name = 'orders' AND tc.constraint_type = 'FOREIGN KEY'",
            "expected": {
              "update_rule": "CASCADE"
            }
          },
          {
            "description": "Before update: customer 1 has 2 orders",
            "executeQuery": "SELECT COUNT(*) as count FROM orders WHERE customer_id = 1",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Update parent customer's ID",
            "executeQuery": "UPDATE customers SET id = 100 WHERE id = 1 RETURNING name",
            "expected": {
              "name": "Alice"
            }
          },
          {
            "description": "After update: child orders' customer_id automatically updated (CASCADE)",
            "executeQuery": "SELECT COUNT(*) as count FROM orders WHERE customer_id = 100",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Old customer_id no longer exists in child records",
            "executeQuery": "SELECT COUNT(*) as count FROM orders WHERE customer_id = 1",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Other customer's orders unaffected",
            "executeQuery": "SELECT COUNT(*) as count FROM orders WHERE customer_id = 2",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONUPDATE-002",
      "given": "relationship field with onUpdate: 'set-null'",
      "when": "parent record's primary key updated",
      "then": "PostgreSQL sets child foreign key columns to NULL (SET NULL)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE departments (id INTEGER PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE employees (id SERIAL PRIMARY KEY, name VARCHAR(255), department_id INTEGER REFERENCES departments(id) ON UPDATE SET NULL)",
            "INSERT INTO departments (id, name) VALUES (1, 'Engineering'), (2, 'Sales')",
            "INSERT INTO employees (name, department_id) VALUES ('Alice', 1), ('Bob', 1), ('Charlie', 2)"
          ],
          "fieldConfig": {
            "name": "department_id",
            "type": "relationship",
            "relatedTable": "departments",
            "onUpdate": "set-null"
          }
        },
        "assertions": [
          {
            "description": "Foreign key has ON UPDATE SET NULL",
            "executeQuery": "SELECT rc.update_rule FROM information_schema.referential_constraints rc JOIN information_schema.table_constraints tc ON rc.constraint_name = tc.constraint_name WHERE tc.table_name = 'employees' AND tc.constraint_type = 'FOREIGN KEY'",
            "expected": {
              "update_rule": "SET NULL"
            }
          },
          {
            "description": "Before update: employees have department_id",
            "executeQuery": "SELECT name FROM employees WHERE department_id = 1 ORDER BY name",
            "expected": [
              {
                "name": "Alice"
              },
              {
                "name": "Bob"
              }
            ]
          },
          {
            "description": "Update parent department's ID",
            "executeQuery": "UPDATE departments SET id = 100 WHERE id = 1 RETURNING name",
            "expected": {
              "name": "Engineering"
            }
          },
          {
            "description": "After update: employees' department_id set to NULL",
            "executeQuery": "SELECT name FROM employees WHERE department_id IS NULL ORDER BY name",
            "expected": [
              {
                "name": "Alice"
              },
              {
                "name": "Bob"
              }
            ]
          },
          {
            "description": "Employees still exist (not deleted, just orphaned)",
            "executeQuery": "SELECT COUNT(*) as count FROM employees",
            "expected": {
              "count": 3
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONUPDATE-003",
      "given": "relationship field with onUpdate: 'restrict'",
      "when": "attempting to update parent record's key with children",
      "then": "PostgreSQL prevents update and returns error (RESTRICT)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE categories (id INTEGER PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE products (id SERIAL PRIMARY KEY, name VARCHAR(255), category_id INTEGER REFERENCES categories(id) ON UPDATE RESTRICT)",
            "INSERT INTO categories (id, name) VALUES (1, 'Electronics'), (2, 'Clothing')",
            "INSERT INTO products (name, category_id) VALUES ('Laptop', 1), ('Smartphone', 1), ('T-Shirt', 2)"
          ],
          "fieldConfig": {
            "name": "category_id",
            "type": "relationship",
            "relatedTable": "categories",
            "onUpdate": "restrict"
          }
        },
        "assertions": [
          {
            "description": "Foreign key has ON UPDATE RESTRICT",
            "executeQuery": "SELECT rc.update_rule FROM information_schema.referential_constraints rc JOIN information_schema.table_constraints tc ON rc.constraint_name = tc.constraint_name WHERE tc.table_name = 'products' AND tc.constraint_type = 'FOREIGN KEY'",
            "expected": {
              "update_rule": "RESTRICT"
            }
          },
          {
            "description": "Category 1 has 2 products",
            "executeQuery": "SELECT COUNT(*) as count FROM products WHERE category_id = 1",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Cannot update category ID with existing products",
            "executeQuery": "UPDATE categories SET id = 100 WHERE id = 1",
            "expectError": "violates foreign key constraint"
          },
          {
            "description": "After failed update: category ID unchanged",
            "executeQuery": "SELECT name FROM categories WHERE id = 1",
            "expected": {
              "name": "Electronics"
            }
          },
          {
            "description": "After failed update: products still reference old ID",
            "executeQuery": "SELECT COUNT(*) as count FROM products WHERE category_id = 1",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONUPDATE-004",
      "given": "relationship field with onUpdate: 'no-action'",
      "when": "attempting to update parent record's key with children",
      "then": "PostgreSQL prevents update (NO ACTION, deferred check)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE projects (id INTEGER PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), project_id INTEGER REFERENCES projects(id) ON UPDATE NO ACTION)",
            "INSERT INTO projects (id, name) VALUES (1, 'Website Redesign'), (2, 'Mobile App')",
            "INSERT INTO tasks (title, project_id) VALUES ('Design mockups', 1), ('Implement backend', 1)"
          ],
          "fieldConfig": {
            "name": "project_id",
            "type": "relationship",
            "relatedTable": "projects",
            "onUpdate": "no-action"
          }
        },
        "assertions": [
          {
            "description": "Foreign key has ON UPDATE NO ACTION",
            "executeQuery": "SELECT rc.update_rule FROM information_schema.referential_constraints rc JOIN information_schema.table_constraints tc ON rc.constraint_name = tc.constraint_name WHERE tc.table_name = 'tasks' AND tc.constraint_type = 'FOREIGN KEY'",
            "expected": {
              "update_rule": "NO ACTION"
            }
          },
          {
            "description": "Cannot update project ID with existing tasks",
            "executeQuery": "UPDATE projects SET id = 100 WHERE id = 1",
            "expectError": "violates foreign key constraint"
          },
          {
            "description": "After failed update: project ID unchanged",
            "executeQuery": "SELECT name FROM projects WHERE id = 1",
            "expected": {
              "name": "Website Redesign"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONUPDATE-005",
      "given": "relationship field with invalid onUpdate value",
      "when": "field configuration validation runs",
      "then": "error lists valid options: cascade, set-null, restrict, no-action",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "customer_id",
            "type": "relationship",
            "relatedTable": "customers",
            "onUpdate": "INVALID-ACTION"
          }
        },
        "assertions": [
          {
            "description": "Invalid onUpdate rejected with enum error",
            "validateConfig": true,
            "expectError": "onUpdate must be one of: cascade, set-null, restrict, no-action"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-ONUPDATE-006",
      "given": "relationship field without onUpdate specified",
      "when": "field configuration uses default",
      "then": "PostgreSQL uses CASCADE as default action",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE authors (id INTEGER PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE books (id SERIAL PRIMARY KEY, title VARCHAR(255), author_id INTEGER REFERENCES authors(id))",
            "INSERT INTO authors (id, name) VALUES (1, 'Jane Austen')",
            "INSERT INTO books (title, author_id) VALUES ('Pride and Prejudice', 1)"
          ],
          "fieldConfig": {
            "name": "author_id",
            "type": "relationship",
            "relatedTable": "authors"
          }
        },
        "assertions": [
          {
            "description": "Default onUpdate is CASCADE (or NO ACTION depending on PostgreSQL version)",
            "executeQuery": "SELECT rc.update_rule FROM information_schema.referential_constraints rc JOIN information_schema.table_constraints tc ON rc.constraint_name = tc.constraint_name WHERE tc.table_name = 'books' AND tc.constraint_type = 'FOREIGN KEY'",
            "expected": {
              "update_rule": "NO ACTION"
            }
          },
          {
            "description": "With default NO ACTION: cannot update author ID with existing books",
            "executeQuery": "UPDATE authors SET id = 100 WHERE id = 1",
            "expectError": "violates foreign key constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-RELATEDTABLE-001",
      "given": "relationship field with relatedTable: 'customers' (existing table)",
      "when": "field migration creates FOREIGN KEY constraint",
      "then": "PostgreSQL creates foreign key referencing customers table",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255))",
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number VARCHAR(50), customer_id INTEGER REFERENCES customers(id))",
            "INSERT INTO customers (name, email) VALUES ('Alice', 'alice@example.com'), ('Bob', 'bob@example.com')",
            "INSERT INTO orders (order_number, customer_id) VALUES ('ORD-001', 1), ('ORD-002', 2)"
          ],
          "fieldConfig": {
            "name": "customer_id",
            "type": "relationship",
            "relatedTable": "customers"
          }
        },
        "assertions": [
          {
            "description": "Foreign key constraint exists referencing customers table",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'FOREIGN KEY' AND table_name = 'orders'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Foreign key references customers table primary key",
            "executeQuery": "SELECT kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.key_column_usage AS kcu JOIN information_schema.constraint_column_usage AS ccu ON kcu.constraint_name = ccu.constraint_name WHERE kcu.table_name = 'orders' AND kcu.column_name = 'customer_id'",
            "expected": {
              "column_name": "customer_id",
              "foreign_table_name": "customers",
              "foreign_column_name": "id"
            }
          },
          {
            "description": "Valid foreign key value accepted",
            "executeQuery": "SELECT order_number FROM orders WHERE customer_id = 1",
            "expected": {
              "order_number": "ORD-001"
            }
          },
          {
            "description": "Invalid foreign key value rejected (non-existent customer)",
            "executeQuery": "INSERT INTO orders (order_number, customer_id) VALUES ('ORD-999', 9999)",
            "expectError": "violates foreign key constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-RELATEDTABLE-002",
      "given": "relationship field with relatedTable: 'nonexistent_table'",
      "when": "field migration attempts to create FOREIGN KEY",
      "then": "PostgreSQL returns error for non-existent table",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number VARCHAR(50), invalid_ref INTEGER REFERENCES nonexistent_table(id))"
          ],
          "fieldConfig": {
            "name": "invalid_ref",
            "type": "relationship",
            "relatedTable": "nonexistent_table"
          }
        },
        "assertions": [
          {
            "description": "Foreign key to non-existent table rejected",
            "executeQuery": "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number VARCHAR(50), invalid_ref INTEGER REFERENCES nonexistent_table(id))",
            "expectError": "relation \"nonexistent_table\" does not exist"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-RELATEDTABLE-003",
      "given": "relationship field with empty relatedTable value",
      "when": "field configuration validation runs",
      "then": "error should require minimum length 1 character",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "customer_id",
            "type": "relationship",
            "relatedTable": ""
          }
        },
        "assertions": [
          {
            "description": "Empty relatedTable rejected",
            "validateConfig": true,
            "expectError": "relatedTable must have at least 1 character"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-RELATEDTABLE-004",
      "given": "relationship field referencing table with composite primary key",
      "when": "field migration creates FOREIGN KEY",
      "then": "PostgreSQL creates foreign key with multiple columns referencing composite key",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE locations (country_code CHAR(2), region_code CHAR(3), name VARCHAR(255), PRIMARY KEY (country_code, region_code))",
            "CREATE TABLE stores (id SERIAL PRIMARY KEY, store_name VARCHAR(255), location_country CHAR(2), location_region CHAR(3), FOREIGN KEY (location_country, location_region) REFERENCES locations(country_code, region_code))",
            "INSERT INTO locations (country_code, region_code, name) VALUES ('US', 'NYC', 'New York'), ('US', 'LAX', 'Los Angeles')",
            "INSERT INTO stores (store_name, location_country, location_region) VALUES ('Store A', 'US', 'NYC')"
          ],
          "fieldConfig": {
            "name": "location",
            "type": "relationship",
            "relatedTable": "locations",
            "foreignKeyColumns": [
              "location_country",
              "location_region"
            ]
          }
        },
        "assertions": [
          {
            "description": "Composite foreign key constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'FOREIGN KEY' AND table_name = 'stores'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Valid composite foreign key accepted",
            "executeQuery": "SELECT store_name FROM stores WHERE location_country = 'US' AND location_region = 'NYC'",
            "expected": {
              "store_name": "Store A"
            }
          },
          {
            "description": "Invalid composite foreign key rejected",
            "executeQuery": "INSERT INTO stores (store_name, location_country, location_region) VALUES ('Store B', 'US', 'XXX')",
            "expectError": "violates foreign key constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-RELATIONTYPE-001",
      "given": "relationship field with relationType: 'one-to-many' (orders â†’ customer)",
      "when": "field migration creates simple FOREIGN KEY",
      "then": "PostgreSQL creates foreign key column without uniqueness constraint",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255))",
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number VARCHAR(50), customer_id INTEGER REFERENCES customers(id))",
            "INSERT INTO customers (name, email) VALUES ('Alice', 'alice@example.com')",
            "INSERT INTO orders (order_number, customer_id) VALUES ('ORD-001', 1), ('ORD-002', 1), ('ORD-003', 1)"
          ],
          "fieldConfig": {
            "name": "customer_id",
            "type": "relationship",
            "relatedTable": "customers",
            "relationType": "one-to-many"
          }
        },
        "assertions": [
          {
            "description": "Foreign key constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'FOREIGN KEY' AND table_name = 'orders'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "No unique constraint on foreign key column",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'UNIQUE' AND table_name = 'orders' AND constraint_name LIKE '%customer_id%'",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Multiple orders can reference same customer (one-to-many)",
            "executeQuery": "SELECT COUNT(*) as count FROM orders WHERE customer_id = 1",
            "expected": {
              "count": 3
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-RELATIONTYPE-002",
      "given": "relationship field with relationType: 'one-to-one' (user â†’ profile)",
      "when": "field migration creates FOREIGN KEY with UNIQUE constraint",
      "then": "PostgreSQL enforces one-to-one relationship via unique foreign key",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE profiles (id SERIAL PRIMARY KEY, bio TEXT, avatar_url VARCHAR(255))",
            "CREATE TABLE users (id SERIAL PRIMARY KEY, username VARCHAR(255), profile_id INTEGER UNIQUE REFERENCES profiles(id))",
            "INSERT INTO profiles (bio, avatar_url) VALUES ('Software engineer', 'https://example.com/avatar1.jpg'), ('Designer', 'https://example.com/avatar2.jpg')",
            "INSERT INTO users (username, profile_id) VALUES ('alice', 1)"
          ],
          "fieldConfig": {
            "name": "profile_id",
            "type": "relationship",
            "relatedTable": "profiles",
            "relationType": "one-to-one"
          }
        },
        "assertions": [
          {
            "description": "Foreign key constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'FOREIGN KEY' AND table_name = 'users'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Unique constraint exists on foreign key column",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'UNIQUE' AND table_name = 'users' AND constraint_name LIKE '%profile_id%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "First user-profile link succeeds",
            "executeQuery": "SELECT username FROM users WHERE profile_id = 1",
            "expected": {
              "username": "alice"
            }
          },
          {
            "description": "Duplicate profile_id rejected (violates one-to-one)",
            "executeQuery": "INSERT INTO users (username, profile_id) VALUES ('bob', 1)",
            "expectError": "duplicate key value violates unique constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-RELATIONTYPE-003",
      "given": "relationship field with relationType: 'many-to-many' (students â†” courses)",
      "when": "field migration creates junction table with two foreign keys",
      "then": "PostgreSQL creates junction table enabling many-to-many relationship",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE students (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255))",
            "CREATE TABLE courses (id SERIAL PRIMARY KEY, title VARCHAR(255), code VARCHAR(50))",
            "CREATE TABLE student_courses (student_id INTEGER REFERENCES students(id), course_id INTEGER REFERENCES courses(id), PRIMARY KEY (student_id, course_id))",
            "INSERT INTO students (name, email) VALUES ('Alice', 'alice@example.com'), ('Bob', 'bob@example.com')",
            "INSERT INTO courses (title, code) VALUES ('Mathematics', 'MATH101'), ('Physics', 'PHYS101')",
            "INSERT INTO student_courses (student_id, course_id) VALUES (1, 1), (1, 2), (2, 1)"
          ],
          "fieldConfig": {
            "name": "courses",
            "type": "relationship",
            "relatedTable": "courses",
            "relationType": "many-to-many",
            "junctionTable": "student_courses"
          }
        },
        "assertions": [
          {
            "description": "Junction table has two foreign keys",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'FOREIGN KEY' AND table_name = 'student_courses'",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Junction table has composite primary key",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'PRIMARY KEY' AND table_name = 'student_courses'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "One student can enroll in multiple courses",
            "executeQuery": "SELECT COUNT(*) as count FROM student_courses WHERE student_id = 1",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "One course can have multiple students",
            "executeQuery": "SELECT COUNT(*) as count FROM student_courses WHERE course_id = 1",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Duplicate enrollment rejected (composite PK prevents duplicates)",
            "executeQuery": "INSERT INTO student_courses (student_id, course_id) VALUES (1, 1)",
            "expectError": "duplicate key value violates unique constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-RELATIONTYPE-004",
      "given": "relationship field with invalid relationType value",
      "when": "field configuration validation runs",
      "then": "error lists valid options: one-to-one, one-to-many, many-to-many",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "customer_id",
            "type": "relationship",
            "relatedTable": "customers",
            "relationType": "INVALID-TYPE"
          }
        },
        "assertions": [
          {
            "description": "Invalid relationType rejected with enum error",
            "validateConfig": true,
            "expectError": "relationType must be one of: one-to-one, one-to-many, many-to-many"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RELATIONSHIP-RELATIONTYPE-005",
      "given": "relationship field without relationType specified",
      "when": "field configuration uses default",
      "then": "PostgreSQL creates one-to-many relationship (default)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE departments (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE employees (id SERIAL PRIMARY KEY, name VARCHAR(255), department_id INTEGER REFERENCES departments(id))",
            "INSERT INTO departments (name) VALUES ('Engineering'), ('Sales')",
            "INSERT INTO employees (name, department_id) VALUES ('Alice', 1), ('Bob', 1), ('Charlie', 2)"
          ],
          "fieldConfig": {
            "name": "department_id",
            "type": "relationship",
            "relatedTable": "departments"
          }
        },
        "assertions": [
          {
            "description": "Default relationType is one-to-many",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'FOREIGN KEY' AND table_name = 'employees'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "No unique constraint (confirms one-to-many, not one-to-one)",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'UNIQUE' AND table_name = 'employees' AND constraint_name LIKE '%department_id%'",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Multiple employees in same department (one-to-many works)",
            "executeQuery": "SELECT COUNT(*) as count FROM employees WHERE department_id = 1",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    }
  ]
}
