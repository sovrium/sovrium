{
  "$id": "single-select-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Single Select Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "type": "string",
      "const": "single-select"
    },
    "options": {
      "$ref": "./options/options.schema.json"
    },
    "default": {
      "$ref": "./default/default.schema.json"
    }
  },
  "description": "Single selection dropdown from predefined options. Users can choose exactly one value from the list. Useful for status fields (Active, Inactive, Pending), categories, priority levels (High, Medium, Low), and enumerated values. Requires at least one option. Supports default value. Indexing improves filtering by option value.",
  "required": ["id", "name", "type", "options"],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-FIELD-SINGLE-SELECT-001",
      "given": "table configuration with single-select field 'priority' (options: High, Medium, Low)",
      "when": "field migration creates column",
      "then": "PostgreSQL VARCHAR column with CHECK constraint for enum values is created",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE tasks (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "priority",
            "type": "single-select",
            "options": [
              {
                "value": "High",
                "label": "High",
                "color": "red"
              },
              {
                "value": "Medium",
                "label": "Medium",
                "color": "yellow"
              },
              {
                "value": "Low",
                "label": "Low",
                "color": "green"
              }
            ]
          }
        },
        "assertions": [
          {
            "description": "Column created as VARCHAR",
            "executeQuery": "SELECT column_name, data_type FROM information_schema.columns WHERE table_name='tasks' AND column_name='priority'",
            "expected": {
              "column_name": "priority",
              "data_type": "character varying"
            }
          },
          {
            "description": "CHECK constraint exists for enum values",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%priority%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Valid option value can be inserted",
            "executeQuery": "INSERT INTO tasks (priority) VALUES ('High') RETURNING priority",
            "expected": {
              "priority": "High"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-SELECT-002",
      "given": "table 'issues' with single-select field 'status' (options: Open, In Progress, Closed)",
      "when": "invalid value is inserted",
      "then": "PostgreSQL CHECK constraint rejects value not in options",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE issues (id SERIAL PRIMARY KEY, status VARCHAR(50) CHECK (status IN ('Open', 'In Progress', 'Closed')))"
        },
        "assertions": [
          {
            "description": "Valid option 'Open' succeeds",
            "executeQuery": "INSERT INTO issues (status) VALUES ('Open') RETURNING status",
            "expected": {
              "status": "Open"
            }
          },
          {
            "description": "Valid option 'In Progress' succeeds",
            "executeQuery": "INSERT INTO issues (status) VALUES ('In Progress') RETURNING status",
            "expected": {
              "status": "In Progress"
            }
          },
          {
            "description": "Invalid value rejected by CHECK constraint",
            "executeQuery": "INSERT INTO issues (status) VALUES ('Invalid Status')",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-SINGLE-SELECT-FIELD-003",
      "given": "table 'products' with single-select field 'category' (required, unique)",
      "when": "constraints are applied",
      "then": "PostgreSQL enforces NOT NULL and UNIQUE constraints",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, category VARCHAR(50) UNIQUE NOT NULL CHECK (category IN ('Electronics', 'Clothing', 'Food')))",
            "INSERT INTO products (category) VALUES ('Electronics')"
          ]
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='products' AND column_name='category'",
            "expected": {
              "is_nullable": "NO"
            }
          },
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='products' AND constraint_type='UNIQUE' AND constraint_name LIKE '%category%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Duplicate value rejected",
            "executeQuery": "INSERT INTO products (category) VALUES ('Electronics')",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "NULL value rejected",
            "executeQuery": "INSERT INTO products (category) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-SINGLE-SELECT-FIELD-004",
      "given": "table 'tickets' with single-select field 'severity' and default value 'Low'",
      "when": "row inserted without providing severity value",
      "then": "PostgreSQL applies DEFAULT value 'Low'",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE tickets (id SERIAL PRIMARY KEY, severity VARCHAR(50) DEFAULT 'Low' CHECK (severity IN ('Critical', 'High', 'Medium', 'Low')))",
          "fieldConfig": {
            "id": 1,
            "name": "severity",
            "type": "single-select",
            "options": [
              {
                "value": "Critical"
              },
              {
                "value": "High"
              },
              {
                "value": "Medium"
              },
              {
                "value": "Low"
              }
            ],
            "default": "Low"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT value",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='tickets' AND column_name='severity'",
            "expected": {
              "column_default": "'Low'::character varying"
            }
          },
          {
            "description": "INSERT without severity uses default",
            "executeQuery": "INSERT INTO tickets (id) VALUES (DEFAULT) RETURNING severity",
            "expected": {
              "severity": "Low"
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO tickets (severity) VALUES ('Critical') RETURNING severity",
            "expected": {
              "severity": "Critical"
            }
          }
        ]
      }
    },
    {
      "id": "APP-SINGLE-SELECT-FIELD-005",
      "given": "table configuration with single-select field 'type', indexed=true",
      "when": "index is created on the single-select field",
      "then": "PostgreSQL btree index exists for fast filtering by option value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE documents (id SERIAL PRIMARY KEY, type VARCHAR(50) NOT NULL CHECK (type IN ('PDF', 'Word', 'Excel')))",
            "CREATE INDEX idx_documents_type ON documents(type)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "type",
            "type": "single-select",
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_documents_type'",
            "expected": {
              "indexname": "idx_documents_type",
              "tablename": "documents"
            }
          },
          {
            "description": "Index uses btree for option filtering",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_documents_type'",
            "expected": {
              "indexdef": "CREATE INDEX idx_documents_type ON public.documents USING btree (type)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-SELECT-DEFAULT-001",
      "given": "single-select field with default: 'option_1'",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL DEFAULT constraint provides default option",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, name VARCHAR(255), category VARCHAR(50) DEFAULT 'option_1')",
            "INSERT INTO products (name) VALUES ('Product A')"
          ],
          "fieldConfig": {
            "name": "category",
            "type": "single-select",
            "options": [
              {
                "id": "option_1",
                "value": "Electronics"
              },
              {
                "id": "option_2",
                "value": "Clothing"
              },
              {
                "id": "option_3",
                "value": "Food"
              }
            ],
            "default": "option_1"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT constraint with option",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='products' AND column_name='category'",
            "expected": {
              "column_default": "'option_1'::character varying"
            }
          },
          {
            "description": "INSERT without value uses default option",
            "executeQuery": "SELECT category FROM products WHERE name = 'Product A'",
            "expected": {
              "category": "option_1"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-SELECT-DEFAULT-002",
      "given": "single-select field without default specified",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL inserts NULL",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), priority VARCHAR(50))",
            "INSERT INTO tasks (title) VALUES ('Task A')"
          ],
          "fieldConfig": {
            "name": "priority",
            "type": "single-select",
            "options": [
              {
                "id": "low",
                "value": "Low"
              },
              {
                "id": "medium",
                "value": "Medium"
              },
              {
                "id": "high",
                "value": "High"
              }
            ]
          }
        },
        "assertions": [
          {
            "description": "Column has no DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='tasks' AND column_name='priority'",
            "expected": {
              "column_default": null
            }
          },
          {
            "description": "INSERT without value results in NULL",
            "executeQuery": "SELECT priority FROM tasks WHERE title = 'Task A'",
            "expected": {
              "priority": null
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-SELECT-DEFAULT-003",
      "given": "single-select field with default and explicit value",
      "when": "INSERT with specific option",
      "then": "PostgreSQL uses explicit value, ignoring default",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE tickets (id SERIAL PRIMARY KEY, title VARCHAR(255), status VARCHAR(50) DEFAULT 'open')",
            "INSERT INTO tickets (title, status) VALUES ('Bug Report', 'closed')"
          ],
          "fieldConfig": {
            "name": "status",
            "type": "single-select",
            "options": [
              {
                "id": "open",
                "value": "Open"
              },
              {
                "id": "closed",
                "value": "Closed"
              },
              {
                "id": "pending",
                "value": "Pending"
              }
            ],
            "default": "open"
          }
        },
        "assertions": [
          {
            "description": "Explicit value overrides default",
            "executeQuery": "SELECT status FROM tickets WHERE title = 'Bug Report'",
            "expected": {
              "status": "closed"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-SELECT-OPTIONS-001",
      "given": "single-select field with options: ['Low', 'Medium', 'High']",
      "when": "field migration creates CHECK constraint enforcing allowed values",
      "then": "PostgreSQL accepts only values from options array",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), priority VARCHAR(50) CHECK (priority IN ('Low', 'Medium', 'High')))",
            "INSERT INTO tasks (title, priority) VALUES ('Task 1', 'Low'), ('Task 2', 'High')"
          ],
          "fieldConfig": {
            "name": "priority",
            "type": "single-select",
            "options": ["Low", "Medium", "High"]
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces allowed values",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%priority%'",
            "expected": {
              "check_clause": "(priority IN ('Low', 'Medium', 'High'))"
            }
          },
          {
            "description": "Valid option 'Low' accepted",
            "executeQuery": "SELECT priority FROM tasks WHERE priority = 'Low'",
            "expected": {
              "priority": "Low"
            }
          },
          {
            "description": "Invalid option rejected",
            "executeQuery": "INSERT INTO tasks (title, priority) VALUES ('Task 3', 'Urgent')",
            "expectError": "violates check constraint"
          },
          {
            "description": "All valid options accepted",
            "executeQuery": "INSERT INTO tasks (title, priority) VALUES ('Task 4', 'Medium') RETURNING priority",
            "expected": {
              "priority": "Medium"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-SELECT-OPTIONS-002",
      "given": "single-select field with options: ['Active', 'Inactive']",
      "when": "NULL value inserted",
      "then": "PostgreSQL accepts NULL (if nullable) or rejects (if required)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255), status VARCHAR(50) CHECK (status IN ('Active', 'Inactive') OR status IS NULL))",
            "INSERT INTO users (name, status) VALUES ('Alice', 'Active'), ('Bob', NULL)"
          ],
          "fieldConfig": {
            "name": "status",
            "type": "single-select",
            "options": ["Active", "Inactive"],
            "required": false
          }
        },
        "assertions": [
          {
            "description": "NULL accepted when field is nullable",
            "executeQuery": "SELECT status FROM users WHERE name = 'Bob'",
            "expected": {
              "status": null
            }
          },
          {
            "description": "Valid option 'Active' accepted",
            "executeQuery": "SELECT status FROM users WHERE name = 'Alice'",
            "expected": {
              "status": "Active"
            }
          },
          {
            "description": "Invalid option still rejected",
            "executeQuery": "INSERT INTO users (name, status) VALUES ('Charlie', 'Pending')",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-SELECT-OPTIONS-003",
      "given": "single-select field with empty options array",
      "when": "field configuration validation runs",
      "then": "error should enforce minimum 1 option required",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "category",
            "type": "single-select",
            "options": []
          }
        },
        "assertions": [
          {
            "description": "Configuration with empty options array rejected",
            "validateConfig": true,
            "expectError": "options array must have at least 1 item"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-SELECT-OPTIONS-004",
      "given": "single-select field with options: ['Draft', 'Published', 'Archived']",
      "when": "option value modified in configuration",
      "then": "PostgreSQL ALTER TABLE updates CHECK constraint with new options",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE posts (id SERIAL PRIMARY KEY, title VARCHAR(255), status VARCHAR(50) CHECK (status IN ('Draft', 'Published', 'Archived')))",
            "INSERT INTO posts (title, status) VALUES ('Post 1', 'Draft'), ('Post 2', 'Published')"
          ],
          "fieldConfig": {
            "name": "status",
            "type": "single-select",
            "options": ["Draft", "Published", "Archived"]
          }
        },
        "assertions": [
          {
            "description": "Original CHECK constraint enforces original options",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%status%'",
            "expected": {
              "check_clause": "(status IN ('Draft', 'Published', 'Archived'))"
            }
          },
          {
            "description": "After migration: new option 'Scheduled' allowed",
            "executeQuery": [
              "ALTER TABLE posts DROP CONSTRAINT IF EXISTS posts_status_check",
              "ALTER TABLE posts ADD CONSTRAINT posts_status_check CHECK (status IN ('Draft', 'Scheduled', 'Published', 'Archived'))",
              "INSERT INTO posts (title, status) VALUES ('Post 3', 'Scheduled') RETURNING status"
            ],
            "expected": {
              "status": "Scheduled"
            }
          },
          {
            "description": "Existing data preserved after constraint update",
            "executeQuery": "SELECT COUNT(*) as count FROM posts WHERE status IN ('Draft', 'Published')",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    }
  ]
}
