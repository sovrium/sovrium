{
  "$id": "currency-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Currency Field",
  "description": "Monetary value field with currency code (USD, EUR, GBP, etc.). Stores numeric value with 2 decimal places for cents/pence. Currency code determines display format and symbol ($, €, £). Supports min/max constraints for range validation. Required flag makes the field mandatory. Indexing enables efficient sorting by monetary value.",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "unique": {
      "$ref": "../common/unique/unique.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "const": "currency"
    },
    "min": {
      "$ref": "./min/min.schema.json"
    },
    "max": {
      "$ref": "./max/max.schema.json"
    },
    "default": {
      "$ref": "./default/default.schema.json"
    },
    "currency": {
      "$ref": "./currency/currency.schema.json"
    }
  },
  "required": [
    "id",
    "name",
    "type"
  ],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-CURRENCY-FIELD-001",
      "given": "table configuration with currency field 'price' (currency=USD)",
      "when": "field migration creates column",
      "then": "PostgreSQL NUMERIC(10, 2) column is created for monetary value",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE products (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "price",
            "type": "currency",
            "currency": "USD"
          }
        },
        "assertions": [
          {
            "description": "Column created as NUMERIC(10, 2) for currency",
            "executeQuery": "SELECT column_name, data_type, numeric_precision, numeric_scale FROM information_schema.columns WHERE table_name='products' AND column_name='price'",
            "expected": {
              "column_name": "price",
              "data_type": "numeric",
              "numeric_precision": 10,
              "numeric_scale": 2
            }
          },
          {
            "description": "Currency value with 2 decimals can be inserted",
            "executeQuery": "INSERT INTO products (price) VALUES (99.99) RETURNING price",
            "expected": {
              "price": "99.99"
            }
          },
          {
            "description": "Value rounded to 2 decimal places",
            "executeQuery": "INSERT INTO products (price) VALUES (19.995) RETURNING price",
            "expected": {
              "price": "20.00"
            }
          }
        ]
      }
    },
    {
      "id": "APP-CURRENCY-FIELD-002",
      "given": "table 'invoices' with currency field 'total' (min=0.01, max=999999.99)",
      "when": "CHECK constraint enforces positive monetary values",
      "then": "PostgreSQL rejects negative amounts and values outside range",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE invoices (id SERIAL PRIMARY KEY, total NUMERIC(10, 2) CHECK (total >= 0.01 AND total <= 999999.99))"
        },
        "assertions": [
          {
            "description": "CHECK constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%total%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Valid currency amount succeeds",
            "executeQuery": "INSERT INTO invoices (total) VALUES (1234.56) RETURNING total",
            "expected": {
              "total": "1234.56"
            }
          },
          {
            "description": "Negative amount rejected",
            "executeQuery": "INSERT INTO invoices (total) VALUES (-10.00)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Amount above max rejected",
            "executeQuery": "INSERT INTO invoices (total) VALUES (1000000.00)",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-CURRENCY-FIELD-003",
      "given": "table 'transactions' with currency field 'amount' (required, unique)",
      "when": "constraints are applied",
      "then": "PostgreSQL enforces NOT NULL and UNIQUE constraints",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE transactions (id SERIAL PRIMARY KEY, amount NUMERIC(10, 2) UNIQUE NOT NULL)",
            "INSERT INTO transactions (amount) VALUES (500.00)"
          ]
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='transactions' AND column_name='amount'",
            "expected": {
              "is_nullable": "NO"
            }
          },
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='transactions' AND constraint_type='UNIQUE' AND constraint_name LIKE '%amount%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Duplicate amount rejected",
            "executeQuery": "INSERT INTO transactions (amount) VALUES (500.00)",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "NULL insertion fails",
            "executeQuery": "INSERT INTO transactions (amount) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-CURRENCY-FIELD-004",
      "given": "table 'items' with currency field 'cost' and default value 0.00",
      "when": "row inserted without providing cost value",
      "then": "PostgreSQL applies DEFAULT value 0.00",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE items (id SERIAL PRIMARY KEY, cost NUMERIC(10, 2) DEFAULT 0.00)",
          "fieldConfig": {
            "id": 1,
            "name": "cost",
            "type": "currency",
            "default": 0
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT value",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='items' AND column_name='cost'",
            "expected": {
              "column_default": "0.00"
            }
          },
          {
            "description": "INSERT without cost uses default",
            "executeQuery": "INSERT INTO items (id) VALUES (DEFAULT) RETURNING cost",
            "expected": {
              "cost": "0.00"
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO items (cost) VALUES (25.99) RETURNING cost",
            "expected": {
              "cost": "25.99"
            }
          }
        ]
      }
    },
    {
      "id": "APP-CURRENCY-FIELD-005",
      "given": "table configuration with currency field 'sale_price', indexed=true",
      "when": "index is created on the currency field",
      "then": "PostgreSQL btree index exists for fast monetary value queries",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE sales (id SERIAL PRIMARY KEY, sale_price NUMERIC(10, 2) NOT NULL)",
            "CREATE INDEX idx_sales_price ON sales(sale_price)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "sale_price",
            "type": "currency",
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_sales_price'",
            "expected": {
              "indexname": "idx_sales_price",
              "tablename": "sales"
            }
          },
          {
            "description": "Index uses btree for range queries and sorting",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_sales_price'",
            "expected": {
              "indexdef": "CREATE INDEX idx_sales_price ON public.sales USING btree (sale_price)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-001",
      "given": "user provides currency",
      "when": "validating input",
      "then": "string value should be accepted",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "example_field",
            "type": "text"
          }
        },
        "assertions": [
          {
            "description": "string value should be accepted",
            "validateConfig": true,
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-002",
      "given": "currency is empty string",
      "when": "validating input",
      "then": "default to USD",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "example_field",
            "type": "text"
          }
        },
        "assertions": [
          {
            "description": "default to USD",
            "validateConfig": true,
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-DEFAULT-001",
      "given": "currency field with default: 0.00",
      "when": "field migration creates column with DEFAULT constraint",
      "then": "PostgreSQL automatically sets value to 0.00 when not provided",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE accounts (id SERIAL PRIMARY KEY, name VARCHAR(255), balance DECIMAL(15,2) DEFAULT 0.00)",
            "INSERT INTO accounts (name) VALUES ('Account 1'), ('Account 2')"
          ],
          "fieldConfig": {
            "name": "balance",
            "type": "currency",
            "default": 0
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='accounts' AND column_name='balance'",
            "expected": {
              "column_default": "0.00"
            }
          },
          {
            "description": "Default value applied when not provided",
            "executeQuery": "SELECT balance FROM accounts WHERE name = 'Account 1'",
            "expected": {
              "balance": 0
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO accounts (name, balance) VALUES ('Account 3', 1500.50) RETURNING balance",
            "expected": {
              "balance": 1500.5
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-DEFAULT-002",
      "given": "currency field with default: 49.99 (subscription price)",
      "when": "INSERT without value",
      "then": "PostgreSQL uses default value 49.99",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE subscriptions (id SERIAL PRIMARY KEY, plan_name VARCHAR(255), price DECIMAL(10,2) DEFAULT 49.99)",
            "INSERT INTO subscriptions (plan_name) VALUES ('Basic Plan')"
          ],
          "fieldConfig": {
            "name": "price",
            "type": "currency",
            "default": 49.99
          }
        },
        "assertions": [
          {
            "description": "Default value is 49.99",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='subscriptions' AND column_name='price'",
            "expected": {
              "column_default": "49.99"
            }
          },
          {
            "description": "Default applied to inserted record",
            "executeQuery": "SELECT price FROM subscriptions WHERE plan_name = 'Basic Plan'",
            "expected": {
              "price": 49.99
            }
          },
          {
            "description": "Explicit 0.00 allowed (overrides default)",
            "executeQuery": "INSERT INTO subscriptions (plan_name, price) VALUES ('Free Plan', 0.00) RETURNING price",
            "expected": {
              "price": 0
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-DEFAULT-003",
      "given": "currency field with no default specified",
      "when": "INSERT without value",
      "then": "PostgreSQL uses NULL (if nullable) or rejects (if required)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE payments (id SERIAL PRIMARY KEY, amount DECIMAL(15,2))",
            "INSERT INTO payments (id) VALUES (1)"
          ],
          "fieldConfig": {
            "name": "amount",
            "type": "currency"
          }
        },
        "assertions": [
          {
            "description": "No DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='payments' AND column_name='amount'",
            "expected": {
              "column_default": null
            }
          },
          {
            "description": "NULL used when no default and no value",
            "executeQuery": "SELECT amount FROM payments WHERE id = 1",
            "expected": {
              "amount": null
            }
          },
          {
            "description": "Explicit value succeeds",
            "executeQuery": "INSERT INTO payments (amount) VALUES (275.00) RETURNING amount",
            "expected": {
              "amount": 275
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-MAX-001",
      "given": "currency field with max: 10000.00 (spending limit)",
      "when": "field migration creates CHECK constraint",
      "then": "PostgreSQL rejects currency values above maximum",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE expenses (id SERIAL PRIMARY KEY, amount DECIMAL(15,2) CHECK (amount <= 10000.00))",
            "INSERT INTO expenses (amount) VALUES (500.00), (10000.00), (7500.50)"
          ],
          "fieldConfig": {
            "name": "amount",
            "type": "currency",
            "max": 10000
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint exists for max value",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%amount%' AND check_clause LIKE '%<= 10000.00%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Value at maximum (10000.00) accepted",
            "executeQuery": "SELECT amount FROM expenses WHERE amount = 10000.00",
            "expected": {
              "amount": 10000
            }
          },
          {
            "description": "Value above maximum rejected",
            "executeQuery": "INSERT INTO expenses (amount) VALUES (10000.01)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Value below maximum accepted",
            "executeQuery": "INSERT INTO expenses (amount) VALUES (2500.00) RETURNING amount",
            "expected": {
              "amount": 2500
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-MAX-002",
      "given": "currency field with max: 999999.99 (invoice limit)",
      "when": "INSERT with value above max",
      "then": "PostgreSQL CHECK constraint rejects value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE invoices (id SERIAL PRIMARY KEY, total DECIMAL(15,2) CHECK (total <= 999999.99))",
            "INSERT INTO invoices (total) VALUES (50000.00), (999999.99)"
          ],
          "fieldConfig": {
            "name": "total",
            "type": "currency",
            "max": 999999.99
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces max 999999.99",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%total%'",
            "expected": {
              "check_clause": "(total <= 999999.99)"
            }
          },
          {
            "description": "Exact maximum (999999.99) accepted",
            "executeQuery": "SELECT total FROM invoices WHERE total = 999999.99",
            "expected": {
              "total": 999999.99
            }
          },
          {
            "description": "Above maximum rejected",
            "executeQuery": "INSERT INTO invoices (total) VALUES (1000000.00)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Below maximum accepted",
            "executeQuery": "INSERT INTO invoices (total) VALUES (125000.00) RETURNING total",
            "expected": {
              "total": 125000
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-MAX-003",
      "given": "currency field with both min and max (price range)",
      "when": "CHECK constraint combines both",
      "then": "PostgreSQL enforces currency value within range",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, price DECIMAL(15,2) CHECK (price >= 0.01 AND price <= 99999.99))",
            "INSERT INTO products (price) VALUES (0.01), (5000.00), (99999.99)"
          ],
          "fieldConfig": {
            "name": "price",
            "type": "currency",
            "min": 0.01,
            "max": 99999.99
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces range 0.01-99999.99",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%price%'",
            "expected": {
              "check_clause": "((price >= 0.01) AND (price <= 99999.99))"
            }
          },
          {
            "description": "Value at min (0.01) accepted",
            "executeQuery": "SELECT price FROM products WHERE price = 0.01",
            "expected": {
              "price": 0.01
            }
          },
          {
            "description": "Value at max (99999.99) accepted",
            "executeQuery": "SELECT price FROM products WHERE price = 99999.99",
            "expected": {
              "price": 99999.99
            }
          },
          {
            "description": "Value below min rejected",
            "executeQuery": "INSERT INTO products (price) VALUES (0.00)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Value above max rejected",
            "executeQuery": "INSERT INTO products (price) VALUES (100000.00)",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-MIN-001",
      "given": "currency field with min: 0.00 (no negative prices)",
      "when": "field migration creates CHECK constraint",
      "then": "PostgreSQL rejects currency values below minimum",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, price DECIMAL(15,2) CHECK (price >= 0.00))",
            "INSERT INTO products (price) VALUES (0.00), (9.99), (1250.00)"
          ],
          "fieldConfig": {
            "name": "price",
            "type": "currency",
            "min": 0
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint exists for min value",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%price%' AND check_clause LIKE '%>= 0.00%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Zero price accepted",
            "executeQuery": "SELECT price FROM products WHERE price = 0.00",
            "expected": {
              "price": 0
            }
          },
          {
            "description": "Negative price rejected",
            "executeQuery": "INSERT INTO products (price) VALUES (-5.00)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Positive price accepted",
            "executeQuery": "INSERT INTO products (price) VALUES (29.99) RETURNING price",
            "expected": {
              "price": 29.99
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-MIN-002",
      "given": "currency field with min: 1.00 (minimum purchase)",
      "when": "INSERT with value below min",
      "then": "PostgreSQL CHECK constraint rejects value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, total DECIMAL(15,2) CHECK (total >= 1.00))",
            "INSERT INTO orders (total) VALUES (1.00), (50.00)"
          ],
          "fieldConfig": {
            "name": "total",
            "type": "currency",
            "min": 1
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces min 1.00",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%total%'",
            "expected": {
              "check_clause": "(total >= 1.00)"
            }
          },
          {
            "description": "Exact minimum (1.00) accepted",
            "executeQuery": "SELECT total FROM orders WHERE total = 1.00",
            "expected": {
              "total": 1
            }
          },
          {
            "description": "Below minimum rejected",
            "executeQuery": "INSERT INTO orders (total) VALUES (0.99)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Above minimum accepted",
            "executeQuery": "INSERT INTO orders (total) VALUES (125.50) RETURNING total",
            "expected": {
              "total": 125.5
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-CURRENCY-MIN-003",
      "given": "currency field with no min specified",
      "when": "negative values inserted (refunds, credits)",
      "then": "PostgreSQL accepts all DECIMAL range values",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE transactions (id SERIAL PRIMARY KEY, amount DECIMAL(15,2))",
            "INSERT INTO transactions (amount) VALUES (-100.00), (0.00), (500.00)"
          ],
          "fieldConfig": {
            "name": "amount",
            "type": "currency"
          }
        },
        "assertions": [
          {
            "description": "No CHECK constraint for min",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%amount%'",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Negative amounts accepted (refunds)",
            "executeQuery": "SELECT amount FROM transactions WHERE amount = -100.00",
            "expected": {
              "amount": -100
            }
          },
          {
            "description": "Large refund accepted",
            "executeQuery": "INSERT INTO transactions (amount) VALUES (-5000.00) RETURNING amount",
            "expected": {
              "amount": -5000
            }
          }
        ]
      }
    }
  ]
}
