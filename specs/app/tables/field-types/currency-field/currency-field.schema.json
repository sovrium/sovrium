{
  "$id": "currency-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Currency Field",
  "description": "Monetary value field with currency code (USD, EUR, GBP, etc.). Stores numeric value with 2 decimal places for cents/pence. Currency code determines display format and symbol ($, €, £). Supports min/max constraints for range validation. Required flag makes the field mandatory. Indexing enables efficient sorting by monetary value.",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "unique": {
      "$ref": "../common/unique/unique.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "const": "currency"
    },
    "min": {
      "$ref": "./min/min.schema.json"
    },
    "max": {
      "$ref": "./max/max.schema.json"
    },
    "default": {
      "$ref": "./default/default.schema.json"
    },
    "currency": {
      "$ref": "./currency/currency.schema.json"
    }
  },
  "required": ["id", "name", "type"],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-CURRENCY-FIELD-001",
      "given": "table configuration with currency field 'price' (currency=USD)",
      "when": "field migration creates column",
      "then": "PostgreSQL NUMERIC(10, 2) column is created for monetary value",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE products (id SERIAL PRIMARY KEY)",
          "fieldConfig": { "id": 1, "name": "price", "type": "currency", "currency": "USD" }
        },
        "assertions": [
          {
            "description": "Column created as NUMERIC(10, 2) for currency",
            "executeQuery": "SELECT column_name, data_type, numeric_precision, numeric_scale FROM information_schema.columns WHERE table_name='products' AND column_name='price'",
            "expected": {
              "column_name": "price",
              "data_type": "numeric",
              "numeric_precision": 10,
              "numeric_scale": 2
            }
          },
          {
            "description": "Currency value with 2 decimals can be inserted",
            "executeQuery": "INSERT INTO products (price) VALUES (99.99) RETURNING price",
            "expected": { "price": "99.99" }
          },
          {
            "description": "Value rounded to 2 decimal places",
            "executeQuery": "INSERT INTO products (price) VALUES (19.995) RETURNING price",
            "expected": { "price": "20.00" }
          }
        ]
      }
    },
    {
      "id": "APP-CURRENCY-FIELD-002",
      "given": "table 'invoices' with currency field 'total' (min=0.01, max=999999.99)",
      "when": "CHECK constraint enforces positive monetary values",
      "then": "PostgreSQL rejects negative amounts and values outside range",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE invoices (id SERIAL PRIMARY KEY, total NUMERIC(10, 2) CHECK (total >= 0.01 AND total <= 999999.99))"
        },
        "assertions": [
          {
            "description": "CHECK constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%total%'",
            "expected": { "count": 1 }
          },
          {
            "description": "Valid currency amount succeeds",
            "executeQuery": "INSERT INTO invoices (total) VALUES (1234.56) RETURNING total",
            "expected": { "total": "1234.56" }
          },
          {
            "description": "Negative amount rejected",
            "executeQuery": "INSERT INTO invoices (total) VALUES (-10.00)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Amount above max rejected",
            "executeQuery": "INSERT INTO invoices (total) VALUES (1000000.00)",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-CURRENCY-FIELD-003",
      "given": "table 'transactions' with currency field 'amount' (required, unique)",
      "when": "constraints are applied",
      "then": "PostgreSQL enforces NOT NULL and UNIQUE constraints",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE transactions (id SERIAL PRIMARY KEY, amount NUMERIC(10, 2) UNIQUE NOT NULL)",
            "INSERT INTO transactions (amount) VALUES (500.00)"
          ]
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='transactions' AND column_name='amount'",
            "expected": { "is_nullable": "NO" }
          },
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='transactions' AND constraint_type='UNIQUE' AND constraint_name LIKE '%amount%'",
            "expected": { "count": 1 }
          },
          {
            "description": "Duplicate amount rejected",
            "executeQuery": "INSERT INTO transactions (amount) VALUES (500.00)",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "NULL insertion fails",
            "executeQuery": "INSERT INTO transactions (amount) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-CURRENCY-FIELD-004",
      "given": "table 'items' with currency field 'cost' and default value 0.00",
      "when": "row inserted without providing cost value",
      "then": "PostgreSQL applies DEFAULT value 0.00",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE items (id SERIAL PRIMARY KEY, cost NUMERIC(10, 2) DEFAULT 0.00)",
          "fieldConfig": {
            "id": 1,
            "name": "cost",
            "type": "currency",
            "default": 0.0
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT value",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='items' AND column_name='cost'",
            "expected": { "column_default": "0.00" }
          },
          {
            "description": "INSERT without cost uses default",
            "executeQuery": "INSERT INTO items (id) VALUES (DEFAULT) RETURNING cost",
            "expected": { "cost": "0.00" }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO items (cost) VALUES (25.99) RETURNING cost",
            "expected": { "cost": "25.99" }
          }
        ]
      }
    },
    {
      "id": "APP-CURRENCY-FIELD-005",
      "given": "table configuration with currency field 'sale_price', indexed=true",
      "when": "index is created on the currency field",
      "then": "PostgreSQL btree index exists for fast monetary value queries",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE sales (id SERIAL PRIMARY KEY, sale_price NUMERIC(10, 2) NOT NULL)",
            "CREATE INDEX idx_sales_price ON sales(sale_price)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "sale_price",
            "type": "currency",
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_sales_price'",
            "expected": { "indexname": "idx_sales_price", "tablename": "sales" }
          },
          {
            "description": "Index uses btree for range queries and sorting",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_sales_price'",
            "expected": {
              "indexdef": "CREATE INDEX idx_sales_price ON public.sales USING btree (sale_price)"
            }
          }
        ]
      }
    }
  ]
}
