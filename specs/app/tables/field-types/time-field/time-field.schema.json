{
  "$id": "time-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Time Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "unique": {
      "$ref": "../common/unique/unique.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "type": "string",
      "const": "time",
      "description": "Field type discriminator for time-only fields without date component",
      "examples": ["time"]
    },
    "format": {
      "$ref": "./format/format.schema.json"
    },
    "default": {
      "$ref": "./default/default.schema.json"
    }
  },
  "description": "Time field for clock times only (no date component). Stores values in ISO 8601 time format (HH:mm:ss or HH:mm:ss.sss). Supports custom display formats (HH:mm, hh:mm A, HH:mm:ss) and optional default values. Useful for tracking business hours, appointment slots, recurring schedules, and any time-based data without date context.",
  "examples": [
    {
      "id": "fld_005",
      "name": "store_opening_time",
      "type": "time",
      "required": true,
      "format": "hh:mm A"
    },
    {
      "id": "fld_006",
      "name": "appointment_duration",
      "type": "time",
      "required": false,
      "format": "HH:mm:ss",
      "default": "00:30:00"
    }
  ],
  "required": ["id", "name", "type"],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-FIELD-TIME-001",
      "given": "table configuration with time field 'opening_time'",
      "when": "field migration creates column",
      "then": "PostgreSQL TIME column is created for clock times",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE stores (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "opening_time",
            "type": "time"
          }
        },
        "assertions": [
          {
            "description": "Column created as TIME type",
            "executeQuery": "SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name='stores' AND column_name='opening_time'",
            "expected": {
              "column_name": "opening_time",
              "data_type": "time without time zone",
              "is_nullable": "YES"
            }
          },
          {
            "description": "Valid time can be inserted",
            "executeQuery": "INSERT INTO stores (opening_time) VALUES ('09:00:00') RETURNING opening_time",
            "expected": {
              "opening_time": "09:00:00"
            }
          },
          {
            "description": "24-hour format supported",
            "executeQuery": "INSERT INTO stores (opening_time) VALUES ('14:30:45') RETURNING opening_time",
            "expected": {
              "opening_time": "14:30:45"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-002",
      "given": "table 'appointments' with time field 'slot_time'",
      "when": "time range queries are performed",
      "then": "PostgreSQL TIME type supports comparison and ordering",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE appointments (id SERIAL PRIMARY KEY, slot_time TIME)",
            "INSERT INTO appointments (slot_time) VALUES ('08:00:00'), ('12:30:00'), ('17:45:00')"
          ]
        },
        "assertions": [
          {
            "description": "Find times after specific time",
            "executeQuery": "SELECT COUNT(*) as count FROM appointments WHERE slot_time > '12:00:00'",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Find times between range",
            "executeQuery": "SELECT COUNT(*) as count FROM appointments WHERE slot_time BETWEEN '08:00:00' AND '13:00:00'",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Order by time ascending",
            "executeQuery": "SELECT slot_time::TEXT FROM appointments ORDER BY slot_time ASC LIMIT 1",
            "expected": {
              "slot_time": "08:00:00"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-003",
      "given": "table 'schedules' with time field 'start_time' (required, unique)",
      "when": "constraints are applied",
      "then": "PostgreSQL enforces NOT NULL and UNIQUE constraints",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE schedules (id SERIAL PRIMARY KEY, start_time TIME UNIQUE NOT NULL)",
            "INSERT INTO schedules (start_time) VALUES ('10:00:00')"
          ]
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='schedules' AND column_name='start_time'",
            "expected": {
              "is_nullable": "NO"
            }
          },
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='schedules' AND constraint_type='UNIQUE' AND constraint_name LIKE '%start_time%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Duplicate time rejected",
            "executeQuery": "INSERT INTO schedules (start_time) VALUES ('10:00:00')",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "NULL time insertion fails",
            "executeQuery": "INSERT INTO schedules (start_time) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-004",
      "given": "table 'meetings' with time field 'default_time' and default value '09:00:00'",
      "when": "row inserted without providing default_time value",
      "then": "PostgreSQL applies DEFAULT value '09:00:00'",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE meetings (id SERIAL PRIMARY KEY, default_time TIME DEFAULT '09:00:00')",
          "fieldConfig": {
            "id": 1,
            "name": "default_time",
            "type": "time",
            "default": "09:00:00"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT value",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='meetings' AND column_name='default_time'",
            "expected": {
              "column_default": "'09:00:00'::time without time zone"
            }
          },
          {
            "description": "INSERT without default_time uses default",
            "executeQuery": "INSERT INTO meetings (id) VALUES (DEFAULT) RETURNING default_time",
            "expected": {
              "default_time": "09:00:00"
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO meetings (default_time) VALUES ('15:30:00') RETURNING default_time",
            "expected": {
              "default_time": "15:30:00"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-005",
      "given": "table configuration with time field 'shift_start', indexed=true",
      "when": "index is created on the time field",
      "then": "PostgreSQL btree index exists for fast time queries",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE shifts (id SERIAL PRIMARY KEY, shift_start TIME NOT NULL)",
            "CREATE INDEX idx_shifts_start ON shifts(shift_start)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "shift_start",
            "type": "time",
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_shifts_start'",
            "expected": {
              "indexname": "idx_shifts_start",
              "tablename": "shifts"
            }
          },
          {
            "description": "Index uses btree for time range queries",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_shifts_start'",
            "expected": {
              "indexdef": "CREATE INDEX idx_shifts_start ON public.shifts USING btree (shift_start)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-DEFAULT-001",
      "given": "time field with static default: '09:00:00'",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL DEFAULT constraint provides '09:00:00'",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE appointments (id SERIAL PRIMARY KEY, client VARCHAR(255), start_time TIME DEFAULT '09:00:00')",
            "INSERT INTO appointments (client) VALUES ('John Doe')"
          ],
          "fieldConfig": {
            "name": "start_time",
            "type": "time",
            "default": "09:00:00"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT constraint with time",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='appointments' AND column_name='start_time'",
            "expected": {
              "column_default": "'09:00:00'::time without time zone"
            }
          },
          {
            "description": "INSERT without value uses default time",
            "executeQuery": "SELECT start_time FROM appointments WHERE client = 'John Doe'",
            "expected": {
              "start_time": "09:00:00"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-DEFAULT-002",
      "given": "time field with dynamic default: 'now' (CURRENT_TIME)",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL DEFAULT CURRENT_TIME provides current time",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE check_ins (id SERIAL PRIMARY KEY, employee VARCHAR(255), check_in_time TIME DEFAULT CURRENT_TIME)",
            "INSERT INTO check_ins (employee) VALUES ('Alice')"
          ],
          "fieldConfig": {
            "name": "check_in_time",
            "type": "time",
            "default": "now"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT CURRENT_TIME constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='check_ins' AND column_name='check_in_time'",
            "expected": {
              "column_default": "CURRENT_TIME"
            }
          },
          {
            "description": "INSERT without value uses current time (dynamic)",
            "executeQuery": "SELECT check_in_time IS NOT NULL as has_time FROM check_ins WHERE employee = 'Alice'",
            "expected": {
              "has_time": true
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-DEFAULT-003",
      "given": "time field without default specified",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL inserts NULL",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE events (id SERIAL PRIMARY KEY, title VARCHAR(255), event_time TIME)",
            "INSERT INTO events (title) VALUES ('Meeting')"
          ],
          "fieldConfig": {
            "name": "event_time",
            "type": "time"
          }
        },
        "assertions": [
          {
            "description": "Column has no DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='events' AND column_name='event_time'",
            "expected": {
              "column_default": null
            }
          },
          {
            "description": "INSERT without value results in NULL",
            "executeQuery": "SELECT event_time FROM events WHERE title = 'Meeting'",
            "expected": {
              "event_time": null
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-FORMAT-001",
      "title": "Accept valid 12-hour format pattern",
      "given": "time field with format: 'hh:mm A' (12-hour with AM/PM)",
      "when": "field migration creates TIME column",
      "then": "PostgreSQL stores in 24-hour format, application displays using format pattern",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE meetings (id SERIAL PRIMARY KEY, title VARCHAR(255), start_time TIME)",
            "INSERT INTO meetings (title, start_time) VALUES ('Standup', '09:15:00'), ('Lunch', '14:30:00')"
          ],
          "fieldConfig": {
            "name": "start_time",
            "type": "time",
            "format": "hh:mm A"
          }
        },
        "assertions": [
          {
            "description": "Column uses TIME type (24-hour storage)",
            "executeQuery": "SELECT data_type FROM information_schema.columns WHERE table_name='meetings' AND column_name='start_time'",
            "expected": {
              "data_type": "time without time zone"
            }
          },
          {
            "description": "Time stored in 24-hour format (HH:mm:ss)",
            "executeQuery": "SELECT start_time FROM meetings WHERE title = 'Lunch'",
            "expected": {
              "start_time": "14:30:00"
            }
          },
          {
            "description": "Application transforms to 12-hour format (hh:mm A)",
            "displayFormat": "hh:mm A",
            "executeQuery": "SELECT start_time FROM meetings WHERE title = 'Lunch'",
            "expectedDisplay": "02:30 PM",
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-FORMAT-002",
      "title": "Use default 24-hour format when not specified",
      "given": "time field without format property",
      "when": "user views time value",
      "then": "time displayed in default 24-hour format (HH:mm)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE schedules (id SERIAL PRIMARY KEY, activity VARCHAR(255), time TIME DEFAULT '12:00:00')",
            "INSERT INTO schedules (activity, time) VALUES ('Training', '16:45:00')"
          ],
          "fieldConfig": {
            "name": "time",
            "type": "time"
          }
        },
        "assertions": [
          {
            "description": "Default format is HH:mm (24-hour without seconds)",
            "displayFormat": "HH:mm",
            "executeQuery": "SELECT time FROM schedules WHERE activity = 'Training'",
            "expectedDisplay": "16:45",
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-FORMAT-003",
      "title": "Reject invalid format pattern",
      "given": "time field with invalid format pattern",
      "when": "field configuration validation runs",
      "then": "validation error returned with message 'Invalid time format pattern'",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "arrival_time",
            "type": "time",
            "format": "INVALID-FORMAT"
          }
        },
        "assertions": [
          {
            "description": "Invalid format pattern rejected",
            "validateConfig": true,
            "expectError": "Invalid time format pattern. Valid tokens: HH, hh, mm, ss, SSS, A"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-FORMAT-004",
      "title": "Support format with seconds (HH:mm:ss)",
      "given": "time field with format: 'HH:mm:ss' (24-hour with seconds)",
      "when": "time '14:30:45' retrieved",
      "then": "application displays with seconds: '14:30:45'",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE logs (id SERIAL PRIMARY KEY, event VARCHAR(255), timestamp TIME)",
            "INSERT INTO logs (event, timestamp) VALUES ('System Start', '14:30:45')"
          ],
          "fieldConfig": {
            "name": "timestamp",
            "type": "time",
            "format": "HH:mm:ss"
          }
        },
        "assertions": [
          {
            "description": "Display includes seconds",
            "displayFormat": "HH:mm:ss",
            "executeQuery": "SELECT timestamp FROM logs WHERE event = 'System Start'",
            "expectedDisplay": "14:30:45",
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-TIME-FORMAT-005",
      "title": "Support format with milliseconds (HH:mm:ss.SSS)",
      "given": "time field with format: 'HH:mm:ss.SSS'",
      "when": "time '14:30:45.123' retrieved",
      "then": "application displays with milliseconds: '14:30:45.123'",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE performance_logs (id SERIAL PRIMARY KEY, operation VARCHAR(255), execution_time TIME(3))",
            "INSERT INTO performance_logs (operation, execution_time) VALUES ('API Call', '14:30:45.123')"
          ],
          "fieldConfig": {
            "name": "execution_time",
            "type": "time",
            "format": "HH:mm:ss.SSS"
          }
        },
        "assertions": [
          {
            "description": "Column stores milliseconds (TIME(3))",
            "executeQuery": "SELECT execution_time FROM performance_logs WHERE operation = 'API Call'",
            "expected": {
              "execution_time": "14:30:45.123"
            }
          },
          {
            "description": "Display includes milliseconds",
            "displayFormat": "HH:mm:ss.SSS",
            "executeQuery": "SELECT execution_time FROM performance_logs WHERE operation = 'API Call'",
            "expectedDisplay": "14:30:45.123",
            "expectError": "validation error"
          }
        ]
      }
    }
  ]
}
