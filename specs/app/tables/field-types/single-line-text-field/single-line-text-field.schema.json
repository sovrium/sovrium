{
  "$id": "single-line-text-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Single Line Text Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "unique": {
      "$ref": "../common/unique/unique.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "const": "single-line-text"
    },
    "default": {
      "$ref": "./default/default.schema.json"
    }
  },
  "description": "Short text input limited to a single line. Ideal for names, titles, labels, and brief identifiers. Text is stored as-is without formatting. Required flag makes the field mandatory. Unique constraint ensures no duplicate values across records. Indexing improves search and filter performance on this field.",
  "required": [
    "id",
    "name",
    "type"
  ],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-001",
      "given": "table configuration with single-line-text field 'title'",
      "when": "field migration creates column",
      "then": "PostgreSQL VARCHAR(255) column is created",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE products (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "title",
            "type": "single-line-text"
          }
        },
        "assertions": [
          {
            "description": "Column created as VARCHAR(255)",
            "executeQuery": "SELECT column_name, data_type, character_maximum_length, is_nullable FROM information_schema.columns WHERE table_name='products' AND column_name='title'",
            "expected": {
              "column_name": "title",
              "data_type": "character varying",
              "character_maximum_length": 255,
              "is_nullable": "YES"
            }
          },
          {
            "description": "Valid text can be inserted",
            "executeQuery": "INSERT INTO products (title) VALUES ('MacBook Pro 16-inch') RETURNING title",
            "expected": {
              "title": "MacBook Pro 16-inch"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-002",
      "given": "table 'users' with single-line-text field 'username' (required, unique), existing row username='john_doe'",
      "when": "attempt to insert duplicate username='john_doe'",
      "then": "PostgreSQL UNIQUE constraint rejects insertion",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, username VARCHAR(255) UNIQUE NOT NULL)",
            "INSERT INTO users (username) VALUES ('john_doe')"
          ]
        },
        "assertions": [
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='users' AND constraint_type='UNIQUE' AND constraint_name LIKE '%username%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Duplicate username rejected",
            "executeQuery": "INSERT INTO users (username) VALUES ('john_doe')",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "Database still contains only 1 row",
            "executeQuery": "SELECT COUNT(*) as count FROM users",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-003",
      "given": "table 'tasks' with required single-line-text field 'title'",
      "when": "attempt to insert NULL value for required title",
      "then": "PostgreSQL NOT NULL constraint rejects insertion",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255) NOT NULL)"
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='tasks' AND column_name='title'",
            "expected": {
              "is_nullable": "NO"
            }
          },
          {
            "description": "Valid title insertion succeeds",
            "executeQuery": "INSERT INTO tasks (title) VALUES ('Complete project') RETURNING title",
            "expected": {
              "title": "Complete project"
            }
          },
          {
            "description": "NULL title insertion fails",
            "executeQuery": "INSERT INTO tasks (title) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-SINGLE-LINE-TEXT-FIELD-004",
      "given": "table configuration with single-line-text field, indexed=true",
      "when": "index is created on the text field",
      "then": "PostgreSQL btree index exists for fast text lookups",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, sku VARCHAR(255) UNIQUE NOT NULL)",
            "CREATE INDEX idx_products_sku ON products(sku)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "sku",
            "type": "single-line-text",
            "unique": true,
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_products_sku'",
            "expected": {
              "indexname": "idx_products_sku",
              "tablename": "products"
            }
          },
          {
            "description": "Index uses btree for text searching",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_products_sku'",
            "expected": {
              "indexdef": "CREATE INDEX idx_products_sku ON public.products USING btree (sku)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-SINGLE-LINE-TEXT-FIELD-005",
      "given": "table with single-line-text field 'name' and default value 'Untitled'",
      "when": "row inserted without providing name value",
      "then": "PostgreSQL applies DEFAULT value 'Untitled'",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE documents (id SERIAL PRIMARY KEY, name VARCHAR(255) DEFAULT 'Untitled')",
          "fieldConfig": {
            "id": 1,
            "name": "name",
            "type": "single-line-text",
            "default": "Untitled"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT value",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='documents' AND column_name='name'",
            "expected": {
              "column_default": "'Untitled'::character varying"
            }
          },
          {
            "description": "INSERT without name uses default",
            "executeQuery": "INSERT INTO documents (id) VALUES (DEFAULT) RETURNING name",
            "expected": {
              "name": "Untitled"
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO documents (name) VALUES ('My Document') RETURNING name",
            "expected": {
              "name": "My Document"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-006",
      "given": "table with single-line-text field accepting unicode characters",
      "when": "text with emojis, international characters, and symbols is inserted",
      "then": "PostgreSQL stores and retrieves unicode text correctly",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE posts (id SERIAL PRIMARY KEY, content VARCHAR(255))"
        },
        "assertions": [
          {
            "description": "Emoji characters stored correctly",
            "executeQuery": "INSERT INTO posts (content) VALUES ('Hello ðŸ‘‹ World ðŸŒ') RETURNING content",
            "expected": {
              "content": "Hello ðŸ‘‹ World ðŸŒ"
            }
          },
          {
            "description": "International characters stored correctly",
            "executeQuery": "INSERT INTO posts (content) VALUES ('ÐŸÑ€Ð¸Ð²ÐµÑ‚ Ð¼Ð¸Ñ€ ä½ å¥½ä¸–ç•Œ Ù…Ø±Ø­Ø¨Ø§ Ø§Ù„Ø¹Ø§Ù„Ù…') RETURNING content",
            "expected": {
              "content": "ÐŸÑ€Ð¸Ð²ÐµÑ‚ Ð¼Ð¸Ñ€ ä½ å¥½ä¸–ç•Œ Ù…Ø±Ø­Ø¨Ø§ Ø§Ù„Ø¹Ø§Ù„Ù…"
            }
          },
          {
            "description": "Special symbols stored correctly",
            "executeQuery": "INSERT INTO posts (content) VALUES ('Price: â‚¬100 Â¥500 Â£50 Â©2024') RETURNING content",
            "expected": {
              "content": "Price: â‚¬100 Â¥500 Â£50 Â©2024"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-007",
      "given": "table with single-line-text field with VARCHAR(255) limit",
      "when": "text exceeding 255 characters is inserted",
      "then": "PostgreSQL rejects or truncates the text",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE notes (id SERIAL PRIMARY KEY, short_note VARCHAR(255))"
        },
        "assertions": [
          {
            "description": "Text at limit (255 chars) accepted",
            "executeQuery": "INSERT INTO notes (short_note) VALUES (REPEAT('a', 255)) RETURNING LENGTH(short_note) as len",
            "expected": {
              "len": 255
            }
          },
          {
            "description": "Text exceeding limit (300 chars) rejected",
            "executeQuery": "INSERT INTO notes (short_note) VALUES (REPEAT('b', 300))",
            "expectError": "value too long for type character varying(255)"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-008",
      "given": "table with single-line-text field handling special characters",
      "when": "text with quotes, backslashes, and SQL special characters is inserted",
      "then": "PostgreSQL safely escapes and stores the text without SQL injection",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE messages (id SERIAL PRIMARY KEY, message VARCHAR(255))"
        },
        "assertions": [
          {
            "description": "Single quotes escaped correctly",
            "executeQuery": "INSERT INTO messages (message) VALUES ('O''Brien''s message') RETURNING message",
            "expected": {
              "message": "O'Brien's message"
            }
          },
          {
            "description": "Backslashes stored correctly",
            "executeQuery": "INSERT INTO messages (message) VALUES ('Path: C:\\Users\\Documents\\file.txt') RETURNING message",
            "expected": {
              "message": "Path: C:\\Users\\Documents\\file.txt"
            }
          },
          {
            "description": "SQL injection attempt safely escaped",
            "executeQuery": "INSERT INTO messages (message) VALUES (''; DROP TABLE messages; --') RETURNING message",
            "expected": {
              "message": "'; DROP TABLE messages; --"
            }
          },
          {
            "description": "Table still exists after SQL injection attempt",
            "executeQuery": "SELECT COUNT(*) as count FROM messages",
            "expected": {
              "count": 3
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-009",
      "given": "table with single-line-text field and 1000 records",
      "when": "bulk insert of 1000 records is performed",
      "then": "PostgreSQL handles bulk insert efficiently without errors",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE products (id SERIAL PRIMARY KEY, sku VARCHAR(255))"
        },
        "assertions": [
          {
            "description": "Bulk insert 1000 records successfully",
            "executeQuery": "INSERT INTO products (sku) SELECT 'SKU-' || generate_series(1, 1000) RETURNING COUNT(*) OVER() as total",
            "expected": {
              "total": 1000
            }
          },
          {
            "description": "All records inserted correctly",
            "executeQuery": "SELECT COUNT(*) as count FROM products",
            "expected": {
              "count": 1000
            }
          },
          {
            "description": "Sample records have correct format",
            "executeQuery": "SELECT sku FROM products WHERE id IN (1, 500, 1000) ORDER BY id",
            "expected": [
              {
                "sku": "SKU-1"
              },
              {
                "sku": "SKU-500"
              },
              {
                "sku": "SKU-1000"
              }
            ]
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-010",
      "given": "table with indexed single-line-text field and 10000 records",
      "when": "query searches for specific text value",
      "then": "PostgreSQL uses btree index for fast lookup",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE inventory (id SERIAL PRIMARY KEY, product_code VARCHAR(255))",
            "CREATE INDEX idx_product_code ON inventory(product_code)",
            "INSERT INTO inventory (product_code) SELECT 'PROD-' || generate_series(1, 10000)"
          ]
        },
        "assertions": [
          {
            "description": "Index exists on product_code",
            "executeQuery": "SELECT indexname FROM pg_indexes WHERE tablename='inventory' AND indexname='idx_product_code'",
            "expected": {
              "indexname": "idx_product_code"
            }
          },
          {
            "description": "Query finds specific record efficiently",
            "executeQuery": "SELECT product_code FROM inventory WHERE product_code = 'PROD-5000'",
            "expected": {
              "product_code": "PROD-5000"
            }
          },
          {
            "description": "Range query returns correct count",
            "executeQuery": "SELECT COUNT(*) as count FROM inventory WHERE product_code >= 'PROD-1000' AND product_code < 'PROD-2000'",
            "expected": {
              "count": 1000
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-011",
      "given": "table with single-line-text field and 5000 records",
      "when": "LIKE pattern search is performed on large dataset",
      "then": "PostgreSQL executes text search and returns matching records",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE articles (id SERIAL PRIMARY KEY, title VARCHAR(255))",
            "INSERT INTO articles (title) SELECT CASE WHEN i % 10 = 0 THEN 'Featured Article ' || i ELSE 'Regular Article ' || i END FROM generate_series(1, 5000) i"
          ]
        },
        "assertions": [
          {
            "description": "Dataset has 5000 records",
            "executeQuery": "SELECT COUNT(*) as count FROM articles",
            "expected": {
              "count": 5000
            }
          },
          {
            "description": "LIKE search finds featured articles",
            "executeQuery": "SELECT COUNT(*) as count FROM articles WHERE title LIKE 'Featured%'",
            "expected": {
              "count": 500
            }
          },
          {
            "description": "LIKE search with % wildcard returns correct results",
            "executeQuery": "SELECT title FROM articles WHERE title LIKE '%Article 100' ORDER BY id LIMIT 1",
            "expected": {
              "title": "Regular Article 100"
            }
          },
          {
            "description": "Case-insensitive ILIKE search works correctly",
            "executeQuery": "SELECT COUNT(*) as count FROM articles WHERE title ILIKE '%FEATURED%'",
            "expected": {
              "count": 500
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-012",
      "given": "table with unique single-line-text field and concurrent insert attempts",
      "when": "two transactions attempt to insert the same unique value simultaneously",
      "then": "PostgreSQL UNIQUE constraint prevents duplicate insertion and one transaction fails",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE users (id SERIAL PRIMARY KEY, username VARCHAR(255) UNIQUE NOT NULL)"
        },
        "assertions": [
          {
            "description": "First transaction inserts successfully",
            "executeQuery": "INSERT INTO users (username) VALUES ('concurrent_user') RETURNING username",
            "expected": {
              "username": "concurrent_user"
            }
          },
          {
            "description": "Second concurrent insert with same value fails",
            "executeQuery": "INSERT INTO users (username) VALUES ('concurrent_user')",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "Only one record exists after concurrent attempts",
            "executeQuery": "SELECT COUNT(*) as count FROM users WHERE username = 'concurrent_user'",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-013",
      "given": "table with single-line-text field and active transaction updating record",
      "when": "UPDATE modifies a text field value",
      "then": "PostgreSQL applies row-level locking and ensures data consistency",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, sku VARCHAR(255) UNIQUE NOT NULL)",
            "INSERT INTO products (sku) VALUES ('PROD-001')"
          ]
        },
        "assertions": [
          {
            "description": "Record exists before update",
            "executeQuery": "SELECT sku FROM products WHERE id = 1",
            "expected": {
              "sku": "PROD-001"
            }
          },
          {
            "description": "UPDATE modifies the text field",
            "executeQuery": "UPDATE products SET sku = 'PROD-001-UPDATED' WHERE id = 1 RETURNING sku",
            "expected": {
              "sku": "PROD-001-UPDATED"
            }
          },
          {
            "description": "Updated value persists after transaction",
            "executeQuery": "SELECT sku FROM products WHERE id = 1",
            "expected": {
              "sku": "PROD-001-UPDATED"
            }
          },
          {
            "description": "Old value no longer exists",
            "executeQuery": "SELECT COUNT(*) as count FROM products WHERE sku = 'PROD-001'",
            "expected": {
              "count": 0
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-014",
      "given": "table with single-line-text field and multiple concurrent inserts",
      "when": "1000 concurrent inserts are attempted with unique values",
      "then": "PostgreSQL handles concurrent writes without data loss or corruption",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE events (id SERIAL PRIMARY KEY, event_code VARCHAR(255) UNIQUE NOT NULL)"
        },
        "assertions": [
          {
            "description": "Bulk concurrent inserts complete successfully",
            "executeQuery": "INSERT INTO events (event_code) SELECT 'EVENT-' || generate_series(1, 1000) RETURNING COUNT(*) OVER() as total",
            "expected": {
              "total": 1000
            }
          },
          {
            "description": "All records have unique values",
            "executeQuery": "SELECT COUNT(DISTINCT event_code) as unique_count FROM events",
            "expected": {
              "unique_count": 1000
            }
          },
          {
            "description": "Total record count matches inserts",
            "executeQuery": "SELECT COUNT(*) as count FROM events",
            "expected": {
              "count": 1000
            }
          },
          {
            "description": "No duplicate records exist",
            "executeQuery": "SELECT COUNT(*) as duplicate_count FROM (SELECT event_code, COUNT(*) as cnt FROM events GROUP BY event_code HAVING COUNT(*) > 1) duplicates",
            "expected": {
              "duplicate_count": 0
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-015",
      "given": "table with single-line-text field accepting empty strings",
      "when": "empty string is inserted into nullable field",
      "then": "PostgreSQL stores empty string as distinct from NULL",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE items (id SERIAL PRIMARY KEY, description VARCHAR(255))"
        },
        "assertions": [
          {
            "description": "Empty string can be inserted",
            "executeQuery": "INSERT INTO items (description) VALUES ('') RETURNING description",
            "expected": {
              "description": ""
            }
          },
          {
            "description": "NULL can be inserted separately",
            "executeQuery": "INSERT INTO items (description) VALUES (NULL) RETURNING description",
            "expected": {
              "description": null
            }
          },
          {
            "description": "Empty string is distinct from NULL",
            "executeQuery": "SELECT COUNT(*) as empty_count FROM items WHERE description = ''",
            "expected": {
              "empty_count": 1
            }
          },
          {
            "description": "NULL count is separate from empty string",
            "executeQuery": "SELECT COUNT(*) as null_count FROM items WHERE description IS NULL",
            "expected": {
              "null_count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-016",
      "given": "table with single-line-text field handling whitespace",
      "when": "strings with whitespace-only content or leading/trailing spaces are inserted",
      "then": "PostgreSQL preserves whitespace without trimming",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE content (id SERIAL PRIMARY KEY, text VARCHAR(255))"
        },
        "assertions": [
          {
            "description": "Whitespace-only string preserved",
            "executeQuery": "INSERT INTO content (text) VALUES ('   ') RETURNING text, LENGTH(text) as len",
            "expected": {
              "text": "   ",
              "len": 3
            }
          },
          {
            "description": "Leading whitespace preserved",
            "executeQuery": "INSERT INTO content (text) VALUES ('  leading') RETURNING text",
            "expected": {
              "text": "  leading"
            }
          },
          {
            "description": "Trailing whitespace preserved",
            "executeQuery": "INSERT INTO content (text) VALUES ('trailing  ') RETURNING text",
            "expected": {
              "text": "trailing  "
            }
          },
          {
            "description": "Mixed whitespace preserved",
            "executeQuery": "INSERT INTO content (text) VALUES ('  both sides  ') RETURNING text, LENGTH(text) as len",
            "expected": {
              "text": "  both sides  ",
              "len": 14
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-017",
      "given": "table with single-line-text field storing minimal and maximal length strings",
      "when": "single character and 255 character strings are inserted",
      "then": "PostgreSQL accepts both boundary values correctly",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE boundaries (id SERIAL PRIMARY KEY, value VARCHAR(255))"
        },
        "assertions": [
          {
            "description": "Single character (minimum non-empty) accepted",
            "executeQuery": "INSERT INTO boundaries (value) VALUES ('a') RETURNING value, LENGTH(value) as len",
            "expected": {
              "value": "a",
              "len": 1
            }
          },
          {
            "description": "Exactly 255 characters (maximum) accepted",
            "executeQuery": "INSERT INTO boundaries (value) VALUES (REPEAT('b', 255)) RETURNING LENGTH(value) as len",
            "expected": {
              "len": 255
            }
          },
          {
            "description": "Both boundary records exist",
            "executeQuery": "SELECT COUNT(*) as count FROM boundaries",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Maximum length value can be retrieved",
            "executeQuery": "SELECT LEFT(value, 10) as prefix, LENGTH(value) as len FROM boundaries WHERE id = 2",
            "expected": {
              "prefix": "bbbbbbbbbb",
              "len": 255
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-018",
      "given": "table with required single-line-text field",
      "when": "empty string is inserted into NOT NULL field",
      "then": "PostgreSQL accepts empty string as valid non-NULL value",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE required_fields (id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL)"
        },
        "assertions": [
          {
            "description": "Empty string satisfies NOT NULL constraint",
            "executeQuery": "INSERT INTO required_fields (name) VALUES ('') RETURNING name",
            "expected": {
              "name": ""
            }
          },
          {
            "description": "Empty string is not NULL",
            "executeQuery": "SELECT name IS NULL as is_null FROM required_fields WHERE id = 1",
            "expected": {
              "is_null": false
            }
          },
          {
            "description": "NULL value is rejected",
            "executeQuery": "INSERT INTO required_fields (name) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-019",
      "given": "table with single-line-text field containing special boundary characters",
      "when": "strings with newlines, tabs, and control characters are inserted",
      "then": "PostgreSQL stores control characters without interpretation",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE special_chars (id SERIAL PRIMARY KEY, content VARCHAR(255))"
        },
        "assertions": [
          {
            "description": "Tab character preserved",
            "executeQuery": "INSERT INTO special_chars (content) VALUES ('before\tafter') RETURNING content",
            "expected": {
              "content": "before\tafter"
            }
          },
          {
            "description": "Newline character preserved",
            "executeQuery": "INSERT INTO special_chars (content) VALUES ('line1\nline2') RETURNING content",
            "expected": {
              "content": "line1\nline2"
            }
          },
          {
            "description": "Carriage return preserved",
            "executeQuery": "INSERT INTO special_chars (content) VALUES ('before\rafter') RETURNING content",
            "expected": {
              "content": "before\rafter"
            }
          },
          {
            "description": "Mixed control characters preserved",
            "executeQuery": "INSERT INTO special_chars (content) VALUES ('tab\tthen\nnewline') RETURNING content, LENGTH(content) as len",
            "expected": {
              "content": "tab\tthen\nnewline",
              "len": 15
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-DEFAULT-001",
      "given": "single-line text field with default: 'Untitled'",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL DEFAULT constraint provides 'Untitled' as value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE documents (id SERIAL PRIMARY KEY, title VARCHAR(255) DEFAULT 'Untitled', content TEXT)",
            "INSERT INTO documents (content) VALUES ('Sample content')"
          ],
          "fieldConfig": {
            "name": "title",
            "type": "single-line-text",
            "default": "Untitled"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='documents' AND column_name='title'",
            "expected": {
              "column_default": "'Untitled'::character varying"
            }
          },
          {
            "description": "INSERT without value uses default",
            "executeQuery": "SELECT title FROM documents WHERE content = 'Sample content'",
            "expected": {
              "title": "Untitled"
            }
          },
          {
            "description": "INSERT with explicit value overrides default",
            "executeQuery": [
              "INSERT INTO documents (title, content) VALUES ('My Document', 'More content')",
              "SELECT title FROM documents WHERE content = 'More content'"
            ],
            "expected": {
              "title": "My Document"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-DEFAULT-002",
      "given": "single-line text field without default specified",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL inserts NULL (no DEFAULT constraint)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE items (id SERIAL PRIMARY KEY, name VARCHAR(255), description TEXT)",
            "INSERT INTO items (description) VALUES ('Test description')"
          ],
          "fieldConfig": {
            "name": "name",
            "type": "single-line-text"
          }
        },
        "assertions": [
          {
            "description": "Column has no DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='items' AND column_name='name'",
            "expected": {
              "column_default": null
            }
          },
          {
            "description": "INSERT without value results in NULL",
            "executeQuery": "SELECT name FROM items WHERE description = 'Test description'",
            "expected": {
              "name": null
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-DEFAULT-003",
      "given": "single-line text field with default: empty string ''",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL DEFAULT constraint provides empty string",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), notes TEXT DEFAULT '')",
            "INSERT INTO tasks (title) VALUES ('Task 1')"
          ],
          "fieldConfig": {
            "name": "notes",
            "type": "single-line-text",
            "default": ""
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT '' constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='tasks' AND column_name='notes'",
            "expected": {
              "column_default": "''::text"
            }
          },
          {
            "description": "INSERT without value uses empty string default",
            "executeQuery": "SELECT notes FROM tasks WHERE title = 'Task 1'",
            "expected": {
              "notes": ""
            }
          },
          {
            "description": "Empty string is different from NULL",
            "executeQuery": "SELECT notes IS NULL as is_null, notes = '' as is_empty FROM tasks WHERE title = 'Task 1'",
            "expected": {
              "is_null": false,
              "is_empty": true
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-SINGLE-LINE-TEXT-DEFAULT-004",
      "given": "single-line text field with default and NOT NULL constraint",
      "when": "INSERT attempts to explicitly set NULL",
      "then": "PostgreSQL rejects NULL value even with default",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, product_name VARCHAR(255) NOT NULL DEFAULT 'New Product')",
            "INSERT INTO products (product_name) VALUES (NULL)"
          ],
          "fieldConfig": {
            "name": "product_name",
            "type": "single-line-text",
            "default": "New Product",
            "required": true
          }
        },
        "assertions": [
          {
            "description": "Explicit NULL insertion rejected by NOT NULL constraint",
            "executeQuery": "INSERT INTO products (product_name) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          },
          {
            "description": "Omitting value uses default successfully",
            "executeQuery": [
              "INSERT INTO products DEFAULT VALUES",
              "SELECT product_name FROM products LIMIT 1"
            ],
            "expected": {
              "product_name": "New Product"
            }
          }
        ]
      }
    }
  ]
}
