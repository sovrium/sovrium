{
  "$id": "decimal-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Decimal Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "unique": {
      "$ref": "../common/unique/unique.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "const": "decimal"
    },
    "min": {
      "$ref": "./min/min.schema.json"
    },
    "max": {
      "$ref": "./max/max.schema.json"
    },
    "default": {
      "$ref": "./default/default.schema.json"
    },
    "precision": {
      "$ref": "./precision/precision.schema.json"
    }
  },
  "description": "Floating-point number field with configurable decimal precision (0-10 places). Ideal for measurements, scores, ratings, and scientific data. Precision determines how many decimal places are stored and displayed (default: 2). Supports min/max constraints for range validation. Required flag makes the field mandatory.",
  "required": [
    "id",
    "name",
    "type"
  ],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-DECIMAL-FIELD-001",
      "given": "table configuration with decimal field 'price' (precision=2)",
      "when": "field migration creates column",
      "then": "PostgreSQL NUMERIC column is created with 2 decimal places",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE products (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "price",
            "type": "decimal",
            "precision": 2
          }
        },
        "assertions": [
          {
            "description": "Column created as NUMERIC type",
            "executeQuery": "SELECT column_name, data_type, numeric_precision, numeric_scale FROM information_schema.columns WHERE table_name='products' AND column_name='price'",
            "expected": {
              "column_name": "price",
              "data_type": "numeric",
              "numeric_precision": null,
              "numeric_scale": 2
            }
          },
          {
            "description": "Decimal value with 2 places can be inserted",
            "executeQuery": "INSERT INTO products (price) VALUES (19.99) RETURNING price",
            "expected": {
              "price": "19.99"
            }
          },
          {
            "description": "Value with more than 2 decimals is rounded",
            "executeQuery": "INSERT INTO products (price) VALUES (29.999) RETURNING price",
            "expected": {
              "price": "30.00"
            }
          }
        ]
      }
    },
    {
      "id": "APP-DECIMAL-FIELD-002",
      "given": "table 'measurements' with decimal field 'weight' (precision=3, min=0.001, max=999.999)",
      "when": "CHECK constraint enforces range validation",
      "then": "PostgreSQL rejects values outside min/max range",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE measurements (id SERIAL PRIMARY KEY, weight NUMERIC(6, 3) CHECK (weight >= 0.001 AND weight <= 999.999))"
        },
        "assertions": [
          {
            "description": "CHECK constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%weight%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Valid decimal within range succeeds",
            "executeQuery": "INSERT INTO measurements (weight) VALUES (123.456) RETURNING weight",
            "expected": {
              "weight": "123.456"
            }
          },
          {
            "description": "Value below min rejected",
            "executeQuery": "INSERT INTO measurements (weight) VALUES (0.0001)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Value above max rejected",
            "executeQuery": "INSERT INTO measurements (weight) VALUES (1000.000)",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-DECIMAL-FIELD-003",
      "given": "table 'financial_records' with decimal field 'amount' (precision=2, required, unique)",
      "when": "constraints are applied",
      "then": "PostgreSQL enforces NOT NULL and UNIQUE constraints",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE financial_records (id SERIAL PRIMARY KEY, amount NUMERIC(10, 2) UNIQUE NOT NULL)",
            "INSERT INTO financial_records (amount) VALUES (1234.56)"
          ]
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='financial_records' AND column_name='amount'",
            "expected": {
              "is_nullable": "NO"
            }
          },
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='financial_records' AND constraint_type='UNIQUE' AND constraint_name LIKE '%amount%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Duplicate decimal rejected",
            "executeQuery": "INSERT INTO financial_records (amount) VALUES (1234.56)",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "NULL insertion fails",
            "executeQuery": "INSERT INTO financial_records (amount) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-DECIMAL-FIELD-004",
      "given": "table 'configurations' with decimal field 'threshold' (precision=1) and default value 5.5",
      "when": "row inserted without providing threshold value",
      "then": "PostgreSQL applies DEFAULT value 5.5",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE configurations (id SERIAL PRIMARY KEY, threshold NUMERIC(3, 1) DEFAULT 5.5)",
          "fieldConfig": {
            "id": 1,
            "name": "threshold",
            "type": "decimal",
            "precision": 1,
            "default": 5.5
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT value",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='configurations' AND column_name='threshold'",
            "expected": {
              "column_default": "5.5"
            }
          },
          {
            "description": "INSERT without threshold uses default",
            "executeQuery": "INSERT INTO configurations (id) VALUES (DEFAULT) RETURNING threshold",
            "expected": {
              "threshold": "5.5"
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO configurations (threshold) VALUES (9.8) RETURNING threshold",
            "expected": {
              "threshold": "9.8"
            }
          }
        ]
      }
    },
    {
      "id": "APP-DECIMAL-FIELD-005",
      "given": "table configuration with decimal field 'rating' (precision=1), indexed=true",
      "when": "index is created on the decimal field",
      "then": "PostgreSQL btree index exists for fast numerical queries",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE reviews (id SERIAL PRIMARY KEY, rating NUMERIC(2, 1) NOT NULL)",
            "CREATE INDEX idx_reviews_rating ON reviews(rating)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "rating",
            "type": "decimal",
            "precision": 1,
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_reviews_rating'",
            "expected": {
              "indexname": "idx_reviews_rating",
              "tablename": "reviews"
            }
          },
          {
            "description": "Index uses btree for range queries and sorting",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_reviews_rating'",
            "expected": {
              "indexdef": "CREATE INDEX idx_reviews_rating ON public.reviews USING btree (rating)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-DEFAULT-001",
      "given": "decimal field with default: 0.0",
      "when": "field migration creates column with DEFAULT constraint",
      "then": "PostgreSQL automatically sets value to 0.0 when not provided",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE accounts (id SERIAL PRIMARY KEY, name VARCHAR(255), balance DECIMAL(15,2) DEFAULT 0.0)",
            "INSERT INTO accounts (name) VALUES ('Account 1'), ('Account 2')"
          ],
          "fieldConfig": {
            "name": "balance",
            "type": "decimal",
            "default": 0
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='accounts' AND column_name='balance'",
            "expected": {
              "column_default": "0.0"
            }
          },
          {
            "description": "Default value applied when not provided",
            "executeQuery": "SELECT balance FROM accounts WHERE name = 'Account 1'",
            "expected": {
              "balance": 0
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO accounts (name, balance) VALUES ('Account 3', 150.50) RETURNING balance",
            "expected": {
              "balance": 150.5
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-DEFAULT-002",
      "given": "decimal field with default: 19.99 (price)",
      "when": "INSERT without value",
      "then": "PostgreSQL uses default value 19.99",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE items (id SERIAL PRIMARY KEY, name VARCHAR(255), price DECIMAL(10,2) DEFAULT 19.99)",
            "INSERT INTO items (name) VALUES ('Item 1')"
          ],
          "fieldConfig": {
            "name": "price",
            "type": "decimal",
            "default": 19.99
          }
        },
        "assertions": [
          {
            "description": "Default value is 19.99",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='items' AND column_name='price'",
            "expected": {
              "column_default": "19.99"
            }
          },
          {
            "description": "Default applied to inserted record",
            "executeQuery": "SELECT price FROM items WHERE name = 'Item 1'",
            "expected": {
              "price": 19.99
            }
          },
          {
            "description": "Explicit 0.0 allowed (overrides default)",
            "executeQuery": "INSERT INTO items (name, price) VALUES ('Item 2', 0.0) RETURNING price",
            "expected": {
              "price": 0
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-DEFAULT-003",
      "given": "decimal field with no default specified",
      "when": "INSERT without value",
      "then": "PostgreSQL uses NULL (if nullable) or rejects (if required)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE measurements (id SERIAL PRIMARY KEY, weight DECIMAL(10,3))",
            "INSERT INTO measurements (id) VALUES (1)"
          ],
          "fieldConfig": {
            "name": "weight",
            "type": "decimal"
          }
        },
        "assertions": [
          {
            "description": "No DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='measurements' AND column_name='weight'",
            "expected": {
              "column_default": null
            }
          },
          {
            "description": "NULL used when no default and no value",
            "executeQuery": "SELECT weight FROM measurements WHERE id = 1",
            "expected": {
              "weight": null
            }
          },
          {
            "description": "Explicit value succeeds",
            "executeQuery": "INSERT INTO measurements (weight) VALUES (125.750) RETURNING weight",
            "expected": {
              "weight": 125.75
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-MAX-001",
      "given": "decimal field with max: 100.0",
      "when": "field migration creates CHECK constraint",
      "then": "PostgreSQL rejects decimal values above maximum",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE exam_scores (id SERIAL PRIMARY KEY, score DECIMAL(5,2) CHECK (score <= 100.0))",
            "INSERT INTO exam_scores (score) VALUES (85.5), (100.0), (92.75)"
          ],
          "fieldConfig": {
            "name": "score",
            "type": "decimal",
            "max": 100
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint exists for max value",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%score%' AND check_clause LIKE '%<= 100.0%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Value at maximum (100.0) accepted",
            "executeQuery": "SELECT score FROM exam_scores WHERE score = 100.0",
            "expected": {
              "score": 100
            }
          },
          {
            "description": "Value above maximum rejected",
            "executeQuery": "INSERT INTO exam_scores (score) VALUES (100.01)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Decimal value below maximum accepted",
            "executeQuery": "INSERT INTO exam_scores (score) VALUES (67.25) RETURNING score",
            "expected": {
              "score": 67.25
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-MAX-002",
      "given": "decimal field with max: 999.99 (price limit)",
      "when": "INSERT with value above max",
      "then": "PostgreSQL CHECK constraint rejects value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, price DECIMAL(10,2) CHECK (price <= 999.99))",
            "INSERT INTO products (price) VALUES (49.99), (999.99)"
          ],
          "fieldConfig": {
            "name": "price",
            "type": "decimal",
            "max": 999.99
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces max 999.99",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%price%'",
            "expected": {
              "check_clause": "(price <= 999.99)"
            }
          },
          {
            "description": "Exact maximum (999.99) accepted",
            "executeQuery": "SELECT price FROM products WHERE price = 999.99",
            "expected": {
              "price": 999.99
            }
          },
          {
            "description": "Above maximum rejected",
            "executeQuery": "INSERT INTO products (price) VALUES (1000.00)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Below maximum accepted",
            "executeQuery": "INSERT INTO products (price) VALUES (149.50) RETURNING price",
            "expected": {
              "price": 149.5
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-MAX-003",
      "given": "decimal field with both min and max (range constraint)",
      "when": "CHECK constraint combines both",
      "then": "PostgreSQL enforces decimal value within range",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE discounts (id SERIAL PRIMARY KEY, rate DECIMAL(5,2) CHECK (rate >= 0.0 AND rate <= 100.0))",
            "INSERT INTO discounts (rate) VALUES (0.0), (50.5), (100.0)"
          ],
          "fieldConfig": {
            "name": "rate",
            "type": "decimal",
            "min": 0,
            "max": 100
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces range 0.0-100.0",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%rate%'",
            "expected": {
              "check_clause": "((rate >= 0.0) AND (rate <= 100.0))"
            }
          },
          {
            "description": "Value at min (0.0) accepted",
            "executeQuery": "SELECT rate FROM discounts WHERE rate = 0.0",
            "expected": {
              "rate": 0
            }
          },
          {
            "description": "Value at max (100.0) accepted",
            "executeQuery": "SELECT rate FROM discounts WHERE rate = 100.0",
            "expected": {
              "rate": 100
            }
          },
          {
            "description": "Value below min rejected",
            "executeQuery": "INSERT INTO discounts (rate) VALUES (-0.01)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Value above max rejected",
            "executeQuery": "INSERT INTO discounts (rate) VALUES (100.01)",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-MIN-001",
      "given": "decimal field with min: 0.0",
      "when": "field migration creates CHECK constraint",
      "then": "PostgreSQL rejects decimal values below minimum",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE measurements (id SERIAL PRIMARY KEY, value DECIMAL(10,2) CHECK (value >= 0.0))",
            "INSERT INTO measurements (value) VALUES (0.0), (10.5), (99.99)"
          ],
          "fieldConfig": {
            "name": "value",
            "type": "decimal",
            "min": 0
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint exists for min value",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%value%' AND check_clause LIKE '%>= 0.0%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Value at minimum (0.0) accepted",
            "executeQuery": "SELECT value FROM measurements WHERE value = 0.0",
            "expected": {
              "value": 0
            }
          },
          {
            "description": "Value below minimum rejected",
            "executeQuery": "INSERT INTO measurements (value) VALUES (-0.01)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Decimal value above minimum accepted",
            "executeQuery": "INSERT INTO measurements (value) VALUES (25.75) RETURNING value",
            "expected": {
              "value": 25.75
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-MIN-002",
      "given": "decimal field with min: -273.15 (absolute zero)",
      "when": "INSERT with value below min",
      "then": "PostgreSQL CHECK constraint rejects value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE temperatures (id SERIAL PRIMARY KEY, celsius DECIMAL(6,2) CHECK (celsius >= -273.15))",
            "INSERT INTO temperatures (celsius) VALUES (-273.15), (0.0), (100.0)"
          ],
          "fieldConfig": {
            "name": "celsius",
            "type": "decimal",
            "min": -273.15
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces min -273.15",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%celsius%'",
            "expected": {
              "check_clause": "(celsius >= '-273.15'::numeric)"
            }
          },
          {
            "description": "Exact minimum (-273.15) accepted",
            "executeQuery": "SELECT celsius FROM temperatures WHERE celsius = -273.15",
            "expected": {
              "celsius": -273.15
            }
          },
          {
            "description": "Below minimum rejected",
            "executeQuery": "INSERT INTO temperatures (celsius) VALUES (-273.16)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Above minimum accepted",
            "executeQuery": "INSERT INTO temperatures (celsius) VALUES (37.5) RETURNING celsius",
            "expected": {
              "celsius": 37.5
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-MIN-003",
      "given": "decimal field with no min specified",
      "when": "any decimal value inserted",
      "then": "PostgreSQL accepts all DECIMAL range values",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE balances (id SERIAL PRIMARY KEY, amount DECIMAL(15,2))",
            "INSERT INTO balances (amount) VALUES (-9999.99), (0.0), (9999.99)"
          ],
          "fieldConfig": {
            "name": "amount",
            "type": "decimal"
          }
        },
        "assertions": [
          {
            "description": "No CHECK constraint for min",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%amount%'",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Negative decimal values accepted",
            "executeQuery": "SELECT amount FROM balances WHERE amount = -9999.99",
            "expected": {
              "amount": -9999.99
            }
          },
          {
            "description": "Large negative value accepted",
            "executeQuery": "INSERT INTO balances (amount) VALUES (-50000.00) RETURNING amount",
            "expected": {
              "amount": -50000
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-PRECISION-001",
      "given": "user provides precision between 0 and 10",
      "when": "validating input",
      "then": "value should be accepted",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "example_field",
            "type": "text"
          }
        },
        "assertions": [
          {
            "description": "value should be accepted",
            "validateConfig": true,
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-PRECISION-002",
      "given": "user provides precision below 0",
      "when": "validating input",
      "then": "error should enforce minimum value",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "example_field",
            "type": "text"
          }
        },
        "assertions": [
          {
            "description": "error should enforce minimum value",
            "validateConfig": true,
            "expectError": "must be within the allowed range"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DECIMAL-PRECISION-003",
      "given": "user provides precision above 10",
      "when": "validating input",
      "then": "error should enforce maximum value",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "example_field",
            "type": "text"
          }
        },
        "assertions": [
          {
            "description": "error should enforce maximum value",
            "validateConfig": true,
            "expectError": "must be within the allowed range"
          }
        ]
      }
    }
  ]
}
