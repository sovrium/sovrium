{
  "$id": "updated-by-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Updated By Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "type": {
      "type": "string",
      "const": "updated-by"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    }
  },
  "description": "Automatically updated reference to the user who last modified the record. Read-only field that links to user account. Updates on every save operation to current user. Automatically indexed for filtering by editor. Useful for audit trails, tracking who made recent changes, and collaboration history. Displays user profile information in UI.",
  "required": [
    "id",
    "name",
    "type"
  ],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-UPDATED-BY-FIELD-001",
      "given": "table configuration with updated-by field 'updated_by' and UPDATE trigger",
      "when": "field migration creates foreign key with trigger function",
      "then": "PostgreSQL INTEGER NOT NULL column with FOREIGN KEY and trigger is created",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "INSERT INTO users (name) VALUES ('Alice'), ('Bob')",
            "CREATE TABLE products (id SERIAL PRIMARY KEY, name VARCHAR(255), updated_by INTEGER NOT NULL REFERENCES users(id))",
            "CREATE OR REPLACE FUNCTION update_updated_by_column() RETURNS TRIGGER AS $$ BEGIN NEW.updated_by = NEW.updated_by; RETURN NEW; END; $$ LANGUAGE plpgsql",
            "CREATE TRIGGER set_updated_by BEFORE UPDATE ON products FOR EACH ROW EXECUTE FUNCTION update_updated_by_column()"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "updated_by",
            "type": "updated-by"
          }
        },
        "assertions": [
          {
            "description": "Column created as INTEGER with NOT NULL",
            "executeQuery": "SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name='products' AND column_name='updated_by'",
            "expected": {
              "column_name": "updated_by",
              "data_type": "integer",
              "is_nullable": "NO"
            }
          },
          {
            "description": "FOREIGN KEY constraint references users",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='products' AND constraint_type='FOREIGN KEY' AND constraint_name LIKE '%updated_by%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "UPDATE trigger exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.triggers WHERE event_object_table='products' AND trigger_name='set_updated_by'",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-UPDATED-BY-FIELD-002",
      "given": "table 'documents' with updated-by field",
      "when": "record is updated by different users",
      "then": "updated_by reflects the most recent editor's user ID",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "INSERT INTO users (name) VALUES ('Alice'), ('Bob'), ('Charlie')",
            "CREATE TABLE documents (id SERIAL PRIMARY KEY, title VARCHAR(255), updated_by INTEGER NOT NULL REFERENCES users(id))",
            "INSERT INTO documents (title, updated_by) VALUES ('Initial Doc', 1)"
          ]
        },
        "assertions": [
          {
            "description": "Initial updated_by is Alice (user 1)",
            "executeQuery": "SELECT updated_by FROM documents WHERE id = 1",
            "expected": {
              "updated_by": 1
            }
          },
          {
            "description": "UPDATE by Bob changes updated_by to user 2",
            "executeQuery": "UPDATE documents SET title = 'Updated by Bob', updated_by = 2 WHERE id = 1 RETURNING updated_by",
            "expected": {
              "updated_by": 2
            }
          },
          {
            "description": "Subsequent UPDATE by Charlie changes to user 3",
            "executeQuery": "UPDATE documents SET title = 'Updated by Charlie', updated_by = 3 WHERE id = 1 RETURNING updated_by",
            "expected": {
              "updated_by": 3
            }
          },
          {
            "description": "Join with users shows last editor name",
            "executeQuery": "SELECT d.title, u.name as last_editor FROM documents d JOIN users u ON d.updated_by = u.id WHERE d.id = 1",
            "expected": {
              "title": "Updated by Charlie",
              "last_editor": "Charlie"
            }
          }
        ]
      }
    },
    {
      "id": "APP-UPDATED-BY-FIELD-003",
      "given": "table 'tasks' with updated-by field for change tracking",
      "when": "querying tasks by last editor",
      "then": "PostgreSQL supports efficient filtering by updated_by user",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "INSERT INTO users (name) VALUES ('Alice'), ('Bob')",
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), status VARCHAR(50), updated_by INTEGER NOT NULL REFERENCES users(id))",
            "INSERT INTO tasks (title, status, updated_by) VALUES ('Task 1', 'open', 1), ('Task 2', 'open', 2), ('Task 3', 'open', 1)",
            "UPDATE tasks SET status = 'closed', updated_by = 2 WHERE id = 1",
            "UPDATE tasks SET status = 'closed', updated_by = 2 WHERE id = 3"
          ]
        },
        "assertions": [
          {
            "description": "Find all tasks last edited by Bob",
            "executeQuery": "SELECT COUNT(*) as count FROM tasks WHERE updated_by = 2",
            "expected": {
              "count": 3
            }
          },
          {
            "description": "Find tasks last edited by Alice",
            "executeQuery": "SELECT COUNT(*) as count FROM tasks WHERE updated_by = 1",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Join with users to see editor details",
            "executeQuery": "SELECT t.title, t.status, u.name as last_editor FROM tasks t JOIN users u ON t.updated_by = u.id WHERE t.status = 'closed' ORDER BY t.id",
            "expected": [
              {
                "title": "Task 1",
                "status": "closed",
                "last_editor": "Bob"
              },
              {
                "title": "Task 3",
                "status": "closed",
                "last_editor": "Bob"
              }
            ]
          }
        ]
      }
    },
    {
      "id": "APP-UPDATED-BY-FIELD-004",
      "given": "table 'pages' with both created_by and updated_by fields",
      "when": "tracking original creator vs last editor",
      "then": "PostgreSQL supports dual audit trail (creator and last editor)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "INSERT INTO users (name) VALUES ('Alice'), ('Bob')",
            "CREATE TABLE pages (id SERIAL PRIMARY KEY, title VARCHAR(255), created_by INTEGER NOT NULL REFERENCES users(id), updated_by INTEGER NOT NULL REFERENCES users(id))",
            "INSERT INTO pages (title, created_by, updated_by) VALUES ('Page 1', 1, 1)",
            "UPDATE pages SET title = 'Page 1 Edited', updated_by = 2 WHERE id = 1"
          ]
        },
        "assertions": [
          {
            "description": "Creator remains Alice, editor is Bob",
            "executeQuery": "SELECT p.title, uc.name as creator, ue.name as editor FROM pages p JOIN users uc ON p.created_by = uc.id JOIN users ue ON p.updated_by = ue.id WHERE p.id = 1",
            "expected": {
              "title": "Page 1 Edited",
              "creator": "Alice",
              "editor": "Bob"
            }
          },
          {
            "description": "created_by is immutable (still user 1)",
            "executeQuery": "SELECT created_by FROM pages WHERE id = 1",
            "expected": {
              "created_by": 1
            }
          },
          {
            "description": "updated_by changed to user 2",
            "executeQuery": "SELECT updated_by FROM pages WHERE id = 1",
            "expected": {
              "updated_by": 2
            }
          }
        ]
      }
    },
    {
      "id": "APP-UPDATED-BY-FIELD-005",
      "given": "table configuration with updated-by field, indexed=true",
      "when": "index is created on the updated_by field",
      "then": "PostgreSQL btree index exists for fast editor filtering",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE articles (id SERIAL PRIMARY KEY, content TEXT, updated_by INTEGER NOT NULL REFERENCES users(id))",
            "CREATE INDEX idx_articles_updated_by ON articles(updated_by)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "updated_by",
            "type": "updated-by",
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_articles_updated_by'",
            "expected": {
              "indexname": "idx_articles_updated_by",
              "tablename": "articles"
            }
          },
          {
            "description": "Index uses btree for editor filtering",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_articles_updated_by'",
            "expected": {
              "indexdef": "CREATE INDEX idx_articles_updated_by ON public.articles USING btree (updated_by)"
            }
          }
        ]
      }
    }
  ]
}
