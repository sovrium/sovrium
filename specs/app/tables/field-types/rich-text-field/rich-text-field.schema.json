{
  "$id": "rich-text-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Rich Text Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "type": {
      "type": "string",
      "const": "rich-text"
    },
    "maxLength": {
      "$ref": "./maxLength/maxLength.schema.json"
    }
  },
  "description": "Formatted text with markdown support",
  "required": ["id", "name", "type"],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-RICH-TEXT-FIELD-001",
      "given": "table configuration with rich-text field 'content'",
      "when": "field migration creates TEXT column",
      "then": "PostgreSQL TEXT column is created for markdown/rich text storage",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE posts (id SERIAL PRIMARY KEY, content TEXT)",
          "fieldConfig": {
            "id": 1,
            "name": "content",
            "type": "rich-text"
          }
        },
        "assertions": [
          {
            "description": "Column created as TEXT",
            "executeQuery": "SELECT column_name, data_type FROM information_schema.columns WHERE table_name='posts' AND column_name='content'",
            "expected": {
              "column_name": "content",
              "data_type": "text"
            }
          },
          {
            "description": "Markdown text can be stored",
            "executeQuery": "INSERT INTO posts (content) VALUES ('# Heading\n\n**Bold** and *italic* text') RETURNING content",
            "expected": {
              "content": "# Heading\n\n**Bold** and *italic* text"
            }
          },
          {
            "description": "Long text content supported",
            "executeQuery": "INSERT INTO posts (content) VALUES (REPEAT('Lorem ipsum ', 1000)) RETURNING LENGTH(content) as length",
            "expected": {
              "length": 12000
            }
          }
        ]
      }
    },
    {
      "id": "APP-RICH-TEXT-FIELD-002",
      "given": "table 'articles' with rich-text field and maxLength constraint",
      "when": "CHECK constraint enforces maximum length",
      "then": "PostgreSQL rejects text exceeding maxLength",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE articles (id SERIAL PRIMARY KEY, summary TEXT CHECK (LENGTH(summary) <= 500))",
          "fieldConfig": {
            "id": 1,
            "name": "summary",
            "type": "rich-text",
            "maxLength": 500
          }
        },
        "assertions": [
          {
            "description": "Text within limit succeeds",
            "executeQuery": "INSERT INTO articles (summary) VALUES (REPEAT('a', 500)) RETURNING LENGTH(summary) as length",
            "expected": {
              "length": 500
            }
          },
          {
            "description": "Text exceeding maxLength rejected",
            "executeQuery": "INSERT INTO articles (summary) VALUES (REPEAT('a', 501))",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-RICH-TEXT-FIELD-003",
      "given": "table 'pages' with rich-text field for full-text search",
      "when": "GIN index with to_tsvector is created",
      "then": "PostgreSQL supports efficient full-text search on rich text",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE pages (id SERIAL PRIMARY KEY, body TEXT)",
            "CREATE INDEX idx_pages_body_fulltext ON pages USING GIN(to_tsvector('english', body))"
          ]
        },
        "assertions": [
          {
            "description": "Full-text search index exists",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_pages_body_fulltext'",
            "expected": {
              "indexname": "idx_pages_body_fulltext",
              "tablename": "pages"
            }
          },
          {
            "description": "Index uses GIN for full-text search",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_pages_body_fulltext'",
            "expected": {
              "indexdef": "CREATE INDEX idx_pages_body_fulltext ON public.pages USING gin (to_tsvector('english'::regconfig, body))"
            }
          }
        ]
      }
    },
    {
      "id": "APP-RICH-TEXT-FIELD-004",
      "given": "table 'comments' with rich-text field supporting search",
      "when": "full-text search query is performed",
      "then": "PostgreSQL to_tsvector and to_tsquery enable text search",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE comments (id SERIAL PRIMARY KEY, message TEXT)",
            "INSERT INTO comments (message) VALUES ('This is a great product!')",
            "INSERT INTO comments (message) VALUES ('I love the design and features')",
            "INSERT INTO comments (message) VALUES ('Not happy with the service')"
          ]
        },
        "assertions": [
          {
            "description": "Find comments containing 'product'",
            "executeQuery": "SELECT COUNT(*) as count FROM comments WHERE to_tsvector('english', message) @@ to_tsquery('english', 'product')",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Find comments containing 'design' OR 'service'",
            "executeQuery": "SELECT COUNT(*) as count FROM comments WHERE to_tsvector('english', message) @@ to_tsquery('english', 'design | service')",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    },
    {
      "id": "APP-RICH-TEXT-FIELD-005",
      "given": "table 'documents' with rich-text field (required, unique)",
      "when": "constraints are applied",
      "then": "PostgreSQL enforces NOT NULL and UNIQUE constraints",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE documents (id SERIAL PRIMARY KEY, slug TEXT UNIQUE NOT NULL)",
            "INSERT INTO documents (slug) VALUES ('my-first-document')"
          ]
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='documents' AND column_name='slug'",
            "expected": {
              "is_nullable": "NO"
            }
          },
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='documents' AND constraint_type='UNIQUE' AND constraint_name LIKE '%slug%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Duplicate slug rejected",
            "executeQuery": "INSERT INTO documents (slug) VALUES ('my-first-document')",
            "expectError": "duplicate key value violates unique constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RICH-TEXT-MAXLENGTH-001",
      "given": "user provides maxLength >= 1",
      "when": "validating input",
      "then": "value should be accepted",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "example_field",
            "type": "text"
          }
        },
        "assertions": [
          {
            "description": "value should be accepted",
            "validateConfig": true,
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-RICH-TEXT-MAXLENGTH-002",
      "given": "user provides maxLength < 1",
      "when": "validating input",
      "then": "error should enforce minimum value",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "example_field",
            "type": "text"
          }
        },
        "assertions": [
          {
            "description": "error should enforce minimum value",
            "validateConfig": true,
            "expectError": "must be within the allowed range"
          }
        ]
      }
    }
  ]
}
