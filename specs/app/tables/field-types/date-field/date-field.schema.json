{
  "$id": "date-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Date Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "unique": {
      "$ref": "../common/unique/unique.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "type": "string",
      "const": "date",
      "description": "Field type discriminator for date-only fields",
      "examples": ["date"]
    },
    "format": {
      "$ref": "./format/format.schema.json"
    },
    "default": {
      "$ref": "./default/default.schema.json"
    }
  },
  "description": "Date field for calendar dates only (no time component). Stores values in ISO 8601 date format (YYYY-MM-DD). Supports custom display formats (YYYY-MM-DD, MM/DD/YYYY, DD-MM-YYYY) and optional default values. Useful for tracking birthdays, deadlines, project milestones, and any date-based data without time precision.",
  "examples": [
    {
      "id": "fld_001",
      "name": "birth_date",
      "type": "date",
      "required": true,
      "format": "YYYY-MM-DD"
    },
    {
      "id": "fld_002",
      "name": "project_deadline",
      "type": "date",
      "required": false,
      "indexed": true,
      "format": "MM/DD/YYYY"
    }
  ],
  "required": ["id", "name", "type"],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-FIELD-DATE-001",
      "given": "table configuration with date field 'birth_date'",
      "when": "field migration creates column",
      "then": "PostgreSQL DATE column is created for calendar dates",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE employees (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "birth_date",
            "type": "date"
          }
        },
        "assertions": [
          {
            "description": "Column created as DATE type",
            "executeQuery": "SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name='employees' AND column_name='birth_date'",
            "expected": {
              "column_name": "birth_date",
              "data_type": "date",
              "is_nullable": "YES"
            }
          },
          {
            "description": "Valid date can be inserted",
            "executeQuery": "INSERT INTO employees (birth_date) VALUES ('1990-05-15') RETURNING birth_date",
            "expected": {
              "birth_date": "1990-05-15"
            }
          },
          {
            "description": "Date stored in ISO 8601 format (YYYY-MM-DD)",
            "executeQuery": "SELECT birth_date::TEXT as date_string FROM employees WHERE id = 1",
            "expected": {
              "date_string": "1990-05-15"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-002",
      "given": "table 'projects' with date field 'deadline'",
      "when": "date range queries are performed",
      "then": "PostgreSQL DATE type supports comparison and ordering",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE projects (id SERIAL PRIMARY KEY, deadline DATE)",
            "INSERT INTO projects (deadline) VALUES ('2024-01-15'), ('2024-06-30'), ('2024-12-31')"
          ]
        },
        "assertions": [
          {
            "description": "Find dates after specific date",
            "executeQuery": "SELECT COUNT(*) as count FROM projects WHERE deadline > '2024-06-01'",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Find dates between range",
            "executeQuery": "SELECT COUNT(*) as count FROM projects WHERE deadline BETWEEN '2024-01-01' AND '2024-06-30'",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Order by date ascending",
            "executeQuery": "SELECT deadline::TEXT FROM projects ORDER BY deadline ASC LIMIT 1",
            "expected": {
              "deadline": "2024-01-15"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-003",
      "given": "table 'events' with date field 'event_date' (required, unique)",
      "when": "constraints are applied",
      "then": "PostgreSQL enforces NOT NULL and UNIQUE constraints",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE events (id SERIAL PRIMARY KEY, event_date DATE UNIQUE NOT NULL)",
            "INSERT INTO events (event_date) VALUES ('2024-12-25')"
          ]
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='events' AND column_name='event_date'",
            "expected": {
              "is_nullable": "NO"
            }
          },
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='events' AND constraint_type='UNIQUE' AND constraint_name LIKE '%event_date%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Duplicate date rejected",
            "executeQuery": "INSERT INTO events (event_date) VALUES ('2024-12-25')",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "NULL date insertion fails",
            "executeQuery": "INSERT INTO events (event_date) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-004",
      "given": "table 'registrations' with date field 'signup_date' and default value CURRENT_DATE",
      "when": "row inserted without providing signup_date value",
      "then": "PostgreSQL applies DEFAULT value as current date",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE registrations (id SERIAL PRIMARY KEY, signup_date DATE DEFAULT CURRENT_DATE)",
          "fieldConfig": {
            "id": 1,
            "name": "signup_date",
            "type": "date",
            "default": "today"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT value CURRENT_DATE",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='registrations' AND column_name='signup_date'",
            "expected": {
              "column_default": "CURRENT_DATE"
            }
          },
          {
            "description": "INSERT without signup_date uses current date",
            "executeQuery": "INSERT INTO registrations (id) VALUES (DEFAULT) RETURNING signup_date = CURRENT_DATE as is_today",
            "expected": {
              "is_today": true
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO registrations (signup_date) VALUES ('2024-01-01') RETURNING signup_date",
            "expected": {
              "signup_date": "2024-01-01"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-005",
      "given": "table configuration with date field 'anniversary', indexed=true",
      "when": "index is created on the date field",
      "then": "PostgreSQL btree index exists for fast date queries",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE memberships (id SERIAL PRIMARY KEY, anniversary DATE NOT NULL)",
            "CREATE INDEX idx_memberships_anniversary ON memberships(anniversary)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "anniversary",
            "type": "date",
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_memberships_anniversary'",
            "expected": {
              "indexname": "idx_memberships_anniversary",
              "tablename": "memberships"
            }
          },
          {
            "description": "Index uses btree for date range queries",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_memberships_anniversary'",
            "expected": {
              "indexdef": "CREATE INDEX idx_memberships_anniversary ON public.memberships USING btree (anniversary)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-DEFAULT-001",
      "given": "date field with static default: '2025-01-01'",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL DEFAULT constraint provides '2025-01-01'",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE events (id SERIAL PRIMARY KEY, title VARCHAR(255), event_date DATE DEFAULT '2025-01-01')",
            "INSERT INTO events (title) VALUES ('New Year Party')"
          ],
          "fieldConfig": {
            "name": "event_date",
            "type": "date",
            "default": "2025-01-01"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT constraint with date",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='events' AND column_name='event_date'",
            "expected": {
              "column_default": "'2025-01-01'::date"
            }
          },
          {
            "description": "INSERT without value uses default date",
            "executeQuery": "SELECT event_date FROM events WHERE title = 'New Year Party'",
            "expected": {
              "event_date": "2025-01-01"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-DEFAULT-002",
      "given": "date field with dynamic default: 'today' (CURRENT_DATE)",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL DEFAULT CURRENT_DATE provides current date",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE logs (id SERIAL PRIMARY KEY, message TEXT, log_date DATE DEFAULT CURRENT_DATE)",
            "INSERT INTO logs (message) VALUES ('System started')"
          ],
          "fieldConfig": {
            "name": "log_date",
            "type": "date",
            "default": "today"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT CURRENT_DATE constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='logs' AND column_name='log_date'",
            "expected": {
              "column_default": "CURRENT_DATE"
            }
          },
          {
            "description": "INSERT without value uses current date (dynamic)",
            "executeQuery": "SELECT log_date = CURRENT_DATE as is_today FROM logs WHERE message = 'System started'",
            "expected": {
              "is_today": true
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-DEFAULT-003",
      "given": "date field without default specified",
      "when": "INSERT without value for this field",
      "then": "PostgreSQL inserts NULL",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), due_date DATE)",
            "INSERT INTO tasks (title) VALUES ('Todo item')"
          ],
          "fieldConfig": {
            "name": "due_date",
            "type": "date"
          }
        },
        "assertions": [
          {
            "description": "Column has no DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='tasks' AND column_name='due_date'",
            "expected": {
              "column_default": null
            }
          },
          {
            "description": "INSERT without value results in NULL",
            "executeQuery": "SELECT due_date FROM tasks WHERE title = 'Todo item'",
            "expected": {
              "due_date": null
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-DEFAULT-004",
      "given": "date field with default and explicit value",
      "when": "INSERT with specific date",
      "then": "PostgreSQL uses explicit value, ignoring default",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE appointments (id SERIAL PRIMARY KEY, client VARCHAR(255), appointment_date DATE DEFAULT CURRENT_DATE)",
            "INSERT INTO appointments (client, appointment_date) VALUES ('Alice', '2025-06-15')"
          ],
          "fieldConfig": {
            "name": "appointment_date",
            "type": "date",
            "default": "today"
          }
        },
        "assertions": [
          {
            "description": "Explicit value overrides default",
            "executeQuery": "SELECT appointment_date FROM appointments WHERE client = 'Alice'",
            "expected": {
              "appointment_date": "2025-06-15"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-FORMAT-001",
      "title": "Accept valid date format pattern",
      "given": "date field with format: 'MM/DD/YYYY' (US format)",
      "when": "field migration creates DATE column",
      "then": "PostgreSQL stores in ISO 8601 (YYYY-MM-DD), application displays using format pattern",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE events (id SERIAL PRIMARY KEY, name VARCHAR(255), event_date DATE)",
            "INSERT INTO events (name, event_date) VALUES ('Launch', '2024-12-31'), ('Conference', '2024-01-15')"
          ],
          "fieldConfig": {
            "name": "event_date",
            "type": "date",
            "format": "MM/DD/YYYY"
          }
        },
        "assertions": [
          {
            "description": "Column uses DATE type (ISO 8601 storage)",
            "executeQuery": "SELECT data_type FROM information_schema.columns WHERE table_name='events' AND column_name='event_date'",
            "expected": {
              "data_type": "date"
            }
          },
          {
            "description": "Date stored in ISO format (YYYY-MM-DD)",
            "executeQuery": "SELECT event_date FROM events WHERE name = 'Launch'",
            "expected": {
              "event_date": "2024-12-31"
            }
          },
          {
            "description": "Application transforms to display format (MM/DD/YYYY)",
            "displayFormat": "MM/DD/YYYY",
            "executeQuery": "SELECT event_date FROM events WHERE name = 'Launch'",
            "expectedDisplay": "12/31/2024",
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-FORMAT-002",
      "title": "Use default format when not specified",
      "given": "date field without format property",
      "when": "user views date value",
      "then": "date displayed in default ISO 8601 format (YYYY-MM-DD)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), due_date DATE DEFAULT CURRENT_DATE)",
            "INSERT INTO tasks (title, due_date) VALUES ('Task 1', '2024-06-15')"
          ],
          "fieldConfig": {
            "name": "due_date",
            "type": "date"
          }
        },
        "assertions": [
          {
            "description": "Default format is YYYY-MM-DD",
            "executeQuery": "SELECT due_date FROM tasks WHERE title = 'Task 1'",
            "expected": {
              "due_date": "2024-06-15"
            }
          },
          {
            "description": "Display format defaults to YYYY-MM-DD (same as storage)",
            "displayFormat": "YYYY-MM-DD",
            "executeQuery": "SELECT due_date FROM tasks WHERE title = 'Task 1'",
            "expectedDisplay": "2024-06-15",
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-FORMAT-003",
      "title": "Reject invalid format pattern",
      "given": "date field with invalid format pattern",
      "when": "field configuration validation runs",
      "then": "validation error returned with message 'Invalid date format pattern'",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "created_date",
            "type": "date",
            "format": "INVALID-FORMAT"
          }
        },
        "assertions": [
          {
            "description": "Invalid format pattern rejected",
            "validateConfig": true,
            "expectError": "Invalid date format pattern. Valid tokens: YYYY, MM, DD"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-DATE-FORMAT-004",
      "title": "Support European date format (DD-MM-YYYY)",
      "given": "date field with format: 'DD-MM-YYYY'",
      "when": "date '2024-12-25' retrieved",
      "then": "application displays as '25-12-2024'",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE holidays (id SERIAL PRIMARY KEY, name VARCHAR(255), holiday_date DATE)",
            "INSERT INTO holidays (name, holiday_date) VALUES ('Christmas', '2024-12-25')"
          ],
          "fieldConfig": {
            "name": "holiday_date",
            "type": "date",
            "format": "DD-MM-YYYY"
          }
        },
        "assertions": [
          {
            "description": "Storage remains ISO format",
            "executeQuery": "SELECT holiday_date FROM holidays WHERE name = 'Christmas'",
            "expected": {
              "holiday_date": "2024-12-25"
            }
          },
          {
            "description": "Display uses European format (DD-MM-YYYY)",
            "displayFormat": "DD-MM-YYYY",
            "executeQuery": "SELECT holiday_date FROM holidays WHERE name = 'Christmas'",
            "expectedDisplay": "25-12-2024",
            "expectError": "validation error"
          }
        ]
      }
    }
  ]
}
