{
  "$id": "long-text-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Long Text Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "unique": {
      "$ref": "../common/unique/unique.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "const": "long-text"
    },
    "default": {
      "$ref": "./default/default.schema.json"
    }
  },
  "description": "Multi-line text input for paragraphs, descriptions, notes, and comments. Supports line breaks and longer content. Text is stored as-is without rich formatting (no bold, italics, etc.). Required flag makes the field mandatory. Indexing improves search performance but may be slower for very long content.",
  "required": ["id", "name", "type"],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-FIELD-LONG-TEXT-001",
      "given": "table configuration with long-text field 'description'",
      "when": "field migration creates column",
      "then": "PostgreSQL TEXT column is created (unlimited length)",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE articles (id SERIAL PRIMARY KEY)",
          "fieldConfig": { "id": 1, "name": "description", "type": "long-text" }
        },
        "assertions": [
          {
            "description": "Column created as TEXT type",
            "executeQuery": "SELECT column_name, data_type, character_maximum_length, is_nullable FROM information_schema.columns WHERE table_name='articles' AND column_name='description'",
            "expected": {
              "column_name": "description",
              "data_type": "text",
              "character_maximum_length": null,
              "is_nullable": "YES"
            }
          },
          {
            "description": "Multi-line text with line breaks can be inserted",
            "executeQuery": "INSERT INTO articles (description) VALUES ('Line 1\nLine 2\nLine 3') RETURNING description",
            "expected": { "description": "Line 1\nLine 2\nLine 3" }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LONG-TEXT-002",
      "given": "table 'posts' with long-text field 'content'",
      "when": "insert text exceeding VARCHAR(255) limit (500+ characters)",
      "then": "TEXT column accepts unlimited length without truncation",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE posts (id SERIAL PRIMARY KEY, content TEXT)"
        },
        "assertions": [
          {
            "description": "TEXT column has no character_maximum_length",
            "executeQuery": "SELECT data_type, character_maximum_length FROM information_schema.columns WHERE table_name='posts' AND column_name='content'",
            "expected": {
              "data_type": "text",
              "character_maximum_length": null
            }
          },
          {
            "description": "Large text (>255 chars) insertion succeeds",
            "executeQuery": "INSERT INTO posts (content) VALUES ('Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.') RETURNING LENGTH(content) as length",
            "expected": { "length": 445 }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LONG-TEXT-003",
      "given": "table 'comments' with required long-text field 'body'",
      "when": "attempt to insert NULL value for required body",
      "then": "PostgreSQL NOT NULL constraint rejects insertion",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE comments (id SERIAL PRIMARY KEY, body TEXT NOT NULL)"
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='comments' AND column_name='body'",
            "expected": { "is_nullable": "NO" }
          },
          {
            "description": "Valid text insertion succeeds",
            "executeQuery": "INSERT INTO comments (body) VALUES ('Great article!') RETURNING body",
            "expected": { "body": "Great article!" }
          },
          {
            "description": "NULL insertion fails",
            "executeQuery": "INSERT INTO comments (body) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-LONG-TEXT-FIELD-004",
      "given": "table configuration with long-text field, indexed=true",
      "when": "index is created on the text field",
      "then": "PostgreSQL btree index exists for text search performance",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE pages (id SERIAL PRIMARY KEY, content TEXT NOT NULL)",
            "CREATE INDEX idx_pages_content ON pages(content)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "content",
            "type": "long-text",
            "required": true,
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_pages_content'",
            "expected": { "indexname": "idx_pages_content", "tablename": "pages" }
          },
          {
            "description": "Index uses btree for text searching",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_pages_content'",
            "expected": {
              "indexdef": "CREATE INDEX idx_pages_content ON public.pages USING btree (content)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-LONG-TEXT-FIELD-005",
      "given": "table with long-text field 'notes' and default value 'No notes'",
      "when": "row inserted without providing notes value",
      "then": "PostgreSQL applies DEFAULT value 'No notes'",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE projects (id SERIAL PRIMARY KEY, notes TEXT DEFAULT 'No notes')",
          "fieldConfig": {
            "id": 1,
            "name": "notes",
            "type": "long-text",
            "default": "No notes"
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT value",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='projects' AND column_name='notes'",
            "expected": { "column_default": "'No notes'::text" }
          },
          {
            "description": "INSERT without notes uses default",
            "executeQuery": "INSERT INTO projects (id) VALUES (DEFAULT) RETURNING notes",
            "expected": { "notes": "No notes" }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO projects (notes) VALUES ('Custom notes here') RETURNING notes",
            "expected": { "notes": "Custom notes here" }
          }
        ]
      }
    }
  ]
}
