{
  "$id": "percentage-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Percentage Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "unique": {
      "$ref": "../common/unique/unique.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "const": "percentage"
    },
    "min": {
      "$ref": "./min/min.schema.json"
    },
    "max": {
      "$ref": "./max/max.schema.json"
    },
    "default": {
      "$ref": "./default/default.schema.json"
    }
  },
  "description": "Ratio field displayed as percentage (0-100%). Stores value as decimal (0.0-1.0 or 0-100 depending on configuration). Display adds % symbol automatically. Supports min/max constraints for range validation (typically 0-100). Required flag makes the field mandatory. Useful for completion rates, discounts, and probability values.",
  "required": ["id", "name", "type"],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-PERCENTAGE-FIELD-001",
      "given": "table configuration with percentage field 'completion'",
      "when": "field migration creates column",
      "then": "PostgreSQL NUMERIC(5, 2) column is created for percentage storage (0-100)",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE tasks (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "completion",
            "type": "percentage"
          }
        },
        "assertions": [
          {
            "description": "Column created as NUMERIC(5, 2) for percentage",
            "executeQuery": "SELECT column_name, data_type, numeric_precision, numeric_scale FROM information_schema.columns WHERE table_name='tasks' AND column_name='completion'",
            "expected": {
              "column_name": "completion",
              "data_type": "numeric",
              "numeric_precision": 5,
              "numeric_scale": 2
            }
          },
          {
            "description": "Percentage value can be inserted",
            "executeQuery": "INSERT INTO tasks (completion) VALUES (75.50) RETURNING completion",
            "expected": {
              "completion": "75.50"
            }
          },
          {
            "description": "Zero percentage can be inserted",
            "executeQuery": "INSERT INTO tasks (completion) VALUES (0.00) RETURNING completion",
            "expected": {
              "completion": "0.00"
            }
          },
          {
            "description": "Full completion (100%) can be inserted",
            "executeQuery": "INSERT INTO tasks (completion) VALUES (100.00) RETURNING completion",
            "expected": {
              "completion": "100.00"
            }
          }
        ]
      }
    },
    {
      "id": "APP-PERCENTAGE-FIELD-002",
      "given": "table 'progress_reports' with percentage field 'score' (min=0, max=100)",
      "when": "CHECK constraint enforces 0-100% range",
      "then": "PostgreSQL rejects values outside 0-100 range",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE progress_reports (id SERIAL PRIMARY KEY, score NUMERIC(5, 2) CHECK (score >= 0 AND score <= 100))"
        },
        "assertions": [
          {
            "description": "CHECK constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%score%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Valid percentage within range succeeds",
            "executeQuery": "INSERT INTO progress_reports (score) VALUES (85.25) RETURNING score",
            "expected": {
              "score": "85.25"
            }
          },
          {
            "description": "Negative percentage rejected",
            "executeQuery": "INSERT INTO progress_reports (score) VALUES (-1.00)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Percentage above 100 rejected",
            "executeQuery": "INSERT INTO progress_reports (score) VALUES (100.01)",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-PERCENTAGE-FIELD-003",
      "given": "table 'discounts' with percentage field 'rate' (required, unique)",
      "when": "constraints are applied",
      "then": "PostgreSQL enforces NOT NULL and UNIQUE constraints",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE discounts (id SERIAL PRIMARY KEY, rate NUMERIC(5, 2) UNIQUE NOT NULL)",
            "INSERT INTO discounts (rate) VALUES (15.00)"
          ]
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='discounts' AND column_name='rate'",
            "expected": {
              "is_nullable": "NO"
            }
          },
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='discounts' AND constraint_type='UNIQUE' AND constraint_name LIKE '%rate%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Duplicate percentage rejected",
            "executeQuery": "INSERT INTO discounts (rate) VALUES (15.00)",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "NULL insertion fails",
            "executeQuery": "INSERT INTO discounts (rate) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-PERCENTAGE-FIELD-004",
      "given": "table 'metrics' with percentage field 'success_rate' and default value 0.00",
      "when": "row inserted without providing success_rate value",
      "then": "PostgreSQL applies DEFAULT value 0.00",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE metrics (id SERIAL PRIMARY KEY, success_rate NUMERIC(5, 2) DEFAULT 0.00)",
          "fieldConfig": {
            "id": 1,
            "name": "success_rate",
            "type": "percentage",
            "default": 0
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT value",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='metrics' AND column_name='success_rate'",
            "expected": {
              "column_default": "0.00"
            }
          },
          {
            "description": "INSERT without success_rate uses default",
            "executeQuery": "INSERT INTO metrics (id) VALUES (DEFAULT) RETURNING success_rate",
            "expected": {
              "success_rate": "0.00"
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO metrics (success_rate) VALUES (95.75) RETURNING success_rate",
            "expected": {
              "success_rate": "95.75"
            }
          }
        ]
      }
    },
    {
      "id": "APP-PERCENTAGE-FIELD-005",
      "given": "table configuration with percentage field 'conversion_rate', indexed=true",
      "when": "index is created on the percentage field",
      "then": "PostgreSQL btree index exists for fast percentage queries",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE campaigns (id SERIAL PRIMARY KEY, conversion_rate NUMERIC(5, 2) NOT NULL)",
            "CREATE INDEX idx_campaigns_conversion ON campaigns(conversion_rate)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "conversion_rate",
            "type": "percentage",
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_campaigns_conversion'",
            "expected": {
              "indexname": "idx_campaigns_conversion",
              "tablename": "campaigns"
            }
          },
          {
            "description": "Index uses btree for range queries and sorting",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_campaigns_conversion'",
            "expected": {
              "indexdef": "CREATE INDEX idx_campaigns_conversion ON public.campaigns USING btree (conversion_rate)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-PERCENTAGE-DEFAULT-001",
      "given": "percentage field with default: 0.0",
      "when": "field migration creates column with DEFAULT constraint",
      "then": "PostgreSQL automatically sets value to 0.0 when not provided",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE projects (id SERIAL PRIMARY KEY, name VARCHAR(255), completion DECIMAL(5,2) DEFAULT 0.0)",
            "INSERT INTO projects (name) VALUES ('Project Alpha'), ('Project Beta')"
          ],
          "fieldConfig": {
            "name": "completion",
            "type": "percentage",
            "default": 0
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='projects' AND column_name='completion'",
            "expected": {
              "column_default": "0.0"
            }
          },
          {
            "description": "Default value applied when not provided",
            "executeQuery": "SELECT completion FROM projects WHERE name = 'Project Alpha'",
            "expected": {
              "completion": 0
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO projects (name, completion) VALUES ('Project Gamma', 45.5) RETURNING completion",
            "expected": {
              "completion": 45.5
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-PERCENTAGE-DEFAULT-002",
      "given": "percentage field with default: 15.0 (sales tax rate)",
      "when": "INSERT without value",
      "then": "PostgreSQL uses default value 15.0",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE tax_regions (id SERIAL PRIMARY KEY, region_name VARCHAR(255), tax_rate DECIMAL(5,2) DEFAULT 15.0)",
            "INSERT INTO tax_regions (region_name) VALUES ('Region A')"
          ],
          "fieldConfig": {
            "name": "tax_rate",
            "type": "percentage",
            "default": 15
          }
        },
        "assertions": [
          {
            "description": "Default value is 15.0",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='tax_regions' AND column_name='tax_rate'",
            "expected": {
              "column_default": "15.0"
            }
          },
          {
            "description": "Default applied to inserted record",
            "executeQuery": "SELECT tax_rate FROM tax_regions WHERE region_name = 'Region A'",
            "expected": {
              "tax_rate": 15
            }
          },
          {
            "description": "Explicit 0.0 allowed (overrides default)",
            "executeQuery": "INSERT INTO tax_regions (region_name, tax_rate) VALUES ('Tax-Free Zone', 0.0) RETURNING tax_rate",
            "expected": {
              "tax_rate": 0
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-PERCENTAGE-DEFAULT-003",
      "given": "percentage field with no default specified",
      "when": "INSERT without value",
      "then": "PostgreSQL uses NULL (if nullable) or rejects (if required)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE performance_metrics (id SERIAL PRIMARY KEY, efficiency DECIMAL(5,2))",
            "INSERT INTO performance_metrics (id) VALUES (1)"
          ],
          "fieldConfig": {
            "name": "efficiency",
            "type": "percentage"
          }
        },
        "assertions": [
          {
            "description": "No DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='performance_metrics' AND column_name='efficiency'",
            "expected": {
              "column_default": null
            }
          },
          {
            "description": "NULL used when no default and no value",
            "executeQuery": "SELECT efficiency FROM performance_metrics WHERE id = 1",
            "expected": {
              "efficiency": null
            }
          },
          {
            "description": "Explicit value succeeds",
            "executeQuery": "INSERT INTO performance_metrics (efficiency) VALUES (87.25) RETURNING efficiency",
            "expected": {
              "efficiency": 87.25
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-PERCENTAGE-MAX-001",
      "given": "percentage field with max: 100.0 (standard percentage cap)",
      "when": "field migration creates CHECK constraint",
      "then": "PostgreSQL rejects percentage values above maximum",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE progress_trackers (id SERIAL PRIMARY KEY, task_name VARCHAR(255), completion_rate DECIMAL(5,2) CHECK (completion_rate <= 100.0))",
            "INSERT INTO progress_trackers (task_name, completion_rate) VALUES ('Project A', 25.5), ('Project B', 100.0), ('Project C', 67.75)"
          ],
          "fieldConfig": {
            "name": "completion_rate",
            "type": "percentage",
            "max": 100
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint exists for max value",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%completion_rate%' AND check_clause LIKE '%<= 100.0%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Value at maximum (100.0) accepted",
            "executeQuery": "SELECT completion_rate FROM progress_trackers WHERE completion_rate = 100.0",
            "expected": {
              "completion_rate": 100
            }
          },
          {
            "description": "Value above maximum rejected",
            "executeQuery": "INSERT INTO progress_trackers (task_name, completion_rate) VALUES ('Project D', 100.01)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Decimal value below maximum accepted",
            "executeQuery": "INSERT INTO progress_trackers (task_name, completion_rate) VALUES ('Project E', 82.33) RETURNING completion_rate",
            "expected": {
              "completion_rate": 82.33
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-PERCENTAGE-MAX-002",
      "given": "percentage field with max: 50.0 (discount limit)",
      "when": "INSERT with value above max",
      "then": "PostgreSQL CHECK constraint rejects value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE discount_policies (id SERIAL PRIMARY KEY, policy_name VARCHAR(255), max_discount DECIMAL(5,2) CHECK (max_discount <= 50.0))",
            "INSERT INTO discount_policies (policy_name, max_discount) VALUES ('Regular', 10.0), ('Premium', 50.0)"
          ],
          "fieldConfig": {
            "name": "max_discount",
            "type": "percentage",
            "max": 50
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces max 50.0",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%max_discount%'",
            "expected": {
              "check_clause": "(max_discount <= 50.0)"
            }
          },
          {
            "description": "Exact maximum (50.0) accepted",
            "executeQuery": "SELECT max_discount FROM discount_policies WHERE max_discount = 50.0",
            "expected": {
              "max_discount": 50
            }
          },
          {
            "description": "Above maximum rejected",
            "executeQuery": "INSERT INTO discount_policies (policy_name, max_discount) VALUES ('Excessive', 50.01)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Below maximum accepted",
            "executeQuery": "INSERT INTO discount_policies (policy_name, max_discount) VALUES ('Standard', 25.0) RETURNING max_discount",
            "expected": {
              "max_discount": 25
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-PERCENTAGE-MAX-003",
      "given": "percentage field with both min and max (range constraint)",
      "when": "CHECK constraint combines both",
      "then": "PostgreSQL enforces percentage value within range",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE battery_levels (id SERIAL PRIMARY KEY, device_name VARCHAR(255), charge_level DECIMAL(5,2) CHECK (charge_level >= 0.0 AND charge_level <= 100.0))",
            "INSERT INTO battery_levels (device_name, charge_level) VALUES ('Phone', 0.0), ('Laptop', 55.5), ('Tablet', 100.0)"
          ],
          "fieldConfig": {
            "name": "charge_level",
            "type": "percentage",
            "min": 0,
            "max": 100
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces range 0.0-100.0",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%charge_level%'",
            "expected": {
              "check_clause": "((charge_level >= 0.0) AND (charge_level <= 100.0))"
            }
          },
          {
            "description": "Value at min (0.0) accepted",
            "executeQuery": "SELECT charge_level FROM battery_levels WHERE charge_level = 0.0",
            "expected": {
              "charge_level": 0
            }
          },
          {
            "description": "Value at max (100.0) accepted",
            "executeQuery": "SELECT charge_level FROM battery_levels WHERE charge_level = 100.0",
            "expected": {
              "charge_level": 100
            }
          },
          {
            "description": "Value below min rejected",
            "executeQuery": "INSERT INTO battery_levels (device_name, charge_level) VALUES ('Watch', -0.01)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Value above max rejected",
            "executeQuery": "INSERT INTO battery_levels (device_name, charge_level) VALUES ('Headphones', 100.01)",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-PERCENTAGE-MIN-001",
      "given": "percentage field with min: 0.0 (no negative percentages)",
      "when": "field migration creates CHECK constraint",
      "then": "PostgreSQL rejects percentage values below minimum",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), completion DECIMAL(5,2) CHECK (completion >= 0.0))",
            "INSERT INTO tasks (title, completion) VALUES ('Task 1', 0.0), ('Task 2', 50.5), ('Task 3', 100.0)"
          ],
          "fieldConfig": {
            "name": "completion",
            "type": "percentage",
            "min": 0
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint exists for min value",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%completion%' AND check_clause LIKE '%>= 0.0%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Zero percentage accepted",
            "executeQuery": "SELECT completion FROM tasks WHERE completion = 0.0",
            "expected": {
              "completion": 0
            }
          },
          {
            "description": "Negative percentage rejected",
            "executeQuery": "INSERT INTO tasks (title, completion) VALUES ('Task 4', -5.0)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Positive percentage accepted",
            "executeQuery": "INSERT INTO tasks (title, completion) VALUES ('Task 5', 75.5) RETURNING completion",
            "expected": {
              "completion": 75.5
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-PERCENTAGE-MIN-002",
      "given": "percentage field with min: 10.0 (minimum discount)",
      "when": "INSERT with value below min",
      "then": "PostgreSQL CHECK constraint rejects value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE promotions (id SERIAL PRIMARY KEY, name VARCHAR(255), discount_rate DECIMAL(5,2) CHECK (discount_rate >= 10.0))",
            "INSERT INTO promotions (name, discount_rate) VALUES ('Summer Sale', 15.0), ('Black Friday', 50.0)"
          ],
          "fieldConfig": {
            "name": "discount_rate",
            "type": "percentage",
            "min": 10
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces min 10.0",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%discount_rate%'",
            "expected": {
              "check_clause": "(discount_rate >= 10.0)"
            }
          },
          {
            "description": "Exact minimum (10.0) accepted",
            "executeQuery": "INSERT INTO promotions (name, discount_rate) VALUES ('Spring Sale', 10.0) RETURNING discount_rate",
            "expected": {
              "discount_rate": 10
            }
          },
          {
            "description": "Below minimum rejected",
            "executeQuery": "INSERT INTO promotions (name, discount_rate) VALUES ('Weak Sale', 9.99)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Above minimum accepted",
            "executeQuery": "INSERT INTO promotions (name, discount_rate) VALUES ('Mega Sale', 25.0) RETURNING discount_rate",
            "expected": {
              "discount_rate": 25
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-PERCENTAGE-MIN-003",
      "given": "percentage field with no min specified",
      "when": "negative values inserted (corrections, adjustments)",
      "then": "PostgreSQL accepts all DECIMAL range values",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE financial_adjustments (id SERIAL PRIMARY KEY, adjustment_rate DECIMAL(5,2))",
            "INSERT INTO financial_adjustments (adjustment_rate) VALUES (-15.0), (0.0), (25.0)"
          ],
          "fieldConfig": {
            "name": "adjustment_rate",
            "type": "percentage"
          }
        },
        "assertions": [
          {
            "description": "No CHECK constraint for min",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%adjustment_rate%'",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Negative percentages accepted (adjustments)",
            "executeQuery": "SELECT adjustment_rate FROM financial_adjustments WHERE adjustment_rate = -15.0",
            "expected": {
              "adjustment_rate": -15
            }
          },
          {
            "description": "Large negative adjustment accepted",
            "executeQuery": "INSERT INTO financial_adjustments (adjustment_rate) VALUES (-50.0) RETURNING adjustment_rate",
            "expected": {
              "adjustment_rate": -50
            }
          }
        ]
      }
    }
  ]
}
