{
  "$id": "integer-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Integer Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "unique": {
      "$ref": "../common/unique/unique.schema.json"
    },
    "indexed": {
      "$ref": "../common/indexed/indexed.schema.json"
    },
    "type": {
      "const": "integer"
    },
    "min": {
      "$ref": "./min/min.schema.json"
    },
    "max": {
      "$ref": "./max/max.schema.json"
    },
    "default": {
      "$ref": "./default/default.schema.json"
    }
  },
  "description": "Whole number field without decimal places. Ideal for counts, IDs, quantities, ages, and rankings. Supports min/max constraints for range validation. Required flag makes the field mandatory. Unique constraint ensures no duplicate values. Indexing enables efficient numerical sorting and filtering.",
  "required": [
    "id",
    "name",
    "type"
  ],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-INTEGER-FIELD-001",
      "given": "table configuration with integer field 'quantity'",
      "when": "field migration creates column",
      "then": "PostgreSQL INTEGER column is created (32-bit signed integer)",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE products (id SERIAL PRIMARY KEY)",
          "fieldConfig": {
            "id": 1,
            "name": "quantity",
            "type": "integer"
          }
        },
        "assertions": [
          {
            "description": "Column created as INTEGER type",
            "executeQuery": "SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name='products' AND column_name='quantity'",
            "expected": {
              "column_name": "quantity",
              "data_type": "integer",
              "is_nullable": "YES"
            }
          },
          {
            "description": "Valid integer can be inserted",
            "executeQuery": "INSERT INTO products (quantity) VALUES (42) RETURNING quantity",
            "expected": {
              "quantity": 42
            }
          },
          {
            "description": "Negative integer can be inserted",
            "executeQuery": "INSERT INTO products (quantity) VALUES (-10) RETURNING quantity",
            "expected": {
              "quantity": -10
            }
          }
        ]
      }
    },
    {
      "id": "APP-INTEGER-FIELD-002",
      "given": "table 'inventory' with integer field 'stock' (min=0, max=1000)",
      "when": "CHECK constraint enforces range validation",
      "then": "PostgreSQL rejects values outside min/max range",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE inventory (id SERIAL PRIMARY KEY, stock INTEGER CHECK (stock >= 0 AND stock <= 1000))"
        },
        "assertions": [
          {
            "description": "CHECK constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%stock%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Valid value within range succeeds",
            "executeQuery": "INSERT INTO inventory (stock) VALUES (500) RETURNING stock",
            "expected": {
              "stock": 500
            }
          },
          {
            "description": "Value below min rejected",
            "executeQuery": "INSERT INTO inventory (stock) VALUES (-1)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Value above max rejected",
            "executeQuery": "INSERT INTO inventory (stock) VALUES (1001)",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-INTEGER-FIELD-003",
      "given": "table 'orders' with integer field 'order_number' (required, unique)",
      "when": "constraints are applied",
      "then": "PostgreSQL enforces NOT NULL and UNIQUE constraints",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number INTEGER UNIQUE NOT NULL)",
            "INSERT INTO orders (order_number) VALUES (1001)"
          ]
        },
        "assertions": [
          {
            "description": "NOT NULL constraint enforced",
            "executeQuery": "SELECT is_nullable FROM information_schema.columns WHERE table_name='orders' AND column_name='order_number'",
            "expected": {
              "is_nullable": "NO"
            }
          },
          {
            "description": "UNIQUE constraint exists",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE table_name='orders' AND constraint_type='UNIQUE' AND constraint_name LIKE '%order_number%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Duplicate integer rejected",
            "executeQuery": "INSERT INTO orders (order_number) VALUES (1001)",
            "expectError": "duplicate key value violates unique constraint"
          },
          {
            "description": "NULL insertion fails",
            "executeQuery": "INSERT INTO orders (order_number) VALUES (NULL)",
            "expectError": "violates not-null constraint"
          }
        ]
      }
    },
    {
      "id": "APP-INTEGER-FIELD-004",
      "given": "table 'settings' with integer field 'timeout' and default value 30",
      "when": "row inserted without providing timeout value",
      "then": "PostgreSQL applies DEFAULT value 30",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE settings (id SERIAL PRIMARY KEY, timeout INTEGER DEFAULT 30)",
          "fieldConfig": {
            "id": 1,
            "name": "timeout",
            "type": "integer",
            "default": 30
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT value",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='settings' AND column_name='timeout'",
            "expected": {
              "column_default": "30"
            }
          },
          {
            "description": "INSERT without timeout uses default",
            "executeQuery": "INSERT INTO settings (id) VALUES (DEFAULT) RETURNING timeout",
            "expected": {
              "timeout": 30
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO settings (timeout) VALUES (60) RETURNING timeout",
            "expected": {
              "timeout": 60
            }
          }
        ]
      }
    },
    {
      "id": "APP-INTEGER-FIELD-005",
      "given": "table configuration with integer field 'score', indexed=true",
      "when": "index is created on the integer field",
      "then": "PostgreSQL btree index exists for fast numerical queries",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE leaderboard (id SERIAL PRIMARY KEY, score INTEGER NOT NULL)",
            "CREATE INDEX idx_leaderboard_score ON leaderboard(score)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "score",
            "type": "integer",
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_leaderboard_score'",
            "expected": {
              "indexname": "idx_leaderboard_score",
              "tablename": "leaderboard"
            }
          },
          {
            "description": "Index uses btree for range queries and sorting",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_leaderboard_score'",
            "expected": {
              "indexdef": "CREATE INDEX idx_leaderboard_score ON public.leaderboard USING btree (score)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-INTEGER-DEFAULT-001",
      "given": "integer field with default: 0",
      "when": "field migration creates column with DEFAULT constraint",
      "then": "PostgreSQL automatically sets value to 0 when not provided",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE counters (id SERIAL PRIMARY KEY, name VARCHAR(255), value INTEGER DEFAULT 0)",
            "INSERT INTO counters (name) VALUES ('counter1'), ('counter2')"
          ],
          "fieldConfig": {
            "name": "value",
            "type": "integer",
            "default": 0
          }
        },
        "assertions": [
          {
            "description": "Column has DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='counters' AND column_name='value'",
            "expected": {
              "column_default": "0"
            }
          },
          {
            "description": "Default value applied when not provided",
            "executeQuery": "SELECT value FROM counters WHERE name = 'counter1'",
            "expected": {
              "value": 0
            }
          },
          {
            "description": "Explicit value overrides default",
            "executeQuery": "INSERT INTO counters (name, value) VALUES ('counter3', 42) RETURNING value",
            "expected": {
              "value": 42
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-INTEGER-DEFAULT-002",
      "given": "integer field with default: 100",
      "when": "INSERT without value",
      "then": "PostgreSQL uses default value 100",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, name VARCHAR(255), stock INTEGER DEFAULT 100)",
            "INSERT INTO products (name) VALUES ('Product 1')"
          ],
          "fieldConfig": {
            "name": "stock",
            "type": "integer",
            "default": 100
          }
        },
        "assertions": [
          {
            "description": "Default value is 100",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='products' AND column_name='stock'",
            "expected": {
              "column_default": "100"
            }
          },
          {
            "description": "Default applied to inserted record",
            "executeQuery": "SELECT stock FROM products WHERE name = 'Product 1'",
            "expected": {
              "stock": 100
            }
          },
          {
            "description": "Explicit 0 allowed (overrides default)",
            "executeQuery": "INSERT INTO products (name, stock) VALUES ('Product 2', 0) RETURNING stock",
            "expected": {
              "stock": 0
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-INTEGER-DEFAULT-003",
      "given": "integer field with no default specified",
      "when": "INSERT without value",
      "then": "PostgreSQL uses NULL (if nullable) or rejects (if required)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE items (id SERIAL PRIMARY KEY, quantity INTEGER)",
            "INSERT INTO items (id) VALUES (1)"
          ],
          "fieldConfig": {
            "name": "quantity",
            "type": "integer"
          }
        },
        "assertions": [
          {
            "description": "No DEFAULT constraint",
            "executeQuery": "SELECT column_default FROM information_schema.columns WHERE table_name='items' AND column_name='quantity'",
            "expected": {
              "column_default": null
            }
          },
          {
            "description": "NULL used when no default and no value",
            "executeQuery": "SELECT quantity FROM items WHERE id = 1",
            "expected": {
              "quantity": null
            }
          },
          {
            "description": "Explicit value succeeds",
            "executeQuery": "INSERT INTO items (quantity) VALUES (5) RETURNING quantity",
            "expected": {
              "quantity": 5
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-INTEGER-MAX-001",
      "given": "integer field with max: 100",
      "when": "field migration creates CHECK constraint",
      "then": "PostgreSQL rejects values above maximum",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE quiz_scores (id SERIAL PRIMARY KEY, student_name VARCHAR(255), score INTEGER CHECK (score <= 100))",
            "INSERT INTO quiz_scores (student_name, score) VALUES ('Alice', 85), ('Bob', 100)"
          ],
          "fieldConfig": {
            "name": "score",
            "type": "integer",
            "max": 100
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint exists for max value",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%score%' AND check_clause LIKE '%<= 100%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Value at maximum (100) accepted",
            "executeQuery": "SELECT score FROM quiz_scores WHERE score = 100",
            "expected": {
              "score": 100
            }
          },
          {
            "description": "Value above maximum rejected",
            "executeQuery": "INSERT INTO quiz_scores (student_name, score) VALUES ('Charlie', 101)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Value below maximum accepted",
            "executeQuery": "INSERT INTO quiz_scores (student_name, score) VALUES ('Diana', 75) RETURNING score",
            "expected": {
              "score": 75
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-INTEGER-MAX-002",
      "given": "integer field with max: 5 (rating)",
      "when": "INSERT with value above max",
      "then": "PostgreSQL CHECK constraint rejects value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE reviews (id SERIAL PRIMARY KEY, product_name VARCHAR(255), rating INTEGER CHECK (rating <= 5))",
            "INSERT INTO reviews (product_name, rating) VALUES ('Product A', 4)"
          ],
          "fieldConfig": {
            "name": "rating",
            "type": "integer",
            "max": 5
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces max rating 5",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%rating%'",
            "expected": {
              "check_clause": "(rating <= 5)"
            }
          },
          {
            "description": "Rating 5 (exact maximum) accepted",
            "executeQuery": "INSERT INTO reviews (product_name, rating) VALUES ('Product B', 5) RETURNING rating",
            "expected": {
              "rating": 5
            }
          },
          {
            "description": "Rating 6 (above maximum) rejected",
            "executeQuery": "INSERT INTO reviews (product_name, rating) VALUES ('Product C', 6)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Rating 1 (below maximum) accepted",
            "executeQuery": "INSERT INTO reviews (product_name, rating) VALUES ('Product D', 1) RETURNING rating",
            "expected": {
              "rating": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-INTEGER-MAX-003",
      "given": "integer field with both min and max (range constraint)",
      "when": "CHECK constraint combines both",
      "then": "PostgreSQL enforces value within range",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE settings (id SERIAL PRIMARY KEY, volume INTEGER CHECK (volume >= 0 AND volume <= 100))",
            "INSERT INTO settings (volume) VALUES (0), (50), (100)"
          ],
          "fieldConfig": {
            "name": "volume",
            "type": "integer",
            "min": 0,
            "max": 100
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces range 0-100",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%volume%'",
            "expected": {
              "check_clause": "((volume >= 0) AND (volume <= 100))"
            }
          },
          {
            "description": "Value at min (0) accepted",
            "executeQuery": "SELECT volume FROM settings WHERE volume = 0",
            "expected": {
              "volume": 0
            }
          },
          {
            "description": "Value at max (100) accepted",
            "executeQuery": "SELECT volume FROM settings WHERE volume = 100",
            "expected": {
              "volume": 100
            }
          },
          {
            "description": "Value below min rejected",
            "executeQuery": "INSERT INTO settings (volume) VALUES (-1)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Value above max rejected",
            "executeQuery": "INSERT INTO settings (volume) VALUES (101)",
            "expectError": "violates check constraint"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-INTEGER-MIN-001",
      "given": "integer field with min: 0",
      "when": "field migration creates CHECK constraint",
      "then": "PostgreSQL rejects values below minimum",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, stock INTEGER CHECK (stock >= 0))",
            "INSERT INTO products (stock) VALUES (0), (10), (100)"
          ],
          "fieldConfig": {
            "name": "stock",
            "type": "integer",
            "min": 0
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint exists for min value",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%stock%' AND check_clause LIKE '%>= 0%'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Value at minimum (0) accepted",
            "executeQuery": "SELECT stock FROM products WHERE stock = 0",
            "expected": {
              "stock": 0
            }
          },
          {
            "description": "Value below minimum rejected",
            "executeQuery": "INSERT INTO products (stock) VALUES (-1)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Value above minimum accepted",
            "executeQuery": "INSERT INTO products (stock) VALUES (50) RETURNING stock",
            "expected": {
              "stock": 50
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-INTEGER-MIN-002",
      "given": "integer field with min: 18 (age restriction)",
      "when": "INSERT with value below min",
      "then": "PostgreSQL CHECK constraint rejects value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255), age INTEGER CHECK (age >= 18))",
            "INSERT INTO users (name, age) VALUES ('Alice', 25)"
          ],
          "fieldConfig": {
            "name": "age",
            "type": "integer",
            "min": 18
          }
        },
        "assertions": [
          {
            "description": "CHECK constraint enforces min age 18",
            "executeQuery": "SELECT check_clause FROM information_schema.check_constraints WHERE constraint_name LIKE '%age%'",
            "expected": {
              "check_clause": "(age >= 18)"
            }
          },
          {
            "description": "Age 18 (exact minimum) accepted",
            "executeQuery": "INSERT INTO users (name, age) VALUES ('Bob', 18) RETURNING age",
            "expected": {
              "age": 18
            }
          },
          {
            "description": "Age 17 (below minimum) rejected",
            "executeQuery": "INSERT INTO users (name, age) VALUES ('Charlie', 17)",
            "expectError": "violates check constraint"
          },
          {
            "description": "Age 65 (above minimum) accepted",
            "executeQuery": "INSERT INTO users (name, age) VALUES ('Diana', 65) RETURNING age",
            "expected": {
              "age": 65
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-INTEGER-MIN-003",
      "given": "integer field with no min specified",
      "when": "any integer value inserted",
      "then": "PostgreSQL accepts all INTEGER range values",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE readings (id SERIAL PRIMARY KEY, temperature INTEGER)",
            "INSERT INTO readings (temperature) VALUES (-273), (0), (100)"
          ],
          "fieldConfig": {
            "name": "temperature",
            "type": "integer"
          }
        },
        "assertions": [
          {
            "description": "No CHECK constraint for min",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.check_constraints WHERE constraint_name LIKE '%temperature%'",
            "expected": {
              "count": 0
            }
          },
          {
            "description": "Negative values accepted",
            "executeQuery": "SELECT temperature FROM readings WHERE temperature = -273",
            "expected": {
              "temperature": -273
            }
          },
          {
            "description": "Very low value accepted (within INTEGER range)",
            "executeQuery": "INSERT INTO readings (temperature) VALUES (-2147483648) RETURNING temperature",
            "expected": {
              "temperature": -2147483648
            }
          }
        ]
      }
    }
  ]
}
