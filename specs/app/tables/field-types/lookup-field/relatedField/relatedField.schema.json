{
  "$id": "relatedField.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Name of the field in the related table to display",
  "description": "Name of the field in the related table to fetch and display. Lookup fields use PostgreSQL VIEWs with LEFT JOIN to fetch this field value from the related table through the specified relationship.",
  "type": "string",
  "minLength": 1,
  "x-specs": [
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-001",
      "given": "lookup field with relatedField: 'email' (from customers table)",
      "when": "VIEW joins through relationship to fetch field",
      "then": "PostgreSQL VIEW includes email column from related customers table",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255))",
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number VARCHAR(50), customer_id INTEGER REFERENCES customers(id))",
            "CREATE VIEW orders_with_email AS SELECT o.*, c.email as customer_email FROM orders o LEFT JOIN customers c ON o.customer_id = c.id",
            "INSERT INTO customers (name, email) VALUES ('Alice', 'alice@example.com'), ('Bob', 'bob@example.com')",
            "INSERT INTO orders (order_number, customer_id) VALUES ('ORD-001', 1), ('ORD-002', 2)"
          ],
          "fieldConfig": {
            "name": "customer_email",
            "type": "lookup",
            "relationshipField": "customer_id",
            "relatedField": "email"
          }
        },
        "assertions": [
          {
            "description": "VIEW column shows related table's email field",
            "executeQuery": "SELECT order_number, customer_email FROM orders_with_email WHERE order_number = 'ORD-001'",
            "expected": {
              "order_number": "ORD-001",
              "customer_email": "alice@example.com"
            }
          },
          {
            "description": "Lookup value updates when related record's field changes",
            "executeQuery": [
              "UPDATE customers SET email = 'alice.updated@example.com' WHERE id = 1",
              "SELECT customer_email FROM orders_with_email WHERE order_number = 'ORD-001'"
            ],
            "expected": {
              "customer_email": "alice.updated@example.com"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-002",
      "given": "lookup field with relatedField: 'name' (from departments table)",
      "when": "VIEW fetches department name for employees",
      "then": "PostgreSQL VIEW shows department name instead of just ID",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE departments (id SERIAL PRIMARY KEY, name VARCHAR(255), location VARCHAR(255))",
            "CREATE TABLE employees (id SERIAL PRIMARY KEY, emp_name VARCHAR(255), department_id INTEGER REFERENCES departments(id))",
            "CREATE VIEW employees_with_dept AS SELECT e.*, d.name as department_name FROM employees e LEFT JOIN departments d ON e.department_id = d.id",
            "INSERT INTO departments (name, location) VALUES ('Engineering', 'Building A'), ('Sales', 'Building B')",
            "INSERT INTO employees (emp_name, department_id) VALUES ('Alice', 1), ('Bob', 2), ('Charlie', 1)"
          ],
          "fieldConfig": {
            "name": "department_name",
            "type": "lookup",
            "relationshipField": "department_id",
            "relatedField": "name"
          }
        },
        "assertions": [
          {
            "description": "Lookup shows department name for first employee",
            "executeQuery": "SELECT emp_name, department_name FROM employees_with_dept WHERE emp_name = 'Alice'",
            "expected": {
              "emp_name": "Alice",
              "department_name": "Engineering"
            }
          },
          {
            "description": "Different employee shows different department name",
            "executeQuery": "SELECT emp_name, department_name FROM employees_with_dept WHERE emp_name = 'Bob'",
            "expected": {
              "emp_name": "Bob",
              "department_name": "Sales"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-003",
      "given": "lookup field with relatedField referencing non-existent column",
      "when": "VIEW creation attempts to select non-existent field",
      "then": "PostgreSQL returns error for undefined column in related table",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE categories (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE products (id SERIAL PRIMARY KEY, product_name VARCHAR(255), category_id INTEGER REFERENCES categories(id))",
            "CREATE VIEW products_with_lookup AS SELECT p.*, c.nonexistent_field FROM products p LEFT JOIN categories c ON p.category_id = c.id"
          ],
          "fieldConfig": {
            "name": "category_field",
            "type": "lookup",
            "relationshipField": "category_id",
            "relatedField": "nonexistent_field"
          }
        },
        "assertions": [
          {
            "description": "VIEW creation with non-existent relatedField fails",
            "executeQuery": "CREATE VIEW products_with_lookup AS SELECT p.*, c.nonexistent_field FROM products p LEFT JOIN categories c ON p.category_id = c.id",
            "expectError": "column \"nonexistent_field\" does not exist"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-004",
      "given": "lookup field with empty relatedField value",
      "when": "field configuration validation runs",
      "then": "error should require minimum length 1 character",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "customer_email",
            "type": "lookup",
            "relationshipField": "customer_id",
            "relatedField": ""
          }
        },
        "assertions": [
          {
            "description": "Empty relatedField rejected",
            "validateConfig": true,
            "expectError": "relatedField must have at least 1 character"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-005",
      "given": "lookup field with relatedField: numeric type (price from products)",
      "when": "VIEW fetches numeric field from related table",
      "then": "PostgreSQL VIEW preserves numeric type in lookup column",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, name VARCHAR(255), base_price DECIMAL(10,2))",
            "CREATE TABLE order_items (id SERIAL PRIMARY KEY, quantity INTEGER, product_id INTEGER REFERENCES products(id))",
            "CREATE VIEW order_items_with_price AS SELECT oi.*, p.base_price as product_price FROM order_items oi LEFT JOIN products p ON oi.product_id = p.id",
            "INSERT INTO products (name, base_price) VALUES ('Laptop', 999.99), ('Mouse', 29.99)",
            "INSERT INTO order_items (quantity, product_id) VALUES (2, 1), (5, 2)"
          ],
          "fieldConfig": {
            "name": "product_price",
            "type": "lookup",
            "relationshipField": "product_id",
            "relatedField": "base_price"
          }
        },
        "assertions": [
          {
            "description": "Lookup field shows numeric price value",
            "executeQuery": "SELECT quantity, product_price FROM order_items_with_price WHERE quantity = 2",
            "expected": {
              "quantity": 2,
              "product_price": 999.99
            }
          },
          {
            "description": "Lookup field maintains DECIMAL type",
            "executeQuery": "SELECT data_type FROM information_schema.columns WHERE table_name = 'products' AND column_name = 'base_price'",
            "expected": {
              "data_type": "numeric"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-006",
      "given": "lookup field with relatedField: boolean type (is_active from users)",
      "when": "VIEW fetches boolean field from related table",
      "then": "PostgreSQL VIEW preserves boolean type in lookup column",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, username VARCHAR(255), is_active BOOLEAN DEFAULT true)",
            "CREATE TABLE sessions (id SERIAL PRIMARY KEY, session_token VARCHAR(255), user_id INTEGER REFERENCES users(id))",
            "CREATE VIEW sessions_with_status AS SELECT s.*, u.is_active as user_active FROM sessions s LEFT JOIN users u ON s.user_id = u.id",
            "INSERT INTO users (username, is_active) VALUES ('alice', true), ('bob', false)",
            "INSERT INTO sessions (session_token, user_id) VALUES ('token-abc', 1), ('token-xyz', 2)"
          ],
          "fieldConfig": {
            "name": "user_active",
            "type": "lookup",
            "relationshipField": "user_id",
            "relatedField": "is_active"
          }
        },
        "assertions": [
          {
            "description": "Lookup shows true for active user",
            "executeQuery": "SELECT session_token, user_active FROM sessions_with_status WHERE session_token = 'token-abc'",
            "expected": {
              "session_token": "token-abc",
              "user_active": true
            }
          },
          {
            "description": "Lookup shows false for inactive user",
            "executeQuery": "SELECT session_token, user_active FROM sessions_with_status WHERE session_token = 'token-xyz'",
            "expected": {
              "session_token": "token-xyz",
              "user_active": false
            }
          }
        ]
      }
    }
  ]
}
