{
  "$id": "lookup-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Lookup Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "type": {
      "type": "string",
      "const": "lookup"
    },
    "relationshipField": {
      "$ref": "./relationshipField/relationshipField.schema.json"
    },
    "relatedField": {
      "$ref": "./relatedField/relatedField.schema.json"
    }
  },
  "description": "Display field values from related records through a relationship. Specify relationshipField (the relationship field in current table) and relatedField (the field to display from related table). Read-only field that automatically shows current value from linked record. Updates when related record changes. Useful for showing related data without duplicating storage (e.g., showing customer name in order, category name in product). More efficient than copying data.",
  "required": [
    "id",
    "name",
    "type",
    "relationshipField",
    "relatedField"
  ],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-LOOKUP-FIELD-001",
      "given": "table 'orders' with lookup field 'customer_name' through 'customer_id' relationship",
      "when": "querying with JOIN to retrieve related field",
      "then": "PostgreSQL JOIN returns customer name from related table",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255))",
            "INSERT INTO customers (name, email) VALUES ('Alice Johnson', 'alice@example.com'), ('Bob Smith', 'bob@example.com')",
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, customer_id INTEGER REFERENCES customers(id), amount DECIMAL(10,2))",
            "INSERT INTO orders (customer_id, amount) VALUES (1, 150.00), (2, 200.00), (1, 75.50)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "customer_name",
            "type": "lookup",
            "relationshipField": "customer_id",
            "relatedField": "name"
          }
        },
        "assertions": [
          {
            "description": "Lookup retrieves customer name via JOIN",
            "executeQuery": "SELECT o.id, c.name as customer_name FROM orders o JOIN customers c ON o.customer_id = c.id WHERE o.id = 1",
            "expected": {
              "id": 1,
              "customer_name": "Alice Johnson"
            }
          },
          {
            "description": "Multiple orders lookup same customer",
            "executeQuery": "SELECT COUNT(*) as count FROM orders o JOIN customers c ON o.customer_id = c.id WHERE c.name = 'Alice Johnson'",
            "expected": {
              "count": 2
            }
          },
          {
            "description": "Lookup returns all related records",
            "executeQuery": "SELECT o.id, c.name as customer_name FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.id",
            "expected": [
              {
                "id": 1,
                "customer_name": "Alice Johnson"
              },
              {
                "id": 2,
                "customer_name": "Bob Smith"
              },
              {
                "id": 3,
                "customer_name": "Alice Johnson"
              }
            ]
          }
        ]
      }
    },
    {
      "id": "APP-LOOKUP-FIELD-002",
      "given": "table 'tasks' with multiple lookup fields through same relationship",
      "when": "querying multiple related fields via JOIN",
      "then": "PostgreSQL JOIN returns all specified lookup fields",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255), department VARCHAR(100))",
            "INSERT INTO users (name, email, department) VALUES ('John Doe', 'john@company.com', 'Engineering')",
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), assigned_to INTEGER REFERENCES users(id))",
            "INSERT INTO tasks (title, assigned_to) VALUES ('Fix bug', 1), ('Write docs', 1)"
          ],
          "fieldConfig": [
            {
              "id": 1,
              "name": "assignee_name",
              "type": "lookup",
              "relationshipField": "assigned_to",
              "relatedField": "name"
            },
            {
              "id": 2,
              "name": "assignee_email",
              "type": "lookup",
              "relationshipField": "assigned_to",
              "relatedField": "email"
            },
            {
              "id": 3,
              "name": "assignee_department",
              "type": "lookup",
              "relationshipField": "assigned_to",
              "relatedField": "department"
            }
          ]
        },
        "assertions": [
          {
            "description": "Single JOIN retrieves all lookup fields",
            "executeQuery": "SELECT t.id, u.name as assignee_name, u.email as assignee_email, u.department as assignee_department FROM tasks t JOIN users u ON t.assigned_to = u.id WHERE t.id = 1",
            "expected": {
              "id": 1,
              "assignee_name": "John Doe",
              "assignee_email": "john@company.com",
              "assignee_department": "Engineering"
            }
          }
        ]
      }
    },
    {
      "id": "APP-LOOKUP-FIELD-003",
      "given": "table configuration with lookup field 'product_category' defined as VIEW",
      "when": "VIEW is created to encapsulate lookup logic",
      "then": "PostgreSQL VIEW provides lookup field alongside base table columns",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE categories (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "INSERT INTO categories (name) VALUES ('Electronics'), ('Clothing')",
            "CREATE TABLE products (id SERIAL PRIMARY KEY, title VARCHAR(255), category_id INTEGER REFERENCES categories(id))",
            "INSERT INTO products (title, category_id) VALUES ('Laptop', 1), ('T-Shirt', 2)",
            "CREATE VIEW products_with_category AS SELECT p.id, p.title, p.category_id, c.name as product_category FROM products p LEFT JOIN categories c ON p.category_id = c.id"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "product_category",
            "type": "lookup",
            "relationshipField": "category_id",
            "relatedField": "name"
          }
        },
        "assertions": [
          {
            "description": "VIEW exists in information_schema",
            "executeQuery": "SELECT table_name FROM information_schema.views WHERE table_name = 'products_with_category'",
            "expected": {
              "table_name": "products_with_category"
            }
          },
          {
            "description": "VIEW returns lookup field with base columns",
            "executeQuery": "SELECT id, title, product_category FROM products_with_category WHERE id = 1",
            "expected": {
              "id": 1,
              "title": "Laptop",
              "product_category": "Electronics"
            }
          },
          {
            "description": "VIEW supports filtering by lookup field",
            "executeQuery": "SELECT COUNT(*) as count FROM products_with_category WHERE product_category = 'Electronics'",
            "expected": {
              "count": 1
            }
          }
        ]
      }
    },
    {
      "id": "APP-LOOKUP-FIELD-004",
      "given": "table 'invoices' with lookup field when relationship is NULL",
      "when": "LEFT JOIN is used for optional relationships",
      "then": "PostgreSQL returns NULL for lookup when foreign key is NULL",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE companies (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "INSERT INTO companies (name) VALUES ('Acme Corp')",
            "CREATE TABLE invoices (id SERIAL PRIMARY KEY, invoice_number VARCHAR(50), company_id INTEGER REFERENCES companies(id))",
            "INSERT INTO invoices (invoice_number, company_id) VALUES ('INV-001', 1), ('INV-002', NULL)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "company_name",
            "type": "lookup",
            "relationshipField": "company_id",
            "relatedField": "name"
          }
        },
        "assertions": [
          {
            "description": "Lookup returns value when relationship exists",
            "executeQuery": "SELECT i.invoice_number, c.name as company_name FROM invoices i LEFT JOIN companies c ON i.company_id = c.id WHERE i.invoice_number = 'INV-001'",
            "expected": {
              "invoice_number": "INV-001",
              "company_name": "Acme Corp"
            }
          },
          {
            "description": "Lookup returns NULL when relationship is NULL",
            "executeQuery": "SELECT i.invoice_number, c.name as company_name FROM invoices i LEFT JOIN companies c ON i.company_id = c.id WHERE i.invoice_number = 'INV-002'",
            "expected": {
              "invoice_number": "INV-002",
              "company_name": null
            }
          },
          {
            "description": "LEFT JOIN preserves records with NULL relationships",
            "executeQuery": "SELECT COUNT(*) as count FROM invoices i LEFT JOIN companies c ON i.company_id = c.id",
            "expected": {
              "count": 2
            }
          }
        ]
      }
    },
    {
      "id": "APP-LOOKUP-FIELD-005",
      "given": "table 'line_items' with lookup field 'product_price' from products table",
      "when": "related product price is updated",
      "then": "lookup reflects the updated value immediately",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, name VARCHAR(255), price DECIMAL(10,2))",
            "INSERT INTO products (name, price) VALUES ('Widget', 19.99)",
            "CREATE TABLE line_items (id SERIAL PRIMARY KEY, product_id INTEGER REFERENCES products(id), quantity INTEGER)",
            "INSERT INTO line_items (product_id, quantity) VALUES (1, 5)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "product_price",
            "type": "lookup",
            "relationshipField": "product_id",
            "relatedField": "price"
          }
        },
        "assertions": [
          {
            "description": "Initial lookup returns original price",
            "executeQuery": "SELECT li.id, p.price as product_price FROM line_items li JOIN products p ON li.product_id = p.id WHERE li.id = 1",
            "expected": {
              "id": 1,
              "product_price": "19.99"
            }
          },
          {
            "description": "Update related product price",
            "executeQuery": "UPDATE products SET price = 24.99 WHERE id = 1",
            "expected": {}
          },
          {
            "description": "Lookup automatically reflects updated price",
            "executeQuery": "SELECT li.id, p.price as product_price FROM line_items li JOIN products p ON li.product_id = p.id WHERE li.id = 1",
            "expected": {
              "id": 1,
              "product_price": "24.99"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-001",
      "given": "lookup field with relatedField: 'email' (from customers table)",
      "when": "VIEW joins through relationship to fetch field",
      "then": "PostgreSQL VIEW includes email column from related customers table",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255))",
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number VARCHAR(50), customer_id INTEGER REFERENCES customers(id))",
            "CREATE VIEW orders_with_email AS SELECT o.*, c.email as customer_email FROM orders o LEFT JOIN customers c ON o.customer_id = c.id",
            "INSERT INTO customers (name, email) VALUES ('Alice', 'alice@example.com'), ('Bob', 'bob@example.com')",
            "INSERT INTO orders (order_number, customer_id) VALUES ('ORD-001', 1), ('ORD-002', 2)"
          ],
          "fieldConfig": {
            "name": "customer_email",
            "type": "lookup",
            "relationshipField": "customer_id",
            "relatedField": "email"
          }
        },
        "assertions": [
          {
            "description": "VIEW column shows related table's email field",
            "executeQuery": "SELECT order_number, customer_email FROM orders_with_email WHERE order_number = 'ORD-001'",
            "expected": {
              "order_number": "ORD-001",
              "customer_email": "alice@example.com"
            }
          },
          {
            "description": "Lookup value updates when related record's field changes",
            "executeQuery": [
              "UPDATE customers SET email = 'alice.updated@example.com' WHERE id = 1",
              "SELECT customer_email FROM orders_with_email WHERE order_number = 'ORD-001'"
            ],
            "expected": {
              "customer_email": "alice.updated@example.com"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-002",
      "given": "lookup field with relatedField: 'name' (from departments table)",
      "when": "VIEW fetches department name for employees",
      "then": "PostgreSQL VIEW shows department name instead of just ID",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE departments (id SERIAL PRIMARY KEY, name VARCHAR(255), location VARCHAR(255))",
            "CREATE TABLE employees (id SERIAL PRIMARY KEY, emp_name VARCHAR(255), department_id INTEGER REFERENCES departments(id))",
            "CREATE VIEW employees_with_dept AS SELECT e.*, d.name as department_name FROM employees e LEFT JOIN departments d ON e.department_id = d.id",
            "INSERT INTO departments (name, location) VALUES ('Engineering', 'Building A'), ('Sales', 'Building B')",
            "INSERT INTO employees (emp_name, department_id) VALUES ('Alice', 1), ('Bob', 2), ('Charlie', 1)"
          ],
          "fieldConfig": {
            "name": "department_name",
            "type": "lookup",
            "relationshipField": "department_id",
            "relatedField": "name"
          }
        },
        "assertions": [
          {
            "description": "Lookup shows department name for first employee",
            "executeQuery": "SELECT emp_name, department_name FROM employees_with_dept WHERE emp_name = 'Alice'",
            "expected": {
              "emp_name": "Alice",
              "department_name": "Engineering"
            }
          },
          {
            "description": "Different employee shows different department name",
            "executeQuery": "SELECT emp_name, department_name FROM employees_with_dept WHERE emp_name = 'Bob'",
            "expected": {
              "emp_name": "Bob",
              "department_name": "Sales"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-003",
      "given": "lookup field with relatedField referencing non-existent column",
      "when": "VIEW creation attempts to select non-existent field",
      "then": "PostgreSQL returns error for undefined column in related table",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE categories (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE products (id SERIAL PRIMARY KEY, product_name VARCHAR(255), category_id INTEGER REFERENCES categories(id))",
            "CREATE VIEW products_with_lookup AS SELECT p.*, c.nonexistent_field FROM products p LEFT JOIN categories c ON p.category_id = c.id"
          ],
          "fieldConfig": {
            "name": "category_field",
            "type": "lookup",
            "relationshipField": "category_id",
            "relatedField": "nonexistent_field"
          }
        },
        "assertions": [
          {
            "description": "VIEW creation with non-existent relatedField fails",
            "executeQuery": "CREATE VIEW products_with_lookup AS SELECT p.*, c.nonexistent_field FROM products p LEFT JOIN categories c ON p.category_id = c.id",
            "expectError": "column \"nonexistent_field\" does not exist"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-004",
      "given": "lookup field with empty relatedField value",
      "when": "field configuration validation runs",
      "then": "error should require minimum length 1 character",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "customer_email",
            "type": "lookup",
            "relationshipField": "customer_id",
            "relatedField": ""
          }
        },
        "assertions": [
          {
            "description": "Empty relatedField rejected",
            "validateConfig": true,
            "expectError": "relatedField must have at least 1 character"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-005",
      "given": "lookup field with relatedField: numeric type (price from products)",
      "when": "VIEW fetches numeric field from related table",
      "then": "PostgreSQL VIEW preserves numeric type in lookup column",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, name VARCHAR(255), base_price DECIMAL(10,2))",
            "CREATE TABLE order_items (id SERIAL PRIMARY KEY, quantity INTEGER, product_id INTEGER REFERENCES products(id))",
            "CREATE VIEW order_items_with_price AS SELECT oi.*, p.base_price as product_price FROM order_items oi LEFT JOIN products p ON oi.product_id = p.id",
            "INSERT INTO products (name, base_price) VALUES ('Laptop', 999.99), ('Mouse', 29.99)",
            "INSERT INTO order_items (quantity, product_id) VALUES (2, 1), (5, 2)"
          ],
          "fieldConfig": {
            "name": "product_price",
            "type": "lookup",
            "relationshipField": "product_id",
            "relatedField": "base_price"
          }
        },
        "assertions": [
          {
            "description": "Lookup field shows numeric price value",
            "executeQuery": "SELECT quantity, product_price FROM order_items_with_price WHERE quantity = 2",
            "expected": {
              "quantity": 2,
              "product_price": 999.99
            }
          },
          {
            "description": "Lookup field maintains DECIMAL type",
            "executeQuery": "SELECT data_type FROM information_schema.columns WHERE table_name = 'products' AND column_name = 'base_price'",
            "expected": {
              "data_type": "numeric"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATEDFIELD-006",
      "given": "lookup field with relatedField: boolean type (is_active from users)",
      "when": "VIEW fetches boolean field from related table",
      "then": "PostgreSQL VIEW preserves boolean type in lookup column",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, username VARCHAR(255), is_active BOOLEAN DEFAULT true)",
            "CREATE TABLE sessions (id SERIAL PRIMARY KEY, session_token VARCHAR(255), user_id INTEGER REFERENCES users(id))",
            "CREATE VIEW sessions_with_status AS SELECT s.*, u.is_active as user_active FROM sessions s LEFT JOIN users u ON s.user_id = u.id",
            "INSERT INTO users (username, is_active) VALUES ('alice', true), ('bob', false)",
            "INSERT INTO sessions (session_token, user_id) VALUES ('token-abc', 1), ('token-xyz', 2)"
          ],
          "fieldConfig": {
            "name": "user_active",
            "type": "lookup",
            "relationshipField": "user_id",
            "relatedField": "is_active"
          }
        },
        "assertions": [
          {
            "description": "Lookup shows true for active user",
            "executeQuery": "SELECT session_token, user_active FROM sessions_with_status WHERE session_token = 'token-abc'",
            "expected": {
              "session_token": "token-abc",
              "user_active": true
            }
          },
          {
            "description": "Lookup shows false for inactive user",
            "executeQuery": "SELECT session_token, user_active FROM sessions_with_status WHERE session_token = 'token-xyz'",
            "expected": {
              "session_token": "token-xyz",
              "user_active": false
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATIONSHIPFIELD-001",
      "given": "lookup field with relationshipField: 'customer_id' (existing FK)",
      "when": "field migration creates VIEW or trigger-based lookup",
      "then": "PostgreSQL VIEW joins through relationship to fetch lookup values",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255), city VARCHAR(255))",
            "CREATE TABLE orders (id SERIAL PRIMARY KEY, order_number VARCHAR(50), customer_id INTEGER REFERENCES customers(id))",
            "CREATE VIEW orders_with_lookup AS SELECT o.*, c.email as customer_email FROM orders o LEFT JOIN customers c ON o.customer_id = c.id",
            "INSERT INTO customers (name, email, city) VALUES ('Alice', 'alice@example.com', 'New York'), ('Bob', 'bob@example.com', 'Los Angeles')",
            "INSERT INTO orders (order_number, customer_id) VALUES ('ORD-001', 1), ('ORD-002', 2)"
          ],
          "fieldConfig": {
            "name": "customer_email",
            "type": "lookup",
            "relationshipField": "customer_id",
            "relatedField": "email"
          }
        },
        "assertions": [
          {
            "description": "Base table has foreign key relationship",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.table_constraints WHERE constraint_type = 'FOREIGN KEY' AND table_name = 'orders'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "VIEW exists with lookup field",
            "executeQuery": "SELECT COUNT(*) as count FROM information_schema.views WHERE table_name = 'orders_with_lookup'",
            "expected": {
              "count": 1
            }
          },
          {
            "description": "Lookup field fetches value through relationship",
            "executeQuery": "SELECT order_number, customer_email FROM orders_with_lookup WHERE order_number = 'ORD-001'",
            "expected": {
              "order_number": "ORD-001",
              "customer_email": "alice@example.com"
            }
          },
          {
            "description": "Lookup field updates when related record changes",
            "executeQuery": [
              "UPDATE customers SET email = 'alice.new@example.com' WHERE id = 1",
              "SELECT customer_email FROM orders_with_lookup WHERE order_number = 'ORD-001'"
            ],
            "expected": {
              "customer_email": "alice.new@example.com"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATIONSHIPFIELD-002",
      "given": "lookup field with relationshipField referencing non-existent field",
      "when": "VIEW creation attempts to join on non-existent column",
      "then": "PostgreSQL returns error for undefined column",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE departments (id SERIAL PRIMARY KEY, name VARCHAR(255))",
            "CREATE TABLE employees (id SERIAL PRIMARY KEY, emp_name VARCHAR(255))",
            "CREATE VIEW employees_with_lookup AS SELECT e.*, d.name as department_name FROM employees e LEFT JOIN departments d ON e.nonexistent_field = d.id"
          ],
          "fieldConfig": {
            "name": "department_name",
            "type": "lookup",
            "relationshipField": "nonexistent_field",
            "relatedField": "name"
          }
        },
        "assertions": [
          {
            "description": "VIEW creation with non-existent relationship field fails",
            "executeQuery": "CREATE VIEW employees_with_lookup AS SELECT e.*, d.name as department_name FROM employees e LEFT JOIN departments d ON e.nonexistent_field = d.id",
            "expectError": "column \"nonexistent_field\" does not exist"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATIONSHIPFIELD-003",
      "given": "lookup field with empty relationshipField value",
      "when": "field configuration validation runs",
      "then": "error should require minimum length 1 character",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "customer_email",
            "type": "lookup",
            "relationshipField": "",
            "relatedField": "email"
          }
        },
        "assertions": [
          {
            "description": "Empty relationshipField rejected",
            "validateConfig": true,
            "expectError": "relationshipField must have at least 1 character"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATIONSHIPFIELD-004",
      "given": "lookup field following many-to-one relationship (products â†’ category)",
      "when": "multiple products reference same category",
      "then": "each product's lookup field shows correct category value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE categories (id SERIAL PRIMARY KEY, name VARCHAR(255), tax_rate DECIMAL(5,2))",
            "CREATE TABLE products (id SERIAL PRIMARY KEY, product_name VARCHAR(255), category_id INTEGER REFERENCES categories(id))",
            "CREATE VIEW products_with_lookup AS SELECT p.*, c.tax_rate as category_tax_rate FROM products p LEFT JOIN categories c ON p.category_id = c.id",
            "INSERT INTO categories (name, tax_rate) VALUES ('Electronics', 0.20), ('Clothing', 0.10)",
            "INSERT INTO products (product_name, category_id) VALUES ('Laptop', 1), ('Smartphone', 1), ('T-Shirt', 2)"
          ],
          "fieldConfig": {
            "name": "category_tax_rate",
            "type": "lookup",
            "relationshipField": "category_id",
            "relatedField": "tax_rate"
          }
        },
        "assertions": [
          {
            "description": "First product shows correct tax rate",
            "executeQuery": "SELECT product_name, category_tax_rate FROM products_with_lookup WHERE product_name = 'Laptop'",
            "expected": {
              "product_name": "Laptop",
              "category_tax_rate": 0.2
            }
          },
          {
            "description": "Second product in same category shows same tax rate",
            "executeQuery": "SELECT product_name, category_tax_rate FROM products_with_lookup WHERE product_name = 'Smartphone'",
            "expected": {
              "product_name": "Smartphone",
              "category_tax_rate": 0.2
            }
          },
          {
            "description": "Product in different category shows different tax rate",
            "executeQuery": "SELECT product_name, category_tax_rate FROM products_with_lookup WHERE product_name = 'T-Shirt'",
            "expected": {
              "product_name": "T-Shirt",
              "category_tax_rate": 0.1
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-LOOKUP-RELATIONSHIPFIELD-005",
      "given": "lookup field with NULL relationship field value",
      "when": "base record has no related record (FK is NULL)",
      "then": "lookup field returns NULL (LEFT JOIN behavior)",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE managers (id SERIAL PRIMARY KEY, name VARCHAR(255), department VARCHAR(255))",
            "CREATE TABLE tasks (id SERIAL PRIMARY KEY, title VARCHAR(255), assigned_to INTEGER REFERENCES managers(id))",
            "CREATE VIEW tasks_with_lookup AS SELECT t.*, m.department as manager_department FROM tasks t LEFT JOIN managers m ON t.assigned_to = m.id",
            "INSERT INTO managers (name, department) VALUES ('Alice', 'Engineering')",
            "INSERT INTO tasks (title, assigned_to) VALUES ('Assigned Task', 1), ('Unassigned Task', NULL)"
          ],
          "fieldConfig": {
            "name": "manager_department",
            "type": "lookup",
            "relationshipField": "assigned_to",
            "relatedField": "department"
          }
        },
        "assertions": [
          {
            "description": "Task with assigned manager shows lookup value",
            "executeQuery": "SELECT title, manager_department FROM tasks_with_lookup WHERE title = 'Assigned Task'",
            "expected": {
              "title": "Assigned Task",
              "manager_department": "Engineering"
            }
          },
          {
            "description": "Task without assigned manager shows NULL lookup value",
            "executeQuery": "SELECT title, manager_department FROM tasks_with_lookup WHERE title = 'Unassigned Task'",
            "expected": {
              "title": "Unassigned Task",
              "manager_department": null
            }
          }
        ]
      }
    }
  ]
}
