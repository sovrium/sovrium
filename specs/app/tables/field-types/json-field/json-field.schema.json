{
  "$id": "json-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "JSON Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "required": {
      "$ref": "../common/required/required.schema.json"
    },
    "type": {
      "type": "string",
      "const": "json"
    },
    "schema": {
      "$ref": "./schema/schema.schema.json"
    }
  },
  "description": "Flexible JSON field for storing structured data objects. Accepts any valid JSON (objects, arrays, primitives). Optionally provide a JSON Schema for validation to enforce structure and types. Useful for storing configuration objects, API responses, flexible attributes, and dynamic data that doesn't fit rigid schema. Displays with syntax highlighting and formatting in UI. Can be queried using JSON path expressions.",
  "required": ["id", "name", "type"],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-JSON-FIELD-001",
      "given": "table configuration with json field 'metadata'",
      "when": "field migration creates JSONB column",
      "then": "PostgreSQL JSONB column is created for structured JSON data",
      "validation": {
        "setup": {
          "executeQuery": "CREATE TABLE products (id SERIAL PRIMARY KEY, metadata JSONB)",
          "fieldConfig": {
            "id": 1,
            "name": "metadata",
            "type": "json"
          }
        },
        "assertions": [
          {
            "description": "Column created as JSONB",
            "executeQuery": "SELECT column_name, data_type FROM information_schema.columns WHERE table_name='products' AND column_name='metadata'",
            "expected": { "column_name": "metadata", "data_type": "jsonb" }
          },
          {
            "description": "JSON object can be inserted",
            "executeQuery": "INSERT INTO products (metadata) VALUES ('{\"color\": \"red\", \"size\": \"large\"}') RETURNING metadata",
            "expected": { "metadata": { "color": "red", "size": "large" } }
          },
          {
            "description": "JSON array can be inserted",
            "executeQuery": "INSERT INTO products (metadata) VALUES ('[1, 2, 3]') RETURNING metadata",
            "expected": { "metadata": [1, 2, 3] }
          }
        ]
      }
    },
    {
      "id": "APP-JSON-FIELD-002",
      "given": "table 'settings' with json field supporting JSON path queries",
      "when": "querying with JSON operators",
      "then": "PostgreSQL JSONB supports -> and ->> operators for field extraction",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE settings (id SERIAL PRIMARY KEY, config JSONB)",
            "INSERT INTO settings (config) VALUES ('{\"theme\": \"dark\", \"notifications\": {\"email\": true, \"sms\": false}}')"
          ]
        },
        "assertions": [
          {
            "description": "Extract top-level field as JSON",
            "executeQuery": "SELECT config -> 'theme' as theme FROM settings WHERE id = 1",
            "expected": { "theme": "\"dark\"" }
          },
          {
            "description": "Extract top-level field as text",
            "executeQuery": "SELECT config ->> 'theme' as theme FROM settings WHERE id = 1",
            "expected": { "theme": "dark" }
          },
          {
            "description": "Extract nested field",
            "executeQuery": "SELECT config -> 'notifications' ->> 'email' as email_enabled FROM settings WHERE id = 1",
            "expected": { "email_enabled": "true" }
          }
        ]
      }
    },
    {
      "id": "APP-JSON-FIELD-003",
      "given": "table 'users' with json field for querying by JSON content",
      "when": "filtering records by JSON field values",
      "then": "PostgreSQL JSONB supports containment and existence operators",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, preferences JSONB)",
            "INSERT INTO users (preferences) VALUES ('{\"language\": \"en\", \"timezone\": \"UTC\"}')",
            "INSERT INTO users (preferences) VALUES ('{\"language\": \"fr\", \"timezone\": \"Europe/Paris\"}')"
          ]
        },
        "assertions": [
          {
            "description": "Find users with specific language preference",
            "executeQuery": "SELECT COUNT(*) as count FROM users WHERE preferences ->> 'language' = 'en'",
            "expected": { "count": 1 }
          },
          {
            "description": "Check if JSON contains specific key",
            "executeQuery": "SELECT COUNT(*) as count FROM users WHERE preferences ? 'timezone'",
            "expected": { "count": 2 }
          },
          {
            "description": "JSON containment operator @>",
            "executeQuery": "SELECT COUNT(*) as count FROM users WHERE preferences @> '{\"language\": \"fr\"}'",
            "expected": { "count": 1 }
          }
        ]
      }
    },
    {
      "id": "APP-JSON-FIELD-004",
      "given": "table 'documents' with json field and GIN index",
      "when": "GIN index is created on JSONB column",
      "then": "PostgreSQL GIN index supports efficient JSON queries",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE documents (id SERIAL PRIMARY KEY, data JSONB)",
            "CREATE INDEX idx_documents_data ON documents USING GIN(data)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "data",
            "type": "json",
            "indexed": true
          }
        },
        "assertions": [
          {
            "description": "Index exists in pg_indexes",
            "executeQuery": "SELECT indexname, tablename FROM pg_indexes WHERE indexname = 'idx_documents_data'",
            "expected": { "indexname": "idx_documents_data", "tablename": "documents" }
          },
          {
            "description": "Index uses GIN for JSONB operations",
            "executeQuery": "SELECT indexdef FROM pg_indexes WHERE indexname = 'idx_documents_data'",
            "expected": {
              "indexdef": "CREATE INDEX idx_documents_data ON public.documents USING gin (data)"
            }
          }
        ]
      }
    },
    {
      "id": "APP-JSON-FIELD-005",
      "given": "table 'events' with json field supporting JSON modification",
      "when": "updating JSON field with jsonb_set function",
      "then": "PostgreSQL supports in-place JSON field updates",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE events (id SERIAL PRIMARY KEY, payload JSONB)",
            "INSERT INTO events (payload) VALUES ('{\"type\": \"click\", \"count\": 1}')"
          ]
        },
        "assertions": [
          {
            "description": "Initial JSON value",
            "executeQuery": "SELECT payload FROM events WHERE id = 1",
            "expected": { "payload": { "type": "click", "count": 1 } }
          },
          {
            "description": "Update specific JSON field with jsonb_set",
            "executeQuery": "UPDATE events SET payload = jsonb_set(payload, '{count}', '5') WHERE id = 1 RETURNING payload",
            "expected": { "payload": { "type": "click", "count": 5 } }
          },
          {
            "description": "Add new JSON field",
            "executeQuery": "UPDATE events SET payload = jsonb_set(payload, '{user_id}', '\"user123\"') WHERE id = 1 RETURNING payload",
            "expected": { "payload": { "type": "click", "count": 5, "user_id": "user123" } }
          }
        ]
      }
    }
  ]
}
