{
  "$id": "formula-field.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Formula Field",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "../../../common/definitions.schema.json#/definitions/id"
    },
    "name": {
      "$ref": "../../../common/definitions.schema.json#/definitions/name"
    },
    "type": {
      "type": "string",
      "const": "formula"
    },
    "formula": {
      "$ref": "./formula/formula.schema.json"
    },
    "resultType": {
      "$ref": "./resultType/resultType.schema.json"
    },
    "format": {
      "$ref": "./format/format.schema.json"
    }
  },
  "description": "Computed field that automatically calculates values using formula expressions. Formulas can reference other fields, use operators (+, -, *, /, =, >, <), and call functions (CONCAT, IF, ROUND, SUM, etc.). Specify resultType (text, number, boolean, date) for proper type handling. Optionally set display format (currency, percentage, decimal, date). Formulas are read-only and recalculate when dependent fields change. Useful for totals, concatenations, conditional logic, and derived values.",
  "required": ["id", "name", "type", "formula"],
  "additionalProperties": false,
  "x-specs": [
    {
      "id": "APP-FORMULA-FIELD-001",
      "given": "table configuration with formula field 'total' (quantity * unit_price)",
      "when": "field migration creates GENERATED column",
      "then": "PostgreSQL GENERATED ALWAYS AS column computes arithmetic formula",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE line_items (id SERIAL PRIMARY KEY, quantity INTEGER NOT NULL, unit_price DECIMAL(10,2) NOT NULL, total DECIMAL(10,2) GENERATED ALWAYS AS (quantity * unit_price) STORED)",
            "INSERT INTO line_items (quantity, unit_price) VALUES (5, 19.99), (10, 9.50)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "total",
            "type": "formula",
            "formula": "quantity * unit_price",
            "resultType": "number"
          }
        },
        "assertions": [
          {
            "description": "Column is a generated column",
            "executeQuery": "SELECT column_name, is_generated FROM information_schema.columns WHERE table_name='line_items' AND column_name='total'",
            "expected": {
              "column_name": "total",
              "is_generated": "ALWAYS"
            }
          },
          {
            "description": "Formula computes correct total for first record",
            "executeQuery": "SELECT quantity, unit_price, total FROM line_items WHERE id = 1",
            "expected": {
              "quantity": 5,
              "unit_price": "19.99",
              "total": "99.95"
            }
          },
          {
            "description": "Formula computes correct total for second record",
            "executeQuery": "SELECT quantity, unit_price, total FROM line_items WHERE id = 2",
            "expected": {
              "quantity": 10,
              "unit_price": "9.50",
              "total": "95.00"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FORMULA-FIELD-002",
      "given": "table 'contacts' with formula field 'full_name' concatenating first and last names",
      "when": "string concatenation formula is used",
      "then": "PostgreSQL GENERATED column performs text concatenation",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE contacts (id SERIAL PRIMARY KEY, first_name VARCHAR(100) NOT NULL, last_name VARCHAR(100) NOT NULL, full_name VARCHAR(255) GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED)",
            "INSERT INTO contacts (first_name, last_name) VALUES ('John', 'Doe'), ('Jane', 'Smith')"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "full_name",
            "type": "formula",
            "formula": "first_name || ' ' || last_name",
            "resultType": "text"
          }
        },
        "assertions": [
          {
            "description": "Formula concatenates names for first contact",
            "executeQuery": "SELECT first_name, last_name, full_name FROM contacts WHERE id = 1",
            "expected": {
              "first_name": "John",
              "last_name": "Doe",
              "full_name": "John Doe"
            }
          },
          {
            "description": "Formula concatenates names for second contact",
            "executeQuery": "SELECT first_name, last_name, full_name FROM contacts WHERE id = 2",
            "expected": {
              "first_name": "Jane",
              "last_name": "Smith",
              "full_name": "Jane Smith"
            }
          },
          {
            "description": "Generated column automatically updates when source fields change",
            "executeQuery": "UPDATE contacts SET first_name = 'Janet' WHERE id = 2 RETURNING full_name",
            "expected": {
              "full_name": "Janet Smith"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FORMULA-FIELD-003",
      "given": "table 'products' with formula field 'discount_price' using conditional logic",
      "when": "CASE WHEN formula applies conditional calculation",
      "then": "PostgreSQL GENERATED column supports conditional expressions",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, price DECIMAL(10,2) NOT NULL, on_sale BOOLEAN NOT NULL, discount_price DECIMAL(10,2) GENERATED ALWAYS AS (CASE WHEN on_sale THEN price * 0.80 ELSE price END) STORED)",
            "INSERT INTO products (price, on_sale) VALUES (100.00, true), (50.00, false)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "discount_price",
            "type": "formula",
            "formula": "CASE WHEN on_sale THEN price * 0.80 ELSE price END",
            "resultType": "number"
          }
        },
        "assertions": [
          {
            "description": "Product on sale gets 20% discount",
            "executeQuery": "SELECT price, on_sale, discount_price FROM products WHERE id = 1",
            "expected": {
              "price": "100.00",
              "on_sale": true,
              "discount_price": "80.00"
            }
          },
          {
            "description": "Product not on sale has no discount",
            "executeQuery": "SELECT price, on_sale, discount_price FROM products WHERE id = 2",
            "expected": {
              "price": "50.00",
              "on_sale": false,
              "discount_price": "50.00"
            }
          },
          {
            "description": "Formula updates when on_sale changes",
            "executeQuery": "UPDATE products SET on_sale = true WHERE id = 2 RETURNING discount_price",
            "expected": {
              "discount_price": "40.00"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FORMULA-FIELD-004",
      "given": "table 'measurements' with formula field 'rounded_value' using numeric functions",
      "when": "formula uses ROUND, ABS, or other math functions",
      "then": "PostgreSQL GENERATED column applies mathematical functions",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE measurements (id SERIAL PRIMARY KEY, raw_value DECIMAL(10,4) NOT NULL, rounded_value DECIMAL(10,2) GENERATED ALWAYS AS (ROUND(raw_value, 2)) STORED)",
            "INSERT INTO measurements (raw_value) VALUES (19.9567), (49.1234), (-15.6789)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "rounded_value",
            "type": "formula",
            "formula": "ROUND(raw_value, 2)",
            "resultType": "number"
          }
        },
        "assertions": [
          {
            "description": "ROUND function rounds to 2 decimal places",
            "executeQuery": "SELECT raw_value, rounded_value FROM measurements WHERE id = 1",
            "expected": {
              "raw_value": "19.9567",
              "rounded_value": "19.96"
            }
          },
          {
            "description": "Second record rounded correctly",
            "executeQuery": "SELECT raw_value, rounded_value FROM measurements WHERE id = 2",
            "expected": {
              "raw_value": "49.1234",
              "rounded_value": "49.12"
            }
          },
          {
            "description": "Negative value rounded correctly",
            "executeQuery": "SELECT raw_value, rounded_value FROM measurements WHERE id = 3",
            "expected": {
              "raw_value": "-15.6789",
              "rounded_value": "-15.68"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FORMULA-FIELD-005",
      "given": "table 'invoices' with formula field 'is_overdue' using date comparison",
      "when": "formula compares dates with current timestamp",
      "then": "PostgreSQL GENERATED column evaluates boolean date logic",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE invoices (id SERIAL PRIMARY KEY, due_date DATE NOT NULL, paid BOOLEAN NOT NULL DEFAULT false, is_overdue BOOLEAN GENERATED ALWAYS AS (NOT paid AND due_date < CURRENT_DATE) STORED)",
            "INSERT INTO invoices (due_date, paid) VALUES ('2024-01-15', false), ('2025-12-31', false), ('2024-06-01', true)"
          ],
          "fieldConfig": {
            "id": 1,
            "name": "is_overdue",
            "type": "formula",
            "formula": "NOT paid AND due_date < CURRENT_DATE",
            "resultType": "boolean"
          }
        },
        "assertions": [
          {
            "description": "Unpaid invoice with past due date is overdue",
            "executeQuery": "SELECT due_date, paid, is_overdue FROM invoices WHERE id = 1",
            "expected": {
              "due_date": "2024-01-15",
              "paid": false,
              "is_overdue": true
            }
          },
          {
            "description": "Unpaid invoice with future due date is not overdue",
            "executeQuery": "SELECT due_date, paid, is_overdue FROM invoices WHERE id = 2",
            "expected": {
              "due_date": "2025-12-31",
              "paid": false,
              "is_overdue": false
            }
          },
          {
            "description": "Paid invoice is never overdue regardless of date",
            "executeQuery": "SELECT due_date, paid, is_overdue FROM invoices WHERE id = 3",
            "expected": {
              "due_date": "2024-06-01",
              "paid": true,
              "is_overdue": false
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-FORMAT-001",
      "given": "formula field with format: 'currency' and expression: price * quantity",
      "when": "formula computes product total",
      "then": "PostgreSQL GENERATED column computes value, application displays with currency formatting",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE order_items (id SERIAL PRIMARY KEY, product_name VARCHAR(255), price DECIMAL(10,2), quantity INTEGER, total DECIMAL(15,2) GENERATED ALWAYS AS (price * quantity) STORED)",
            "INSERT INTO order_items (product_name, price, quantity) VALUES ('Widget', 19.99, 3), ('Gadget', 49.50, 2)"
          ],
          "fieldConfig": {
            "name": "total",
            "type": "formula",
            "expression": "price * quantity",
            "format": "currency"
          }
        },
        "assertions": [
          {
            "description": "GENERATED column computes formula",
            "executeQuery": "SELECT total FROM order_items WHERE product_name = 'Widget'",
            "expected": {
              "total": 59.97
            }
          },
          {
            "description": "Application displays with currency formatting",
            "displayFormat": "currency",
            "executeQuery": "SELECT total FROM order_items WHERE product_name = 'Widget'",
            "expectedDisplay": "$59.97",
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-FORMAT-002",
      "given": "formula field with format: 'percentage' and expression: (completed / total) * 100",
      "when": "formula computes completion rate",
      "then": "PostgreSQL computes percentage, application displays with % symbol",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE projects (id SERIAL PRIMARY KEY, name VARCHAR(255), completed INTEGER, total INTEGER, completion_rate DECIMAL(5,2) GENERATED ALWAYS AS ((completed::DECIMAL / NULLIF(total, 0)) * 100) STORED)",
            "INSERT INTO projects (name, completed, total) VALUES ('Alpha', 75, 100), ('Beta', 45, 60)"
          ],
          "fieldConfig": {
            "name": "completion_rate",
            "type": "formula",
            "expression": "(completed / total) * 100",
            "format": "percentage"
          }
        },
        "assertions": [
          {
            "description": "Formula computes percentage",
            "executeQuery": "SELECT completion_rate FROM projects WHERE name = 'Alpha'",
            "expected": {
              "completion_rate": 75
            }
          },
          {
            "description": "Application displays with percentage formatting",
            "displayFormat": "percentage",
            "executeQuery": "SELECT completion_rate FROM projects WHERE name = 'Alpha'",
            "expectedDisplay": "75.00%",
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-FORMAT-003",
      "given": "formula field without format property",
      "when": "format is empty or omitted",
      "then": "PostgreSQL formula result displayed without formatting",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE calculations (id SERIAL PRIMARY KEY, x DECIMAL(10,2), y DECIMAL(10,2), result DECIMAL(10,2) GENERATED ALWAYS AS (x + y) STORED)",
            "INSERT INTO calculations (x, y) VALUES (12.50, 37.25), (100.00, 250.50)"
          ],
          "fieldConfig": {
            "name": "result",
            "type": "formula",
            "expression": "x + y"
          }
        },
        "assertions": [
          {
            "description": "Formula computes sum",
            "executeQuery": "SELECT result FROM calculations WHERE x = 12.50",
            "expected": {
              "result": 49.75
            }
          },
          {
            "description": "Display without formatting (raw numeric)",
            "executeQuery": "SELECT result FROM calculations WHERE x = 12.50",
            "expectedDisplay": "49.75",
            "expectError": "validation error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-001",
      "given": "formula field with arithmetic expression: 'price * quantity'",
      "when": "field migration creates GENERATED column",
      "then": "PostgreSQL computes value automatically on INSERT/UPDATE",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE order_items (id SERIAL PRIMARY KEY, product VARCHAR(255), price DECIMAL(10,2), quantity INTEGER, total DECIMAL(15,2) GENERATED ALWAYS AS (price * quantity) STORED)",
            "INSERT INTO order_items (product, price, quantity) VALUES ('Widget', 19.99, 5), ('Gadget', 49.50, 2)"
          ],
          "fieldConfig": {
            "name": "total",
            "type": "formula",
            "formula": "price * quantity",
            "resultType": "number"
          }
        },
        "assertions": [
          {
            "description": "Column is GENERATED type",
            "executeQuery": "SELECT is_generated FROM information_schema.columns WHERE table_name='order_items' AND column_name='total'",
            "expected": {
              "is_generated": "ALWAYS"
            }
          },
          {
            "description": "Formula computes automatically (19.99 * 5)",
            "executeQuery": "SELECT total FROM order_items WHERE product = 'Widget'",
            "expected": {
              "total": 99.95
            }
          },
          {
            "description": "Cannot manually insert into GENERATED column",
            "executeQuery": "INSERT INTO order_items (product, price, quantity, total) VALUES ('Invalid', 10.00, 1, 999.99)",
            "expectError": "cannot insert into column \"total\""
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-002",
      "given": "formula field with string concatenation: 'CONCAT(first_name, \" \", last_name)'",
      "when": "formula uses text functions",
      "then": "PostgreSQL CONCAT function generates full name",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE employees (id SERIAL PRIMARY KEY, first_name VARCHAR(255), last_name VARCHAR(255), full_name TEXT GENERATED ALWAYS AS (CONCAT(first_name, ' ', last_name)) STORED)",
            "INSERT INTO employees (first_name, last_name) VALUES ('John', 'Doe'), ('Jane', 'Smith')"
          ],
          "fieldConfig": {
            "name": "full_name",
            "type": "formula",
            "formula": "CONCAT(first_name, ' ', last_name)",
            "resultType": "text"
          }
        },
        "assertions": [
          {
            "description": "String concatenation works",
            "executeQuery": "SELECT full_name FROM employees WHERE first_name = 'John'",
            "expected": {
              "full_name": "John Doe"
            }
          },
          {
            "description": "Formula updates when source fields change",
            "executeQuery": "UPDATE employees SET last_name = 'Johnson' WHERE first_name = 'John' RETURNING full_name",
            "expected": {
              "full_name": "John Johnson"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-003",
      "given": "formula field with conditional: 'CASE WHEN status = \"active\" THEN \"Yes\" ELSE \"No\" END'",
      "when": "formula uses CASE expression",
      "then": "PostgreSQL evaluates condition and returns result",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE accounts (id SERIAL PRIMARY KEY, username VARCHAR(255), status VARCHAR(50), is_active TEXT GENERATED ALWAYS AS (CASE WHEN status = 'active' THEN 'Yes' ELSE 'No' END) STORED)",
            "INSERT INTO accounts (username, status) VALUES ('user1', 'active'), ('user2', 'inactive'), ('user3', 'pending')"
          ],
          "fieldConfig": {
            "name": "is_active",
            "type": "formula",
            "formula": "CASE WHEN status = 'active' THEN 'Yes' ELSE 'No' END",
            "resultType": "text"
          }
        },
        "assertions": [
          {
            "description": "Condition evaluates to 'Yes' for active",
            "executeQuery": "SELECT is_active FROM accounts WHERE username = 'user1'",
            "expected": {
              "is_active": "Yes"
            }
          },
          {
            "description": "Condition evaluates to 'No' for non-active",
            "executeQuery": "SELECT is_active FROM accounts WHERE username = 'user2'",
            "expected": {
              "is_active": "No"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-004",
      "given": "formula field with function: 'ROUND(total * 0.15, 2)' (15% tax)",
      "when": "formula uses ROUND function",
      "then": "PostgreSQL computes rounded tax value",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE invoices (id SERIAL PRIMARY KEY, subtotal DECIMAL(15,2), tax DECIMAL(15,2) GENERATED ALWAYS AS (ROUND(subtotal * 0.15, 2)) STORED)",
            "INSERT INTO invoices (subtotal) VALUES (100.00), (49.99), (1234.56)"
          ],
          "fieldConfig": {
            "name": "tax",
            "type": "formula",
            "formula": "ROUND(total * 0.15, 2)",
            "resultType": "number"
          }
        },
        "assertions": [
          {
            "description": "Tax calculated and rounded (100 * 0.15)",
            "executeQuery": "SELECT tax FROM invoices WHERE subtotal = 100.00",
            "expected": {
              "tax": 15
            }
          },
          {
            "description": "Tax rounded to 2 decimals (49.99 * 0.15)",
            "executeQuery": "SELECT tax FROM invoices WHERE subtotal = 49.99",
            "expected": {
              "tax": 7.5
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-005",
      "given": "formula field with empty string",
      "when": "field configuration validation runs",
      "then": "error should require minimum length 1 character",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "result",
            "type": "formula",
            "formula": "",
            "resultType": "text"
          }
        },
        "assertions": [
          {
            "description": "Empty formula rejected",
            "validateConfig": true,
            "expectError": "formula must have at least 1 character"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-006",
      "given": "formula field with invalid SQL syntax",
      "when": "migration attempts to create GENERATED column",
      "then": "PostgreSQL returns syntax error",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE test (id SERIAL PRIMARY KEY, value INTEGER, result INTEGER GENERATED ALWAYS AS (INVALID SYNTAX) STORED)"
          ],
          "fieldConfig": {
            "name": "result",
            "type": "formula",
            "formula": "INVALID SYNTAX",
            "resultType": "number"
          }
        },
        "assertions": [
          {
            "description": "Invalid formula syntax rejected by PostgreSQL",
            "executeQuery": "CREATE TABLE test (id SERIAL PRIMARY KEY, value INTEGER, result INTEGER GENERATED ALWAYS AS (INVALID SYNTAX) STORED)",
            "expectError": "syntax error"
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-RESULTTYPE-001",
      "given": "formula field with resultType: 'number'",
      "when": "field migration creates GENERATED column",
      "then": "PostgreSQL creates DECIMAL type column for numeric results",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE products (id SERIAL PRIMARY KEY, price DECIMAL(10,2), quantity INTEGER, total DECIMAL(15,2) GENERATED ALWAYS AS (price * quantity) STORED)",
            "INSERT INTO products (price, quantity) VALUES (29.99, 3)"
          ],
          "fieldConfig": {
            "name": "total",
            "type": "formula",
            "formula": "price * quantity",
            "resultType": "number"
          }
        },
        "assertions": [
          {
            "description": "Column uses DECIMAL type for number resultType",
            "executeQuery": "SELECT data_type FROM information_schema.columns WHERE table_name='products' AND column_name='total'",
            "expected": {
              "data_type": "numeric"
            }
          },
          {
            "description": "Numeric result computed correctly",
            "executeQuery": "SELECT total FROM products WHERE id = 1",
            "expected": {
              "total": 89.97
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-RESULTTYPE-002",
      "given": "formula field with resultType: 'text'",
      "when": "field migration creates GENERATED column",
      "then": "PostgreSQL creates TEXT type column for string results",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE users (id SERIAL PRIMARY KEY, first_name VARCHAR(255), last_name VARCHAR(255), display_name TEXT GENERATED ALWAYS AS (CONCAT(first_name, ' ', last_name)) STORED)",
            "INSERT INTO users (first_name, last_name) VALUES ('Alice', 'Wonder'), ('Bob', 'Builder')"
          ],
          "fieldConfig": {
            "name": "display_name",
            "type": "formula",
            "formula": "CONCAT(first_name, ' ', last_name)",
            "resultType": "text"
          }
        },
        "assertions": [
          {
            "description": "Column uses TEXT type for text resultType",
            "executeQuery": "SELECT data_type FROM information_schema.columns WHERE table_name='users' AND column_name='display_name'",
            "expected": {
              "data_type": "text"
            }
          },
          {
            "description": "Text result computed correctly",
            "executeQuery": "SELECT display_name FROM users WHERE first_name = 'Alice'",
            "expected": {
              "display_name": "Alice Wonder"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-RESULTTYPE-003",
      "given": "formula field with resultType: 'boolean'",
      "when": "field migration creates GENERATED column",
      "then": "PostgreSQL creates BOOLEAN type column for conditional results",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE inventory (id SERIAL PRIMARY KEY, stock_level INTEGER, in_stock BOOLEAN GENERATED ALWAYS AS (stock_level > 0) STORED)",
            "INSERT INTO inventory (stock_level) VALUES (0), (10), (50)"
          ],
          "fieldConfig": {
            "name": "in_stock",
            "type": "formula",
            "formula": "stock_level > 0",
            "resultType": "boolean"
          }
        },
        "assertions": [
          {
            "description": "Column uses BOOLEAN type for boolean resultType",
            "executeQuery": "SELECT data_type FROM information_schema.columns WHERE table_name='inventory' AND column_name='in_stock'",
            "expected": {
              "data_type": "boolean"
            }
          },
          {
            "description": "Boolean result for zero stock (false)",
            "executeQuery": "SELECT in_stock FROM inventory WHERE stock_level = 0",
            "expected": {
              "in_stock": false
            }
          },
          {
            "description": "Boolean result for positive stock (true)",
            "executeQuery": "SELECT in_stock FROM inventory WHERE stock_level = 10",
            "expected": {
              "in_stock": true
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-RESULTTYPE-004",
      "given": "formula field with resultType: 'date'",
      "when": "field migration creates GENERATED column",
      "then": "PostgreSQL creates DATE type column for date calculations",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE subscriptions (id SERIAL PRIMARY KEY, start_date DATE, duration_days INTEGER, end_date DATE GENERATED ALWAYS AS (start_date + duration_days) STORED)",
            "INSERT INTO subscriptions (start_date, duration_days) VALUES ('2024-01-01', 30), ('2024-06-15', 90)"
          ],
          "fieldConfig": {
            "name": "end_date",
            "type": "formula",
            "formula": "start_date + duration_days",
            "resultType": "date"
          }
        },
        "assertions": [
          {
            "description": "Column uses DATE type for date resultType",
            "executeQuery": "SELECT data_type FROM information_schema.columns WHERE table_name='subscriptions' AND column_name='end_date'",
            "expected": {
              "data_type": "date"
            }
          },
          {
            "description": "Date calculation (2024-01-01 + 30 days)",
            "executeQuery": "SELECT end_date FROM subscriptions WHERE start_date = '2024-01-01'",
            "expected": {
              "end_date": "2024-01-31"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-RESULTTYPE-005",
      "given": "formula field without resultType specified",
      "when": "field configuration uses default",
      "then": "PostgreSQL creates TEXT type column (default: 'text')",
      "validation": {
        "setup": {
          "executeQuery": [
            "CREATE TABLE calculations (id SERIAL PRIMARY KEY, x INTEGER, y INTEGER, result TEXT GENERATED ALWAYS AS (CONCAT('Sum: ', (x + y)::TEXT)) STORED)",
            "INSERT INTO calculations (x, y) VALUES (5, 10)"
          ],
          "fieldConfig": {
            "name": "result",
            "type": "formula",
            "formula": "CONCAT('Sum: ', (x + y)::TEXT)"
          }
        },
        "assertions": [
          {
            "description": "Default resultType is 'text'",
            "executeQuery": "SELECT data_type FROM information_schema.columns WHERE table_name='calculations' AND column_name='result'",
            "expected": {
              "data_type": "text"
            }
          },
          {
            "description": "Result formatted as text",
            "executeQuery": "SELECT result FROM calculations WHERE id = 1",
            "expected": {
              "result": "Sum: 15"
            }
          }
        ]
      }
    },
    {
      "id": "APP-FIELD-FORMULA-RESULTTYPE-006",
      "given": "formula field with invalid resultType value",
      "when": "field configuration validation runs",
      "then": "error lists valid options: text, number, boolean, date",
      "validation": {
        "setup": {
          "fieldConfig": {
            "name": "computed",
            "type": "formula",
            "formula": "x + y",
            "resultType": "INVALID-TYPE"
          }
        },
        "assertions": [
          {
            "description": "Invalid resultType rejected with enum error",
            "validateConfig": true,
            "expectError": "resultType must be one of: text, number, boolean, date"
          }
        ]
      }
    }
  ]
}
