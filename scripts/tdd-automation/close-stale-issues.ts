#!/usr/bin/env bun
/**
 * Copyright (c) 2025 ESSENTIAL SERVICES
 *
 * This source code is licensed under the Business Source License 1.1
 * found in the LICENSE.md file in the root directory of this source tree.
 */

/**
 * Close Stale Issues Script
 *
 * Detects and closes GitHub issues for specs that have been fixed (no longer have .fixme())
 * but were never properly closed through the PR workflow.
 *
 * How it works:
 * 1. Scan for current RED tests with .fixme() (actual current state)
 * 2. Fetch all open spec issues (queued + in-progress)
 * 3. Compare: if issue exists but spec no longer has .fixme(), it's stale
 * 4. Close stale issues with explanatory comment
 *
 * Usage:
 *   bun run scripts/tdd-automation/close-stale-issues.ts          # Dry run (shows what would be closed)
 *   bun run scripts/tdd-automation/close-stale-issues.ts --close  # Actually close stale issues
 */

import * as Effect from 'effect/Effect'
import * as Layer from 'effect/Layer'
import {
  FileSystemServiceLive,
  CommandServiceLive,
  LoggerServicePretty,
  CommandService,
  success,
  logInfo,
  logWarn,
  logError,
  skip,
} from '../lib/effect'
import { scanForFixmeSpecs } from './services/spec-scanner'
import { getQueuedSpecs, getInProgressSpecs } from './services/queue-operations'
import type { SpecIssue } from './services/types'

/**
 * Close a stale issue with explanatory comment
 */
const closeStaleIssue = (issue: SpecIssue): Effect.Effect<void, never, CommandService> =>
  Effect.gen(function* () {
    const cmd = yield* CommandService

    const comment = `ðŸ¤– **Auto-closing stale issue**

This test has been fixed (no longer has \`.fixme()\`) but the issue was never closed through the normal PR workflow.

**Spec ID**: ${issue.specId}
**Status**: âœ… Test passing (no longer RED)

This is likely because:
- The PR didn't include \`Closes #${issue.number}\` in the body, OR
- The test was fixed manually without creating a PR

No further action needed - this issue can be safely closed.

---
Generated by close-stale-issues.ts`

    // Post comment explaining why we're closing
    yield* cmd
      .exec(`gh issue comment ${issue.number} --body "${comment.replace(/"/g, '\\"')}"`, {
        throwOnError: false,
      })
      .pipe(Effect.catchAll(() => Effect.void))

    // Remove old labels
    yield* cmd
      .exec(`gh issue edit ${issue.number} --remove-label "tdd-spec:queued,tdd-spec:in-progress"`, {
        throwOnError: false,
      })
      .pipe(Effect.catchAll(() => Effect.void))

    // Add stale label
    yield* cmd
      .exec(`gh issue edit ${issue.number} --add-label "tdd-spec:stale"`, {
        throwOnError: false,
      })
      .pipe(Effect.catchAll(() => Effect.void))

    // Close with "completed" reason (since test is passing)
    yield* cmd
      .exec(`gh issue close ${issue.number} --reason completed`, {
        throwOnError: false,
      })
      .pipe(Effect.catchAll(() => Effect.void))

    yield* logInfo(`  âœ… Closed #${issue.number}: ${issue.specId}`)
  })

/**
 * Main script
 */
const main = Effect.gen(function* () {
  const isDryRun = !process.argv.includes('--close')

  if (isDryRun) {
    yield* logInfo('ðŸ” DRY RUN MODE - No issues will be closed')
    yield* logInfo('   Add --close flag to actually close stale issues')
    yield* logInfo('')
  }

  // Step 1: Scan for current RED tests with .fixme()
  yield* logInfo('ðŸ“Š Scanning for current RED tests with .fixme()...')
  const scanResult = yield* scanForFixmeSpecs

  // Create a Set of current spec IDs that have .fixme()
  const currentRedSpecs = new Set(scanResult.specs.map((spec) => spec.specId))

  yield* logInfo(`   Found ${currentRedSpecs.size} RED tests with .fixme()`)
  yield* logInfo('')

  // Step 2: Get all open spec issues
  yield* logInfo('ðŸ“‹ Fetching open spec issues...')
  const queuedSpecs = yield* getQueuedSpecs
  const inProgressSpecs = yield* getInProgressSpecs

  const allOpenIssues = [...queuedSpecs, ...inProgressSpecs]

  yield* logInfo(`   Found ${allOpenIssues.length} open issues (queued + in-progress)`)
  yield* logInfo('')

  // Step 3: Find stale issues (open issues for specs without .fixme())
  const staleIssues = allOpenIssues.filter((issue) => !currentRedSpecs.has(issue.specId))

  if (staleIssues.length === 0) {
    yield* success('âœ… No stale issues found - all open issues have corresponding RED tests')
    return
  }

  // Step 4: Report stale issues
  yield* logWarn(`âš ï¸  Found ${staleIssues.length} stale issues:`)
  yield* logInfo('')

  for (const issue of staleIssues) {
    yield* logInfo(`   #${issue.number}: ${issue.specId}`)
    yield* logInfo(`     State: ${issue.state}`)
    yield* logInfo(`     URL: ${issue.url}`)
    yield* logInfo(`     Reason: Test no longer has .fixme() (likely fixed and passing)`)
    yield* logInfo('')
  }

  // Step 5: Close stale issues (if not dry run)
  if (isDryRun) {
    yield* logInfo('ðŸ” DRY RUN - No issues were closed')
    yield* logInfo(`   Run with --close flag to close these ${staleIssues.length} stale issues`)
    yield* logInfo('')
    yield* logInfo('Example:')
    yield* logInfo('  bun run scripts/tdd-automation/close-stale-issues.ts --close')
  } else {
    yield* logInfo(`ðŸ—‘ï¸  Closing ${staleIssues.length} stale issues...`)
    yield* logInfo('')

    let closedCount = 0
    for (const issue of staleIssues) {
      yield* closeStaleIssue(issue)
      closedCount++
    }

    yield* logInfo('')
    yield* success(`âœ… Closed ${closedCount} stale issues`)
  }
})

// Run with dependencies
const MainLayer = Layer.merge(
  FileSystemServiceLive,
  Layer.merge(CommandServiceLive, LoggerServicePretty())
)

Effect.runPromise(
  main.pipe(
    Effect.provide(MainLayer),
    Effect.catchAll((error) =>
      Effect.sync(() => {
        console.error('Close stale issues error:', error)
        process.exit(1)
      })
    )
  )
)
