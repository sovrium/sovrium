{
  "passed": 1,
  "failed": 0,
  "originalContent": "/**\n * Copyright (c) 2025 ESSENTIAL SERVICES\n *\n * This source code is licensed under the Business Source License 1.1\n * found in the LICENSE.md file in the root directory of this source tree.\n */\n\nimport { test, expect } from '@/specs/fixtures'\n\n/**\n * E2E Tests for List records in table\n *\n * Source: specs/api/paths/tables/{tableId}/records/get.json\n * Domain: api\n * Spec Count: 25\n *\n * Soft Delete Behavior:\n * - By default, soft-deleted records (deleted_at IS NOT NULL) are excluded\n * - Use includeDeleted=true query param to include soft-deleted records\n *\n * Test Organization:\n * 1. @spec tests - One per spec in schema (25 tests) - Exhaustive acceptance criteria\n * 2. @regression test - ONE optimized integration test - Efficient workflow validation\n */\n\ntest.describe('List records in table', () => {\n  // ============================================================================\n  // @spec tests (one per spec) - EXHAUSTIVE coverage\n  // ============================================================================\n\n  test(\n    'API-TABLES-RECORDS-LIST-001: should return 200 with array of 3 records and pagination',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table 'projects' with 3 records\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 1,\n            name: 'projects',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text', required: true },\n              { id: 2, name: 'status', type: 'single-line-text', default: 'active' },\n              { id: 3, name: 'priority', type: 'integer', default: 1 },\n              { id: 4, name: 'created_at', type: 'created-at' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO projects (name, status, priority)\n        VALUES\n          ('Project Alpha', 'active', 5),\n          ('Project Beta', 'completed', 3),\n          ('Project Gamma', 'active', 4)\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests all records\n      const response = await request.get('/api/tables/1/records', {})\n\n      // THEN: Returns 200 with array of 3 records and pagination metadata\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data).toHaveProperty('records')\n      expect(data).toHaveProperty('pagination')\n      expect(data.records).toHaveLength(3)\n      expect(data.pagination.total).toBe(3)\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-002: should return 404 Not Found',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, createAuthenticatedUser }) => {\n      // GIVEN: A running server with no table ID 9999\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [],\n      })\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests records from non-existent table\n      const response = await request.get('/api/tables/9999/records', {})\n\n      // THEN: Returns 404 Not Found\n      expect(response.status()).toBe(404)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.error).toBe('Table not found')\n    }\n  )\n\n  test(\n    'API-TABLES-RECORDS-LIST-003: should return 200 with only 2 active records',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with 5 records (2 active, 3 completed)\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 2,\n            name: 'tasks',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text', required: true },\n              { id: 2, name: 'status', type: 'single-line-text', required: true },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO tasks (name, status)\n        VALUES\n          ('Task 1', 'active'),\n          ('Task 2', 'active'),\n          ('Task 3', 'completed'),\n          ('Task 4', 'completed'),\n          ('Task 5', 'completed')\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests records with filter for status=active\n      const response = await request.get('/api/tables/2/records', {\n        params: {\n          filter: JSON.stringify({\n            and: [{ field: 'status', operator: 'equals', value: 'active' }],\n          }),\n        },\n      })\n\n      // THEN: Returns 200 with only 2 active records\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records).toHaveLength(2)\n      expect(data.pagination.total).toBe(2)\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-004: should return 200 with records in descending priority order',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with 3 records having different priorities\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 3,\n            name: 'projects',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'priority', type: 'integer' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO projects (name, priority)\n        VALUES\n          ('Low Priority', 1),\n          ('High Priority', 5),\n          ('Medium Priority', 3)\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests records sorted by priority descending\n      const response = await request.get('/api/tables/3/records', {\n        params: {\n          sort: 'priority:desc',\n        },\n      })\n\n      // THEN: Returns 200 with records in descending priority order\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records).toHaveLength(3)\n      expect(data.records[0].fields.priority).toBe(5)\n      expect(data.records[1].fields.priority).toBe(3)\n      expect(data.records[2].fields.priority).toBe(1)\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-005: should return 200 with records containing only specified fields',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with multiple fields\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 4,\n            name: 'users',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'email', type: 'email', required: true },\n              { id: 3, name: 'phone', type: 'phone-number' },\n              { id: 4, name: 'address', type: 'long-text' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO users (name, email, phone, address)\n        VALUES ('John Doe', 'john@example.com', '555-0100', '123 Main St')\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests only specific fields\n      const response = await request.get('/api/tables/4/records', {\n        params: {\n          fields: 'id,name,email',\n        },\n      })\n\n      // THEN: Returns 200 with records containing only specified fields\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records).toHaveLength(1)\n      expect(data.records[0]).toHaveProperty('id')\n      expect(data.records[0]).toHaveProperty('name')\n      expect(data.records[0]).toHaveProperty('email')\n      expect(data.records[0]).not.toHaveProperty('phone')\n      expect(data.records[0]).not.toHaveProperty('address')\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-006: should return 200 with records 41-60 and correct pagination',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with 100 records\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 5,\n            name: 'items',\n            fields: [{ id: 1, name: 'name', type: 'single-line-text' }],\n          },\n        ],\n      })\n\n      const insertValues = Array.from({ length: 100 }, (_, i) => `('Item ${i + 1}')`).join(',')\n      await executeQuery(`INSERT INTO items (name) VALUES ${insertValues}`)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests with limit=20 and offset=40\n      const response = await request.get('/api/tables/5/records', {\n        params: {\n          limit: '20',\n          offset: '40',\n        },\n      })\n\n      // THEN: Returns 200 with records 41-60 and correct pagination\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records).toHaveLength(20)\n      expect(data.pagination.total).toBe(100)\n      expect(data.pagination.limit).toBe(20)\n      expect(data.pagination.offset).toBe(40)\n    }\n  )\n\n  test(\n    'API-TABLES-RECORDS-LIST-007: should return 200 with records filtered by view',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with records and a predefined view\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 6,\n            name: 'projects',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'status', type: 'single-line-text' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO projects (name, status)\n        VALUES\n          ('Active Project 1', 'active'),\n          ('Active Project 2', 'active'),\n          ('Completed Project', 'completed')\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests records with view parameter\n      const response = await request.get('/api/tables/6/records', {\n        params: {\n          view: 'active_only',\n        },\n      })\n\n      // THEN: Returns 200 with records filtered by view\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records.length).toBeGreaterThan(0)\n    }\n  )\n\n  test(\n    'API-TABLES-RECORDS-LIST-008: should return 200 with records grouped by status',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with records having different status values\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 7,\n            name: 'tasks',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'status', type: 'single-line-text' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO tasks (name, status)\n        VALUES\n          ('Task 1', 'active'),\n          ('Task 2', 'active'),\n          ('Task 3', 'completed')\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests records grouped by status field\n      const response = await request.get('/api/tables/7/records', {\n        params: {\n          groupBy: 'status',\n        },\n      })\n\n      // THEN: Returns 200 with records grouped by status\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data).toHaveProperty('records')\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-009: should return 200 with aggregation results',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with numeric fields\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 8,\n            name: 'projects',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'budget', type: 'currency', currency: 'USD' },\n              { id: 3, name: 'priority', type: 'integer' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO projects (name, budget, priority)\n        VALUES\n          ('Project A', 10000, 5),\n          ('Project B', 20000, 3),\n          ('Project C', 15000, 4)\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests with aggregations (count, sum, avg)\n      const response = await request.get('/api/tables/8/records', {\n        params: {\n          aggregate: JSON.stringify({\n            count: true,\n            sum: ['budget'],\n            avg: ['priority'],\n          }),\n        },\n      })\n\n      // THEN: Returns 200 with aggregation results\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data).toHaveProperty('aggregations')\n      expect(data.aggregations.count).toBe('3')\n      expect(data.aggregations.sum.budget).toBe(45_000)\n      expect(data.aggregations.avg.priority).toBeCloseTo(4, 1)\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-010: should return 200 with records matching formula',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with multiple fields\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 9,\n            name: 'tasks',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'status', type: 'single-line-text' },\n              { id: 3, name: 'priority', type: 'integer' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO tasks (name, status, priority)\n        VALUES\n          ('High Priority Active', 'active', 5),\n          ('Low Priority Active', 'active', 1),\n          ('High Priority Done', 'completed', 5)\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User filters by Airtable-style formula\n      const response = await request.get('/api/tables/9/records', {\n        params: {\n          filterByFormula: \"AND({status}='active', {priority}>=3)\",\n        },\n      })\n\n      // THEN: Returns 200 with records matching formula\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records).toHaveLength(1)\n      expect(data.records[0].fields.name).toBe('High Priority Active')\n    }\n  )\n\n  test(\n    'API-TABLES-RECORDS-LIST-011: should return 200 with multi-field sort applied',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with multiple sortable fields\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 10,\n            name: 'projects',\n            fields: [\n              { id: 1, name: 'priority', type: 'integer' },\n              { id: 2, name: 'created_at', type: 'created-at' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO projects (priority, created_at)\n        VALUES\n          (5, '2025-01-01'),\n          (5, '2025-01-02'),\n          (3, '2025-01-03')\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User sorts by priority desc, then created_at desc\n      const response = await request.get('/api/tables/10/records', {\n        params: {\n          sort: 'priority:desc,created_at:desc',\n        },\n      })\n\n      // THEN: Returns 200 with multi-field sort applied\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records[0].fields.priority).toBe(5)\n      expect(data.records[1].fields.priority).toBe(5)\n      expect(data.records[2].fields.priority).toBe(3)\n    }\n  )\n\n  test(\n    'API-TABLES-RECORDS-LIST-012: should return 200 with both view and explicit filters',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with view and additional filter\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 11,\n            name: 'projects',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'status', type: 'single-line-text' },\n              { id: 3, name: 'priority', type: 'integer' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO projects (name, status, priority)\n        VALUES\n          ('High Active', 'active', 5),\n          ('Low Active', 'active', 1)\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User combines view and explicit filter\n      const response = await request.get('/api/tables/11/records', {\n        params: {\n          view: 'active_only',\n          filter: JSON.stringify({\n            and: [{ field: 'priority', operator: 'greaterThanOrEqual', value: 3 }],\n          }),\n        },\n      })\n\n      // THEN: Returns 200 with both view and explicit filters\n      expect(response.status()).toBe(200)\n    }\n  )\n\n  test(\n    'API-TABLES-RECORDS-LIST-013: should return 401 Unauthorized',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema }) => {\n      // GIVEN: A valid table with auth enabled\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 12,\n            name: 'projects',\n            fields: [{ id: 1, name: 'name', type: 'single-line-text' }],\n          },\n        ],\n      })\n\n      // WHEN: Unauthenticated user requests records\n      const response = await request.get('/api/tables/12/records')\n\n      // THEN: Returns 401 Unauthorized\n      expect(response.status()).toBe(401)\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-014: should return 403 Forbidden',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, createAuthenticatedViewer }) => {\n      // GIVEN: User without read permission\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 13,\n            name: 'confidential',\n            fields: [{ id: 1, name: 'data', type: 'long-text' }],\n          },\n        ],\n      })\n\n      // Create authenticated viewer (without read permission)\n      await createAuthenticatedViewer()\n\n      // WHEN: User without permission requests records\n      const response = await request.get('/api/tables/13/records', {})\n\n      // THEN: Returns 403 Forbidden\n      expect(response.status()).toBe(403)\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-015: should return all fields for admin',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedAdmin }) => {\n      // GIVEN: Admin user with full field access\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 15,\n            name: 'employees',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'email', type: 'email', required: true },\n              { id: 3, name: 'salary', type: 'currency', currency: 'USD' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO employees (name, email, salary)\n        VALUES ('John Doe', 'john@example.com', 75000)\n      `)\n\n      // Create authenticated admin\n      await createAuthenticatedAdmin()\n\n      // WHEN: Admin requests records\n      const response = await request.get('/api/tables/15/records', {})\n\n      // THEN: Returns all fields including salary\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records[0]).toHaveProperty('salary')\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-016: should exclude salary field for member',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedMember }) => {\n      // GIVEN: Member user without salary field read permission\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 16,\n            name: 'employees',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'email', type: 'email', required: true },\n              { id: 3, name: 'salary', type: 'currency', currency: 'USD' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO employees (name, email, salary)\n        VALUES ('John Doe', 'john@example.com', 75000)\n      `)\n\n      // Create authenticated member\n      await createAuthenticatedMember()\n\n      // WHEN: Member requests records\n      const response = await request.get('/api/tables/16/records', {})\n\n      // THEN: Returns records without salary field\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records[0]).toHaveProperty('name')\n      expect(data.records[0]).toHaveProperty('email')\n      expect(data.records[0]).not.toHaveProperty('salary')\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-017: should return minimal fields for viewer',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedViewer }) => {\n      // GIVEN: Viewer with limited field access\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 17,\n            name: 'employees',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'email', type: 'email', required: true },\n              { id: 3, name: 'phone', type: 'phone-number' },\n              { id: 4, name: 'salary', type: 'currency', currency: 'USD' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO employees (name, email, phone, salary)\n        VALUES ('John Doe', 'john@example.com', '555-0100', 75000)\n      `)\n\n      // Create authenticated viewer\n      await createAuthenticatedViewer()\n\n      // WHEN: Viewer requests records\n      const response = await request.get('/api/tables/17/records', {})\n\n      // THEN: Returns only permitted fields\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records[0]).toHaveProperty('id')\n      expect(data.records[0]).toHaveProperty('name')\n      expect(data.records[0]).not.toHaveProperty('email')\n      expect(data.records[0]).not.toHaveProperty('salary')\n    }\n  )\n\n  test(\n    'API-TABLES-RECORDS-LIST-018: should return empty array with 200',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, createAuthenticatedUser }) => {\n      // GIVEN: User with valid permissions but no matching records\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 20,\n            name: 'projects',\n            fields: [{ id: 1, name: 'name', type: 'single-line-text' }],\n          },\n        ],\n      })\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests records (empty table)\n      const response = await request.get('/api/tables/20/records', {})\n\n      // THEN: Returns 200 with empty array\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records).toHaveLength(0)\n      expect(data.pagination.total).toBe(0)\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-019: should paginate with field filtering',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Member with field restrictions and large dataset\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 21,\n            name: 'employees',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'salary', type: 'currency', currency: 'USD' },\n            ],\n          },\n        ],\n      })\n\n      const insertValues = Array.from(\n        { length: 50 },\n        (_, i) => `('Employee ${i + 1}', ${50_000 + i * 1000})`\n      ).join(',')\n      await executeQuery(`\n        INSERT INTO employees (name, salary) VALUES ${insertValues}\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: Member requests paginated records\n      const response = await request.get('/api/tables/21/records', {\n        params: {\n          limit: '10',\n          offset: '20',\n        },\n      })\n\n      // THEN: Returns paginated records without restricted fields\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.records).toHaveLength(10)\n      expect(data.pagination.offset).toBe(20)\n      expect(data.records[0]).not.toHaveProperty('salary')\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-020: should return 403 when sorting by inaccessible field',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, createAuthenticatedMember }) => {\n      // GIVEN: User attempts to sort by restricted field\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 22,\n            name: 'employees',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'salary', type: 'currency', currency: 'USD' },\n            ],\n          },\n        ],\n      })\n\n      // Create authenticated member (cannot read salary field)\n      await createAuthenticatedMember()\n\n      // WHEN: Member sorts by salary (field they cannot read)\n      const response = await request.get('/api/tables/22/records', {\n        params: {\n          sort: 'salary:desc',\n        },\n      })\n\n      // THEN: Returns 403 Forbidden\n      expect(response.status()).toBe(403)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.error).toBe('Forbidden')\n      expect(data.message).toContain('Cannot sort by field')\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-021: should return 403 when filtering by inaccessible field',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, createAuthenticatedMember }) => {\n      // GIVEN: User attempts to filter by restricted field\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 23,\n            name: 'employees',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'salary', type: 'currency', currency: 'USD' },\n            ],\n          },\n        ],\n      })\n\n      // Create authenticated member (cannot read salary field)\n      await createAuthenticatedMember()\n\n      // WHEN: Member filters by salary (field they cannot read)\n      const response = await request.get('/api/tables/23/records', {\n        params: {\n          filter: JSON.stringify({\n            and: [{ field: 'salary', operator: 'greaterThan', value: 60_000 }],\n          }),\n        },\n      })\n\n      // THEN: Returns 403 Forbidden\n      expect(response.status()).toBe(403)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.error).toBe('Forbidden')\n      expect(data.message).toContain('Cannot filter by field')\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-022: should return 403 when aggregating inaccessible field',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, createAuthenticatedMember }) => {\n      // GIVEN: User attempts to aggregate restricted field\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 24,\n            name: 'employees',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'salary', type: 'currency', currency: 'USD' },\n            ],\n          },\n        ],\n      })\n\n      // Create authenticated member (cannot read salary field)\n      await createAuthenticatedMember()\n\n      // WHEN: Member aggregates salary (field they cannot read)\n      const response = await request.get('/api/tables/24/records', {\n        params: {\n          aggregate: JSON.stringify({\n            sum: ['salary'],\n            avg: ['salary'],\n          }),\n        },\n      })\n\n      // THEN: Returns 403 Forbidden\n      expect(response.status()).toBe(403)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.error).toBe('Forbidden')\n      expect(data.message).toContain('Cannot aggregate field')\n    }\n  )\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-023: should return aggregations for accessible fields',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedMember }) => {\n      // GIVEN: User aggregates only accessible fields\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 25,\n            name: 'projects',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'priority', type: 'integer' },\n              { id: 3, name: 'budget', type: 'currency', currency: 'USD' },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO projects (name, priority, budget)\n        VALUES\n          ('P1', 5, 10000),\n          ('P2', 3, 20000),\n          ('P3', 4, 15000)\n      `)\n\n      // Create authenticated member\n      await createAuthenticatedMember()\n\n      // WHEN: Member aggregates permitted fields only\n      const response = await request.get('/api/tables/25/records', {\n        params: {\n          aggregate: JSON.stringify({\n            count: true,\n            avg: ['priority'],\n          }),\n        },\n      })\n\n      // THEN: Returns aggregation results for accessible fields\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: assertion\n      expect(data.aggregations.count).toBe('3')\n      expect(data.aggregations.avg.priority).toBe(4)\n      expect(data.aggregations.avg).not.toHaveProperty('budget')\n    }\n  )\n\n  // ============================================================================\n  // Soft Delete Filtering Tests\n  // ============================================================================\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-024: should exclude soft-deleted records by default',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with mix of active and soft-deleted records\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 27,\n            name: 'tasks',\n            fields: [\n              { id: 1, name: 'title', type: 'single-line-text', required: true },\n              { id: 2, name: 'status', type: 'single-line-text' },\n              { id: 3, name: 'deleted_at', type: 'deleted-at', indexed: true },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO tasks (id, title, status, deleted_at) VALUES\n          (1, 'Active Task 1', 'pending', NULL),\n          (2, 'Deleted Task', 'completed', NOW()),\n          (3, 'Active Task 2', 'in_progress', NULL),\n          (4, 'Another Deleted', 'pending', NOW())\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests records without includeDeleted parameter\n      const response = await request.get('/api/tables/27/records', {})\n\n      // THEN: Returns 200 with only active (non-deleted) records\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: Only 2 active records returned (soft-deleted excluded)\n      expect(data.records).toHaveLength(2)\n      expect(data.pagination.total).toBe(2)\n\n      // Verify no soft-deleted records in response\n      const titles = data.records.map((r: { fields: { title: string } }) => r.fields.title)\n      expect(titles).toContain('Active Task 1')\n      expect(titles).toContain('Active Task 2')\n      expect(titles).not.toContain('Deleted Task')\n      expect(titles).not.toContain('Another Deleted')\n    }\n  )\n\n  test(\n    'API-TABLES-RECORDS-LIST-025: should include deleted with includeDeleted=true',\n    { tag: '@spec' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // GIVEN: Table with mix of active and soft-deleted records\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 28,\n            name: 'tasks',\n            fields: [\n              { id: 1, name: 'title', type: 'single-line-text', required: true },\n              { id: 2, name: 'status', type: 'single-line-text' },\n              { id: 3, name: 'deleted_at', type: 'deleted-at', indexed: true },\n            ],\n          },\n        ],\n      })\n      await executeQuery(`\n        INSERT INTO tasks (id, title, status, deleted_at) VALUES\n          (1, 'Active Task', 'pending', NULL),\n          (2, 'Deleted Task 1', 'completed', NOW()),\n          (3, 'Deleted Task 2', 'in_progress', NOW())\n      `)\n\n      // Create authenticated user\n      await createAuthenticatedUser()\n\n      // WHEN: User requests records with includeDeleted=true\n      const response = await request.get('/api/tables/28/records', {\n        params: {\n          includeDeleted: 'true',\n        },\n      })\n\n      // THEN: Returns 200 with all records (including soft-deleted)\n      expect(response.status()).toBe(200)\n\n      const data = await response.json()\n      // THEN: All 3 records returned (active + soft-deleted)\n      expect(data.records).toHaveLength(3)\n      expect(data.pagination.total).toBe(3)\n\n      // THEN: Deleted records should have deleted_at field populated\n      const deletedRecords = data.records.filter(\n        (r: { fields: { deleted_at: string | null } }) => r.fields.deleted_at !== null\n      )\n      expect(deletedRecords).toHaveLength(2)\n    }\n  )\n\n  // ============================================================================\n  // @regression test (exactly one) - OPTIMIZED integration\n  // ============================================================================\n\n  test.fixme(\n    'API-TABLES-RECORDS-LIST-REGRESSION: user can complete full list records workflow',\n    { tag: '@regression' },\n    async ({ request, startServerWithSchema, executeQuery, createAuthenticatedUser }) => {\n      // ========================================================================\n      // SETUP: Consolidated schema with all fields needed for regression tests\n      // ========================================================================\n      await startServerWithSchema({\n        name: 'test-app',\n        auth: { emailAndPassword: true },\n        tables: [\n          {\n            id: 1,\n            name: 'projects',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text', required: true },\n              { id: 2, name: 'status', type: 'single-line-text', default: 'active' },\n              { id: 3, name: 'priority', type: 'integer', default: 1 },\n              { id: 4, name: 'budget', type: 'currency', currency: 'USD' },\n              { id: 5, name: 'created_at', type: 'created-at' },\n              { id: 6, name: 'deleted_at', type: 'deleted-at', indexed: true },\n            ],\n          },\n          {\n            id: 2,\n            name: 'users',\n            fields: [\n              { id: 1, name: 'name', type: 'single-line-text' },\n              { id: 2, name: 'email', type: 'email', required: true },\n              { id: 3, name: 'phone', type: 'phone-number' },\n              { id: 4, name: 'address', type: 'long-text' },\n              { id: 5, name: 'salary', type: 'currency', currency: 'USD' },\n            ],\n          },\n        ],\n      })\n\n      // Create authenticated user for all test steps\n      await createAuthenticatedUser()\n\n      // ========================================================================\n      // TEST STEPS: Each step corresponds to a @spec test\n      // ========================================================================\n\n      await test.step('API-TABLES-RECORDS-LIST-001: Returns 200 with array of records and pagination', async () => {\n        // Setup: Insert 3 records\n        await executeQuery(`\n          INSERT INTO projects (name, status, priority)\n          VALUES\n            ('Project Alpha', 'active', 5),\n            ('Project Beta', 'completed', 3),\n            ('Project Gamma', 'active', 4)\n        `)\n\n        const response = await request.get('/api/tables/1/records', {})\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data).toHaveProperty('records')\n        expect(data).toHaveProperty('pagination')\n        expect(data.records).toHaveLength(3)\n        expect(data.pagination.total).toBe(3)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-002: Returns 404 for non-existent table', async () => {\n        const response = await request.get('/api/tables/9999/records', {})\n        expect(response.status()).toBe(404)\n\n        const data = await response.json()\n        expect(data.error).toBe('Table not found')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-003: Returns filtered records by status', async () => {\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            filter: JSON.stringify({\n              and: [{ field: 'status', operator: 'equals', value: 'active' }],\n            }),\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records).toHaveLength(2)\n        expect(data.pagination.total).toBe(2)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-004: Returns records sorted by priority descending', async () => {\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            sort: 'priority:desc',\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records).toHaveLength(3)\n        expect(data.records[0].fields.priority).toBe(5)\n        expect(data.records[1].fields.priority).toBe(4)\n        expect(data.records[2].fields.priority).toBe(3)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-005: Returns only specified fields', async () => {\n        // Setup: Insert user record\n        await executeQuery(`\n          INSERT INTO users (name, email, phone, address)\n          VALUES ('John Doe', 'john@example.com', '555-0100', '123 Main St')\n        `)\n\n        const response = await request.get('/api/tables/2/records', {\n          params: {\n            fields: 'id,name,email',\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records).toHaveLength(1)\n        expect(data.records[0]).toHaveProperty('id')\n        expect(data.records[0]).toHaveProperty('name')\n        expect(data.records[0]).toHaveProperty('email')\n        expect(data.records[0]).not.toHaveProperty('phone')\n        expect(data.records[0]).not.toHaveProperty('address')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-006: Returns paginated records with limit and offset', async () => {\n        // Setup: Insert 100 items for pagination test\n        const insertValues = Array.from(\n          { length: 100 },\n          (_, i) => `('Item ${i + 1}', 'active', 1)`\n        ).join(',')\n        await executeQuery(`INSERT INTO projects (name, status, priority) VALUES ${insertValues}`)\n\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            limit: '20',\n            offset: '40',\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records).toHaveLength(20)\n        expect(data.pagination.total).toBe(103) // 3 from earlier + 100 new\n        expect(data.pagination.limit).toBe(20)\n        expect(data.pagination.offset).toBe(40)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-007: Returns records filtered by view', async () => {\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            view: 'active_only',\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records.length).toBeGreaterThan(0)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-008: Returns records grouped by field', async () => {\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            groupBy: 'status',\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data).toHaveProperty('records')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-009: Returns aggregation results', async () => {\n        // Clear and setup specific data for aggregation\n        await executeQuery(`DELETE FROM projects`)\n        await executeQuery(`\n          INSERT INTO projects (name, budget, priority)\n          VALUES\n            ('Project A', 10000, 5),\n            ('Project B', 20000, 3),\n            ('Project C', 15000, 4)\n        `)\n\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            aggregate: JSON.stringify({\n              count: true,\n              sum: ['budget'],\n              avg: ['priority'],\n            }),\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data).toHaveProperty('aggregations')\n        expect(data.aggregations.count).toBe('3')\n        expect(data.aggregations.sum.budget).toBe(45_000)\n        expect(data.aggregations.avg.priority).toBeCloseTo(4, 1)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-010: Returns records matching formula filter', async () => {\n        // Clear and setup specific data for formula test\n        await executeQuery(`DELETE FROM projects`)\n        await executeQuery(`\n          INSERT INTO projects (name, status, priority)\n          VALUES\n            ('High Priority Active', 'active', 5),\n            ('Low Priority Active', 'active', 1),\n            ('High Priority Done', 'completed', 5)\n        `)\n\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            filterByFormula: \"AND({status}='active', {priority}>=3)\",\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records).toHaveLength(1)\n        expect(data.records[0].fields.name).toBe('High Priority Active')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-011: Returns records with multi-field sort', async () => {\n        // Clear and setup specific data for multi-sort test\n        await executeQuery(`DELETE FROM projects`)\n        await executeQuery(`\n          INSERT INTO projects (priority, created_at)\n          VALUES\n            (5, '2025-01-01'),\n            (5, '2025-01-02'),\n            (3, '2025-01-03')\n        `)\n\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            sort: 'priority:desc,created_at:desc',\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records[0].fields.priority).toBe(5)\n        expect(data.records[1].fields.priority).toBe(5)\n        expect(data.records[2].fields.priority).toBe(3)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-012: Returns records with view and explicit filters combined', async () => {\n        // Clear and setup specific data\n        await executeQuery(`DELETE FROM projects`)\n        await executeQuery(`\n          INSERT INTO projects (name, status, priority)\n          VALUES\n            ('High Active', 'active', 5),\n            ('Low Active', 'active', 1)\n        `)\n\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            view: 'active_only',\n            filter: JSON.stringify({\n              and: [{ field: 'priority', operator: 'greaterThanOrEqual', value: 3 }],\n            }),\n          },\n        })\n\n        expect(response.status()).toBe(200)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-013: Returns 401 for unauthenticated request', async () => {\n        const response = await request.get('/api/tables/1/records')\n        expect(response.status()).toBe(401)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-014: Returns 403 for user without read permission', async () => {\n        const response = await request.get('/api/tables/1/records', {})\n        expect(response.status()).toBe(403)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-015: Returns all fields for admin user', async () => {\n        // Clear and setup employee data\n        await executeQuery(`DELETE FROM users`)\n        await executeQuery(`\n          INSERT INTO users (name, email, salary)\n          VALUES ('John Doe', 'john@example.com', 75000)\n        `)\n\n        const response = await request.get('/api/tables/2/records', {})\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records[0]).toHaveProperty('salary')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-016: Excludes salary field for member user', async () => {\n        const response = await request.get('/api/tables/2/records', {})\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records[0]).toHaveProperty('name')\n        expect(data.records[0]).toHaveProperty('email')\n        expect(data.records[0]).not.toHaveProperty('salary')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-017: Returns minimal fields for viewer', async () => {\n        await executeQuery(`DELETE FROM users`)\n        await executeQuery(`\n          INSERT INTO users (name, email, phone, salary)\n          VALUES ('John Doe', 'john@example.com', '555-0100', 75000)\n        `)\n\n        const response = await request.get('/api/tables/2/records', {})\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records[0]).toHaveProperty('id')\n        expect(data.records[0]).toHaveProperty('name')\n        expect(data.records[0]).not.toHaveProperty('email')\n        expect(data.records[0]).not.toHaveProperty('salary')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-018: Returns empty array with 200 for no matching records', async () => {\n        await executeQuery(`DELETE FROM projects`)\n\n        const response = await request.get('/api/tables/1/records', {})\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records).toHaveLength(0)\n        expect(data.pagination.total).toBe(0)\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-019: Paginates with field filtering', async () => {\n        // Setup 50 employee records\n        const insertValues = Array.from(\n          { length: 50 },\n          (_, i) => `('Employee ${i + 1}', 'emp${i + 1}@example.com', ${50_000 + i * 1000})`\n        ).join(',')\n        await executeQuery(`DELETE FROM users`)\n        await executeQuery(`INSERT INTO users (name, email, salary) VALUES ${insertValues}`)\n\n        const response = await request.get('/api/tables/2/records', {\n          params: {\n            limit: '10',\n            offset: '20',\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records).toHaveLength(10)\n        expect(data.pagination.offset).toBe(20)\n        expect(data.records[0]).not.toHaveProperty('salary')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-020: Returns 403 when sorting by inaccessible field', async () => {\n        const response = await request.get('/api/tables/2/records', {\n          params: {\n            sort: 'salary:desc',\n          },\n        })\n\n        expect(response.status()).toBe(403)\n\n        const data = await response.json()\n        expect(data.error).toBe('Forbidden')\n        expect(data.message).toContain('Cannot sort by field')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-021: Returns 403 when filtering by inaccessible field', async () => {\n        const response = await request.get('/api/tables/2/records', {\n          params: {\n            filter: JSON.stringify({\n              and: [{ field: 'salary', operator: 'greaterThan', value: 60_000 }],\n            }),\n          },\n        })\n\n        expect(response.status()).toBe(403)\n\n        const data = await response.json()\n        expect(data.error).toBe('Forbidden')\n        expect(data.message).toContain('Cannot filter by field')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-022: Returns 403 when aggregating inaccessible field', async () => {\n        const response = await request.get('/api/tables/2/records', {\n          params: {\n            aggregate: JSON.stringify({\n              sum: ['salary'],\n              avg: ['salary'],\n            }),\n          },\n        })\n\n        expect(response.status()).toBe(403)\n\n        const data = await response.json()\n        expect(data.error).toBe('Forbidden')\n        expect(data.message).toContain('Cannot aggregate field')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-023: Returns aggregations for accessible fields only', async () => {\n        await executeQuery(`DELETE FROM projects`)\n        await executeQuery(`\n          INSERT INTO projects (name, priority, budget)\n          VALUES\n            ('P1', 5, 10000),\n            ('P2', 3, 20000),\n            ('P3', 4, 15000)\n        `)\n\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            aggregate: JSON.stringify({\n              count: true,\n              avg: ['priority'],\n            }),\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.aggregations.count).toBe('3')\n        expect(data.aggregations.avg.priority).toBe(4)\n        expect(data.aggregations.avg).not.toHaveProperty('budget')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-024: Excludes soft-deleted records by default', async () => {\n        await executeQuery(`DELETE FROM projects`)\n        await executeQuery(`\n          INSERT INTO projects (id, name, status, deleted_at) VALUES\n            (1, 'Active Task 1', 'pending', NULL),\n            (2, 'Deleted Task', 'completed', NOW()),\n            (3, 'Active Task 2', 'in_progress', NULL),\n            (4, 'Another Deleted', 'pending', NOW())\n        `)\n\n        const response = await request.get('/api/tables/1/records', {})\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records).toHaveLength(2)\n        expect(data.pagination.total).toBe(2)\n\n        const titles = data.records.map((r: { fields: { name: string } }) => r.fields.name)\n        expect(titles).toContain('Active Task 1')\n        expect(titles).toContain('Active Task 2')\n        expect(titles).not.toContain('Deleted Task')\n        expect(titles).not.toContain('Another Deleted')\n      })\n\n      await test.step('API-TABLES-RECORDS-LIST-025: Includes deleted records with includeDeleted=true', async () => {\n        await executeQuery(`DELETE FROM projects`)\n        await executeQuery(`\n          INSERT INTO projects (id, name, status, deleted_at) VALUES\n            (1, 'Active Task', 'pending', NULL),\n            (2, 'Deleted Task 1', 'completed', NOW()),\n            (3, 'Deleted Task 2', 'in_progress', NOW())\n        `)\n\n        const response = await request.get('/api/tables/1/records', {\n          params: {\n            includeDeleted: 'true',\n          },\n        })\n\n        expect(response.status()).toBe(200)\n\n        const data = await response.json()\n        expect(data.records).toHaveLength(3)\n        expect(data.pagination.total).toBe(3)\n\n        const deletedRecords = data.records.filter(\n          (r: { fields: { deleted_at: string | null } }) => r.fields.deleted_at !== null\n        )\n        expect(deletedRecords).toHaveLength(2)\n      })\n    }\n  )\n})\n"
}